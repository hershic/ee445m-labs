#+startup: all
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) DOCUMENT(m) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) CANCELED(c)
"In a real time system there is no point in finishing your task before
the deadline." -- Gerstlauer
* [0/1] SysTick
** TODO Initialization macro
convert this code into a single call that is readable, i.e. you can
immediately tell to what frequency/period the SysTick will interrupt.
#+BEGIN_SRC c :tangle no
  SysTickPeriodSet(SysCtlClockGet() / 10);
  SysTickEnable();
  SysTickIntEnable();
#+END_SRC
* [0/5] OS
** TODO Thread addition macro
Create a macro to map over supplied threads and do this sort of
initialization. The only next step is os_launch, which should still be
called separately (comment created <2015-02-17 Tue>).
#+BEGIN_SRC c :tangle no
  IntMasterDisable();
  os_threading_init();
  os_add_thread(Thread1);
  os_add_thread(Thread2);
  os_add_thread(Thread3);
#+END_SRC
** TODO Convert to libut/utlist
** TODO fn to get tcb from thread's starting point
#+BEGIN_SRC c :tangle no
  void idle();
  os_add_thread(idle);
  os_get_tcb(idle); // returns the tcb containing idle
#+END_SRC
** TODO define os_surrender_execution
** TODO Create semaphore.dox
** [0/2] define schedulers
See Rate Monotonic Scheduling for inspiration
- [ ] round-robin
- [ ] at least one other
* [0/1] Nexus
** TODO interruptless-blocks
a lisp/ruby-style object to accept a block and ensure no interrupts
fire while it is executing (makes it atomic, wraps with Critical
sections, something of the sort)
* [0/1] Jitter
** TODO create library
* [0/5] Debugging and total authoritarianism enforcement
** TODO Check on changed immutables?
** TODO create automated testing framework
urged by lecture <2015-02-17 Tue>
- place a magic packet in memory at the end of your stack, check for
  changed contents
** TODO create stack watcher
die on attempted overflow
** TODO reposition the memory
don't shoot yourself in the foot with a lodaed stac
(insert picture here)
** TODO path expressions
urged by lecture <2015-02-17 Tue>
[[http://en.wikipedia.org/wiki/Eiffel_(programming_language)][Eiffel (programming language)]]
[[./img/path_expressions_lec04.png]]
- specify and enforce correct calling order
- represented as a graph
  choose one of the following representations based on sparseness of
  the data structures:
  - adjacency list
  - adjacency matrix
* [0/1] Doxygen
** TODO add everythig to a group! it's all we have sans c++ inheritance.
