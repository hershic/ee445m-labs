<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EE 445M: Epi_api</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">EE 445M
   
   </div>
   <div id="projectbrief">Real Time Operating Systems taken at University of Texas Spring 2015</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__epi__api.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Epi_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9dfec815ec7fa028f90a39b1a4d315ca">EPI_HB16_CS_MASK</a>&#160;&#160;&#160;(<a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a> | <a class="el" href="epi_8h.html#a130064adefdd390094f5c1d4d2296b77">EPI_HB16_BURST_TRAFFIC</a>)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaaf954738021f0632426c67962aedf8e7">EPIWorkaroundWordWrite</a> (uint32_t *pui32Addr, uint32_t ui32Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga47dd18169c4f1dd367fc7ac6d0256c98">EPIWorkaroundWordRead</a> (uint32_t *pui32Addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae0a50bfa91729092980cca2ec63ec84f">EPIWorkaroundHWordWrite</a> (uint16_t *pui16Addr, uint16_t ui16Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad71f8ad921035840a193e61195043f19">EPIWorkaroundHWordRead</a> (uint16_t *pui16Addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga77ba9dc9e83289991e8f14761c878700">EPIWorkaroundByteWrite</a> (uint8_t *pui8Addr, uint8_t ui8Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga5fdafd7c230548f932c7c97bf10edede">EPIWorkaroundByteRead</a> (uint8_t *pui8Addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet</a> (uint32_t ui32Base, uint32_t ui32Mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet</a> (uint32_t ui32Base, uint32_t ui32Divider)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Divider)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7bb1dc9e6eed9bfcf5565cd930b0f22b">EPIDMATxCount</a> (uint32_t ui32Base, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">EPIConfigSDRAMSet</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32Refresh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga1a2bf596b8c09862989df76bc781c2e3">EPIConfigHB8TimingSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga404cc115292a3c173d64ed6c38e793f3">EPIConfigHB16TimingSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gabcbbd4afec4caf570bc1dbfdd0169c99">EPIPSRAMConfigRegSet</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32CR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead</a> (uint32_t ui32Base, uint32_t ui32CS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga7028e21f0e37f8f79e94855c56ce0d8c">EPIPSRAMConfigRegGetNonBlocking</a> (uint32_t ui32Base, uint32_t ui32CS, uint32_t *pui32CR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac078ff4e388a21abdd0e63aae2d96960">EPIPSRAMConfigRegGet</a> (uint32_t ui32Base, uint32_t ui32CS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9544feee05f3e0342a8092ff87f9bad2">EPIConfigGPModeSet</a> (uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32FrameCount, uint32_t ui32MaxWait)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet</a> (uint32_t ui32Base, uint32_t ui32Map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure</a> (uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32DataSize, uint32_t ui32Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart</a> (uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaa5fa0e80a591d62a6b84f09f47a71afa">EPINonBlockingReadStop</a> (uint32_t ui32Base, uint32_t ui32Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga3decd0254b5104255b9dbe1e02936ff6">EPINonBlockingReadCount</a> (uint32_t ui32Base, uint32_t ui32Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaecfc47bee6a379ced21c9ecf984f2888">EPINonBlockingReadAvail</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac8a09fac58328065e92a61fdd31cdcc0">EPINonBlockingReadGet32</a> (uint32_t ui32Base, uint32_t ui32Count, uint32_t *pui32Buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaac0645c23368a2e768a27010e714e7cf">EPINonBlockingReadGet16</a> (uint32_t ui32Base, uint32_t ui32Count, uint16_t *pui16Buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gaf7df76c4aa477ec5f48e682d9a420903">EPINonBlockingReadGet8</a> (uint32_t ui32Base, uint32_t ui32Count, uint8_t *pui8Buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9c11b58182855b534e42cf0357b4db72">EPIFIFOConfig</a> (uint32_t ui32Base, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gab9983fa4529a274cd1b09f5a10cbbdd0">EPIWriteFIFOCountGet</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gac477f3e293ed8e771fc05450cd6c28d5">EPIIntDisable</a> (uint32_t ui32Base, uint32_t ui32IntFlags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad6fcb9023d51da8af50f924dd64e9e72">EPIIntErrorStatus</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga14adf0b4a609b3635ef98c2223ada115">EPIIntErrorClear</a> (uint32_t ui32Base, uint32_t ui32ErrFlags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85">_EPIIntNumberGet</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga4b2d512849c4f92fc15196d62ff30bd2">EPIIntRegister</a> (uint32_t ui32Base, void(*pfnHandler)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__epi__api.html#ga9375b854f9a595e2b0b0a712829cf8aa">EPIIntUnregister</a> (uint32_t ui32Base)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga9dfec815ec7fa028f90a39b1a4d315ca"></a><!-- doxytag: member="epi.c::EPI_HB16_CS_MASK" ref="ga9dfec815ec7fa028f90a39b1a4d315ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__epi__api.html#ga9dfec815ec7fa028f90a39b1a4d315ca">EPI_HB16_CS_MASK</a>&#160;&#160;&#160;(<a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a> | <a class="el" href="epi_8h.html#a130064adefdd390094f5c1d4d2296b77">EPI_HB16_BURST_TRAFFIC</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="epi_8c_source.html#l00067">67</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>Referenced by <a class="el" href="epi_8c_source.html#l00877">EPIConfigHB16CSSet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga96755362386f5ced366f5ae9a46ea513"></a><!-- doxytag: member="epi.c::EPI_HB8_CS_MASK" ref="ga96755362386f5ced366f5ae9a46ea513" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="epi_8h.html#aa1b5d4fe0d20aa8ec95b5326a75fa616">EPI_HB8_MODE_FIFO</a> | <a class="code" href="epi_8h.html#a39f59d28f3d23a19df186562d4f41702">EPI_HB8_RDWAIT_3</a> |       \
                                 EPI_HB8_WRWAIT_3 | <a class="code" href="epi_8h.html#ade4a1b8e90598bde97094372c5863293">EPI_HB8_RDHIGH</a> |          \
                                 EPI_HB8_WRHIGH | <a class="code" href="epi_8h.html#a75c20f10ed8d6b18a809453cd106b995">EPI_HB8_ALE_HIGH</a>)
</pre></div>
<p>Definition at line <a class="el" href="epi_8c_source.html#l00063">63</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>Referenced by <a class="el" href="epi_8c_source.html#l00790">EPIConfigHB8CSSet()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad2c7e37d7576307a5d9b903f65f42a85"></a><!-- doxytag: member="epi.c::_EPIIntNumberGet" ref="gad2c7e37d7576307a5d9b903f65f42a85" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t <a class="el" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85">_EPIIntNumberGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the interrupt number for a given EPI base address.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the EPI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt number for the EPI module with the base address passed in the <em>ui32Base</em> parameter.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the EPI interrupt number or 0 if the interrupt does not exist. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l02070">2070</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00099">CLASS_IS_TM4C129</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, and <a class="el" href="hw__ints_8h_source.html#l00226">INT_EPI0_TM4C129</a>.</p>

<p>Referenced by <a class="el" href="epi_8c_source.html#l02111">EPIIntRegister()</a>, and <a class="el" href="epi_8c_source.html#l02155">EPIIntUnregister()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// By default, assume EPI is not supported.</span>
    <span class="comment">//</span>
    ui32Int = 0;

    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
    {
        ui32Int = <a class="code" href="hw__ints_8h.html#afbaf3596b72d11e1b381928a06dc8f84">INT_EPI0_TM4C129</a>;
    }

    <span class="keywordflow">return</span>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__epi__api_gad2c7e37d7576307a5d9b903f65f42a85_icgraph.png" border="0" usemap="#group__epi__api_gad2c7e37d7576307a5d9b903f65f42a85_icgraph" alt=""/></div>
<map name="group__epi__api_gad2c7e37d7576307a5d9b903f65f42a85_icgraph" id="group__epi__api_gad2c7e37d7576307a5d9b903f65f42a85_icgraph">
<area shape="rect" id="node3" href="group__epi__api.html#ga4b2d512849c4f92fc15196d62ff30bd2" title="EPIIntRegister" alt="" coords="193,5,300,35"/><area shape="rect" id="node5" href="group__epi__api.html#ga9375b854f9a595e2b0b0a712829cf8aa" title="EPIIntUnregister" alt="" coords="188,59,305,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gae781a5be3fc69203242a16f34feae2cf"></a><!-- doxytag: member="epi.c::EPIAddressMapSet" ref="gae781a5be3fc69203242a16f34feae2cf" args="(uint32_t ui32Base, uint32_t ui32Map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gae781a5be3fc69203242a16f34feae2cf">EPIAddressMapSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the address map for the external interface.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Map</td><td>is the address mapping configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the address mapping for the external interface, which then determines the base address of the external memory or device within the processor peripheral and/or memory space.</p>
<p>The parameter <em>ui32Map</em> is the logical OR of the following:</p>
<ul>
<li>Peripheral address space size, select one of:<ul>
<li><b>EPI_ADDR_PER_SIZE_256B</b> sets the peripheral address space to 256 bytes.</li>
<li><b>EPI_ADDR_PER_SIZE_64KB</b> sets the peripheral address space to 64 Kbytes.</li>
<li><b>EPI_ADDR_PER_SIZE_16MB</b> sets the peripheral address space to 16 Mbytes.</li>
<li><b>EPI_ADDR_PER_SIZE_256MB</b> sets the peripheral address space to 256 Mbytes.</li>
</ul>
</li>
<li>Peripheral base address, select one of:<ul>
<li><b>EPI_ADDR_PER_BASE_NONE</b> sets the peripheral base address to none.</li>
<li><b>EPI_ADDR_PER_BASE_A</b> sets the peripheral base address to 0xA0000000.</li>
<li><b>EPI_ADDR_PER_BASE_C</b> sets the peripheral base address to 0xC0000000.</li>
</ul>
</li>
<li>RAM address space, select one of:<ul>
<li><b>EPI_ADDR_RAM_SIZE_256B</b> sets the RAM address space to 256 bytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_64KB</b> sets the RAM address space to 64 Kbytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_16MB</b> sets the RAM address space to 16 Mbytes.</li>
<li><b>EPI_ADDR_RAM_SIZE_256MB</b> sets the RAM address space to 256 Mbytes.</li>
</ul>
</li>
<li>RAM base address, select one of:<ul>
<li><b>EPI_ADDR_RAM_BASE_NONE</b> sets the RAM space address to none.</li>
<li><b>EPI_ADDR_RAM_BASE_6</b> sets the RAM space address to 0x60000000.</li>
<li><b>EPI_ADDR_RAM_BASE_8</b> sets the RAM space address to 0x80000000.</li>
</ul>
</li>
<li><b>EPI_ADDR_RAM_QUAD_MODE</b> maps CS0n to 0x60000000, CS1n to 0x80000000, CS2n to 0xA0000000, and CS3n to 0xC0000000.</li>
<li><b>EPI_ADDR_CODE_SIZE_256B</b> sets an external code size of 256 bytes, range 0x00 to 0xFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_64KB</b> sets an external code size of 64 Kbytes, range 0x0000 to 0xFFFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_16MB</b> sets an external code size of 16 Mbytes, range 0x000000 to 0xFFFFFF.</li>
<li><b>EPI_ADDR_CODE_SIZE_256MB</b> sets an external code size of 256 Mbytes, range 0x0000000 to 0xFFFFFFF.</li>
<li><b>EPI_ADDR_CODE_BASE_NONE</b> sets external code base to not mapped.</li>
<li><b>EPI_ADDR_CODE_BASE_1</b> sets external code base to 0x10000000.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of <b>EPI_ADDR_RAM_QUAD_MODE</b> and <b>EPI_ADDR_CODE_*</b> varies based on the Tiva part in use. Please consult the data sheet to determine if these features are available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01415">1415</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00059">EPI_O_ADDRMAP</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Map &lt; 0x1000);

    <span class="comment">//</span>
    <span class="comment">// Set the value of the address mapping register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a6e502121ee45669b1fb6f6c7d4355cf2">EPI_O_ADDRMAP</a>) = ui32Map;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9544feee05f3e0342a8092ff87f9bad2"></a><!-- doxytag: member="epi.c::EPIConfigGPModeSet" ref="ga9544feee05f3e0342a8092ff87f9bad2" args="(uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32FrameCount, uint32_t ui32MaxWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga9544feee05f3e0342a8092ff87f9bad2">EPIConfigGPModeSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FrameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the interface for general-purpose mode operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32FrameCount</td><td>is the frame size in clocks, if the frame signal is used (0-15). </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is currently not used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in general-purpose operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li><b>EPI_GPMODE_CLKPIN</b> interface clock as output on a pin.</li>
<li><b>EPI_GPMODE_CLKGATE</b> clock is stopped when there is no transaction, otherwise it is free-running.</li>
<li><b>EPI_GPMODE_FRAME50</b> framing signal is 50/50 duty cycle, otherwise it is a pulse.</li>
<li><b>EPI_GPMODE_WRITE2CYCLE</b> a two-cycle write is used, otherwise a single-cycle write is used.</li>
<li>Address bus size, select one of:<ul>
<li><b>EPI_GPMODE_ASIZE_NONE</b> sets no address bus.</li>
<li><b>EPI_GPMODE_ASIZE_4</b> sets an address bus size of 4 bits.</li>
<li><b>EPI_GPMODE_ASIZE_12</b> sets an address bus size of 12 bits.</li>
<li><b>EPI_GPMODE_ASIZE_20</b> sets an address bus size of 20 bits.</li>
</ul>
</li>
<li>Data bus size, select one of:<ul>
<li><b>EPI_GPMODE_DSIZE_8</b> sets a data bus size of 8 bits.</li>
<li><b>EPI_GPMODE_DSIZE_16</b> sets a data bus size of 16 bits.</li>
<li><b>EPI_GPMODE_DSIZE_24</b> sets a data bus size of 24 bits.</li>
<li><b>EPI_GPMODE_DSIZE_32</b> sets a data bus size of 32 bits.</li>
</ul>
</li>
</ul>
<p>The parameter <em>ui32FrameCount</em> is the number of clocks used to form the framing signal, if the framing signal is used. The behavior depends on whether the frame signal is a pulse or a 50/50 duty cycle.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01335">1335</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00178">EPI_GPCFG_FRMCNT_M</a>, <a class="el" href="hw__epi_8h_source.html#l00193">EPI_GPCFG_FRMCNT_S</a>, <a class="el" href="hw__epi_8h_source.html#l00053">EPI_O_GPCFG</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32FrameCount &lt; 16);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32MaxWait &lt; 256);

    <span class="comment">//</span>
    <span class="comment">// Fill in the frame count field of the configuration word.</span>
    <span class="comment">//</span>
    ui32Config &amp;= ~<a class="code" href="hw__epi_8h.html#ab6c41669f6a6d6a1c3aec3b53e605f62">EPI_GPCFG_FRMCNT_M</a>;
    ui32Config |= ui32FrameCount &lt;&lt; <a class="code" href="hw__epi_8h.html#a69cdb65b7c0d9d61a6f6c22c68f12df6">EPI_GPCFG_FRMCNT_S</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the non-moded configuration register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a6a75ead6054642f400ec9d11b9011508">EPI_O_GPCFG</a>) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae6d88d2589bd63fd23fbfa403dc688a5"></a><!-- doxytag: member="epi.c::EPIConfigHB16CSSet" ref="gae6d88d2589bd63fd23fbfa403dc688a5" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the individual chip select configuration for the Host-bus 16 interface.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure individual chip select settings for the Host-bus 16 interface mode. <a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set()</a> must have been set up with the <b>EPI_HB16_CSBAUD</b> flag for the individual chip select configuration option to be available.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR the following:</p>
<ul>
<li>Host-bus 16 submode, select one of:<ul>
<li><b>EPI_HB16_MODE_ADMUX</b> sets data and address muxed, AD[15:0].</li>
<li><b>EPI_HB16_MODE_ADDEMUX</b> sets up data and address separate, D[15:0].</li>
<li><b>EPI_HB16_MODE_SRAM</b> same as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[15:0].</li>
<li><b>EPI_HB16_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[15:0]. This feature is only available on CS0n and CS1n.</li>
</ul>
</li>
<li><b>EPI_HB16_WRHIGH</b> sets active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB16_RDHIGH</b> sets active high read strobe, otherwise it is active low.</li>
<li>Write wait state when <b>EPI_HB16_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB16_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
<li>Read wait state when <b>EPI_HB16_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB16_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB16_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB16_ALE_LOW</b> sets address latch active low.</li>
<li><b>EPI_HB16_BURST_TRAFFIC</b> enables burst traffic. Only valid with <b>EPI_HB16_MODE_ADMUX</b> and a chip select configuration that utilizes an ALE.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of the unique chip select configuration within the Host-bus 16 interface mode varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00877">877</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="epi_8c_source.html#l00067">EPI_HB16_CS_MASK</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00085">EPI_O_HB16CFG3</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset, ui32Reg;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Preserve the bits that will not be modified.</span>
    <span class="comment">//</span>
    ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) &amp; ~<a class="code" href="group__epi__api.html#ga9dfec815ec7fa028f90a39b1a4d315ca">EPI_HB16_CS_MASK</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the target chip select HostBus16 configuration fields.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) = (ui32Reg | ui32Config);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga7d612e5b8a15f344097625817a2a415a"></a><!-- doxytag: member="epi.c::EPIConfigHB16Set" ref="ga7d612e5b8a15f344097625817a2a415a" args="(uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga7d612e5b8a15f344097625817a2a415a">EPIConfigHB16Set</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the interface for Host-bus 16 operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is the maximum number of external clocks to wait if a FIFO ready signal is holding off the transaction.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in Host-bus 16 operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Host-bus 16 submode, select one of:<ul>
<li><b>EPI_HB16_MODE_ADMUX</b> sets data and address muxed, AD[15:0].</li>
<li><b>EPI_HB16_MODE_ADDEMUX</b> sets up data and address as separate, D[15:0].</li>
<li><b>EPI_HB16_MODE_SRAM</b> sets as <b>EPI_HB16_MODE_ADDEMUX</b> but uses address switch for multiple reads instead of OEn strobing, D[15:0].</li>
<li><b>EPI_HB16_MODE_FIFO</b> addes XFIFO controls with sense of XFIFO full and XFIFO empty, D[15:0]. This submode uses no address or ALE.</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB16_USE_TXEMPTY</b> enables TXEMPTY signal with FIFO.</li>
<li><b>EPI_HB16_USE_RXFULL</b> enables RXFULL signal with FIFO.</li>
<li><b>EPI_HB16_WRHIGH</b> use active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB16_RDHIGH</b> use active high read strobe, otherwise it is active low.</li>
<li>Write wait state, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_0</b> sets write wait state to 2 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
</ul>
<ul>
<li>Read wait state, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_0</b> sets read wait state to 2 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB16_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB16_WORD_ACCESS</b> use Word Access mode to route bytes to the correct byte lanes allowing data to be stored in bits [31:16]. If absent, all data transfers use bits [15:0].</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd><b>EPI_HB16_WORD_ACCESS</b> is not available on all parts. Please consult the data sheet to determine if this feature is available.</dd></dl>
<ul>
<li><b>EPI_HB16_CLOCK_GATE_IDLE</b> holds the EPI clock low when no data is available to read or write.</li>
<li><b>EPI_HB16_CLOCK_INVERT</b> inverts the EPI clock.</li>
<li><b>EPI_HB16_IN_READY_EN</b> sets EPIS032 as a ready/stall signal, active high.</li>
<li><b>EPI_HB16_IN_READY_EN_INVERTED</b> sets EPIS032 as ready/stall signal, active low.</li>
<li>Address latch logic, select one of:<ul>
<li><b>EPI_HB16_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB16_ALE_LOW</b> sets address latch active low.</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB16_BURST_TRAFFIC</b> enables burst traffic. Only valid with <b>EPI_HB16_MODE_ADMUX</b> and a chip select configuration that utilizes an ALE.</li>
<li><b>EPI_HB16_BSEL</b> enables byte selects. In this mode, two EPI signals operate as byte selects allowing 8-bit transfers. If this flag is not specified, data must be read and written using only 16-bit transfers.</li>
<li><b>EPI_HB16_CSBAUD</b> use different baud rates when accessing devices on each chip select. CS0n uses the baud rate specified by the lower 16 bits of the divider passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> and CS1n uses the divider passed in the upper 16 bits. If this option is absent, both chip selects use the baud rate resulting from the divider in the lower 16 bits of the parameter passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a>.</li>
</ul>
<p>In addition, some parts support CS2n and CS3n for a total of 4 chip selects. If <b>EPI_HB16_CSBAUD</b> is configured, <a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet()</a> should be used to to configure the divider for CS2n and CS3n. They both also use the lower 16 bits passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> if this option is absent.</p>
<p>The use of <b>EPI_HB16_CSBAUD</b> also allows for unique chip select configurations. CS0n, CS1n, CS2n, and CS3n can each be configured by calling <a class="el" href="group__epi__api.html#gae6d88d2589bd63fd23fbfa403dc688a5">EPIConfigHB16CSSet()</a> if <b>EPI_HB16_CSBAUD</b> is used. Otherwise, the configuration provided in <em>ui32Config</em> is used for all chip selects.</p>
<ul>
<li>Chip select configuration, select one of:<ul>
<li><b>EPI_HB16_CSCFG_CS</b> sets EPIS030 to operate as a chip select signal.</li>
<li><b>EPI_HB16_CSCFG_ALE</b> sets EPIS030 to operate as an address latch (ALE).</li>
<li><b>EPI_HB16_CSCFG_DUAL_CS</b> sets EPIS030 to operate as CS0n and EPIS027 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB16_CSCFG_ALE_DUAL_CS</b> sets EPIS030 as an address latch (ALE), EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB16_CSCFG_ALE_SINGLE_CS</b> sets EPIS030 to operate as an address latch (ALE) and EPIS027 is used as a chip select.</li>
<li><b>EPI_HB16_CSCFG_QUAD_CS</b> sets EPIS030 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n.</li>
<li><b>EPI_HB16_CSCFG_ALE_QUAD_CS</b> sets EPIS030 as an address latch (ALE), EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n. <dl class="note"><dt><b>Note:</b></dt><dd>Dual or quad chip select configurations cannot be used with EPI_HB16_MODE_SRAM.</dd></dl>
The parameter <em>ui32MaxWait</em> is used if the FIFO mode is chosen. If a FIFO is used along with RXFULL or TXEMPTY ready signals, then this parameter determines the maximum number of clocks to wait when the transaction is being held off by by the FIFO using one of these ready signals. A value of 0 means to wait forever.</li>
</ul>
</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Availability of configuration options varies based on the Tiva part in use. Please consult the data sheet to determine if the features desired are available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00712">712</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="epi_8h_source.html#l00190">EPI_HB16_CSBAUD</a>, <a class="el" href="epi_8h_source.html#l00191">EPI_HB16_CSCFG_MASK</a>, <a class="el" href="hw__epi_8h_source.html#l00285">EPI_HB16CFG2_CSBAUD</a>, <a class="el" href="hw__epi_8h_source.html#l00151">EPI_HB16CFG_MAXWAIT_M</a>, <a class="el" href="hw__epi_8h_source.html#l00168">EPI_HB16CFG_MAXWAIT_S</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00058">EPI_O_HB16CFG2</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32MaxWait &lt; 256);

    <span class="comment">//</span>
    <span class="comment">// Determine the CS and word access modes.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a15d6738e007ab347b7bba814df49a580">EPI_O_HB16CFG2</a>) =
        ((ui32Config &amp; <a class="code" href="epi_8h.html#a8f7cd9ae5ee9915f5860c4e7e1330328">EPI_HB16_CSBAUD</a>) ? <a class="code" href="hw__epi_8h.html#afd34e71027e0baf18036bdef3d38caee">EPI_HB16CFG2_CSBAUD</a> : 0) |
        ((ui32Config &amp; <a class="code" href="epi_8h.html#abd20b23cde603b9ba132ff7487e11edc">EPI_HB16_CSCFG_MASK</a>) &lt;&lt; 15);

    <span class="comment">//</span>
    <span class="comment">// Fill in the max wait field of the configuration word.</span>
    <span class="comment">//</span>
    ui32Config &amp;= ~<a class="code" href="hw__epi_8h.html#a145f460d460294ab5664032d54b89a89">EPI_HB16CFG_MAXWAIT_M</a>;
    ui32Config |= ui32MaxWait &lt;&lt; <a class="code" href="hw__epi_8h.html#ae847c419bb220ebecac6392fb17dd4b6">EPI_HB16CFG_MAXWAIT_S</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the main HostBus16 configuration register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a>) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga404cc115292a3c173d64ed6c38e793f3"></a><!-- doxytag: member="epi.c::EPIConfigHB16TimingSet" ref="ga404cc115292a3c173d64ed6c38e793f3" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga404cc115292a3c173d64ed6c38e793f3">EPIConfigHB16TimingSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the individual chip select timing settings for the Host-bus 16 interface.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set individual chip select timings for the Host-bus 16 interface mode.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Input ready stall delay, select one of:<ul>
<li><b>EPI_HB16_IN_READY_DELAY_1</b> sets the stall on input ready (EPIS032) to start 1 EPI clock after signaled.</li>
<li><b>EPI_HB16_IN_READY_DELAY_2</b> sets the stall on input ready (EPIS032) to start 2 EPI clocks after signaled.</li>
<li><b>EPI_HB16_IN_READY_DELAY_3</b> sets the stall on input ready (EPIS032) to start 3 EPI clocks after signaled.</li>
</ul>
</li>
</ul>
<ul>
<li>PSRAM size limitation, select one of:<ul>
<li><b>EPI_HB16_PSRAM_NO_LIMIT</b> defines no row size limitation.</li>
<li><b>EPI_HB16_PSRAM_128</b> defines the PSRAM row size to 128 bytes.</li>
<li><b>EPI_HB16_PSRAM_256</b> defines the PSRAM row size to 256 bytes.</li>
<li><b>EPI_HB16_PSRAM_512</b> defines the PSRAM row size to 512 bytes.</li>
<li><b>EPI_HB16_PSRAM_1024</b> defines the PSRAM row size to 1024 bytes.</li>
<li><b>EPI_HB16_PSRAM_2048</b> defines the PSRAM row size to 2048 bytes.</li>
<li><b>EPI_HB16_PSRAM_4096</b> defines the PSRAM row size to 4096 bytes.</li>
<li><b>EPI_HB16_PSRAM_8192</b> defines the PSRAM row size to 8192 bytes.</li>
</ul>
</li>
</ul>
<ul>
<li>Host bus transfer delay, select one of:<ul>
<li><b>EPI_HB16_CAP_WIDTH_1</b> defines the inter-transfer capture width to create a delay of 1 EPI clock</li>
<li><b>EPI_HB16_CAP_WIDTH_2</b> defines the inter-transfer capture width to create a delay of 2 EPI clocks.</li>
</ul>
</li>
</ul>
<ul>
<li>Write wait state timing reduction, select one of:<ul>
<li><b>EPI_HB16_WRWAIT_MINUS_DISABLE</b> disables the additional write wait state reduction.</li>
<li><b>EPI_HB16_WRWAIT_MINUS_ENABLE</b> enables a 1 EPI clock write wait state reduction.</li>
</ul>
</li>
</ul>
<ul>
<li>Read wait state timing reduction, select one of:<ul>
<li><b>EPI_HB16_RDWAIT_MINUS_DISABLE</b> disables the additional read wait state reduction.</li>
<li><b>EPI_HB16_RDWAIT_MINUS_ENABLE</b> enables a 1 EPI clock read wait state reduction.</li>
</ul>
</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of unique chip select timings within Host-bus 16 interface mode varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01033">1033</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00089">EPI_O_HB16TIME</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Write the target chip select HostBus16 timing register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + (<a class="code" href="hw__epi_8h.html#a1084ac391f2ae3e54d2afd9ab5037fb9">EPI_O_HB16TIME</a> + (ui32CS &lt;&lt; 2))) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0c8d1ad6326357040fa3a8805cfeeb0d"></a><!-- doxytag: member="epi.c::EPIConfigHB8CSSet" ref="ga0c8d1ad6326357040fa3a8805cfeeb0d" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the individual chip select configuration for the Host-bus 8 interface.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure individual chip select settings for the Host-bus 8 interface mode. <a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set()</a> must have been setup with the <b>EPI_HB8_CSBAUD</b> flag for the individual chip select configuration option to be available.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Host-bus 8 submode, select one of:<ul>
<li><b>EPI_HB8_MODE_ADMUX</b> sets data and address muxed, AD[7:0].</li>
<li><b>EPI_HB8_MODE_ADDEMUX</b> sets up data and address separate, D[7:0].</li>
<li><b>EPI_HB8_MODE_SRAM</b> as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[7:0].</li>
<li><b>EPI_HB8_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[7:0]. This is only available for CS0n and CS1n.</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB8_WRHIGH</b> sets active high write strobe, otherwise it is active low.</li>
<li><b>EPI_HB8_RDHIGH</b> sets active high read strobe, otherwise it is active low.</li>
<li>Write wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB8_WRWAIT_1</b> sets write wait state to 4 EPI clocks.</li>
<li><b>EPI_HB8_WRWAIT_2</b> sets write wait state to 6 EPI clocks.</li>
<li><b>EPI_HB8_WRWAIT_3</b> sets write wait state to 8 EPI clocks.</li>
</ul>
</li>
<li>Read wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default).</li>
<li><b>EPI_HB8_RDWAIT_1</b> sets read wait state to 4 EPI clocks.</li>
<li><b>EPI_HB8_RDWAIT_2</b> sets read wait state to 6 EPI clocks.</li>
<li><b>EPI_HB8_RDWAIT_3</b> sets read wait state to 8 EPI clocks.</li>
</ul>
</li>
<li><b>EPI_HB8_ALE_HIGH</b> sets the address latch active high (default).</li>
<li><b>EPI_HB8_ALE_LOW</b> sets address latch active low.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of a unique chip select configuration within Host-bus 8 interface mode varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00790">790</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="epi_8c_source.html#l00063">EPI_HB8_CS_MASK</a>, <a class="el" href="hw__epi_8h_source.html#l00056">EPI_O_HB8CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00084">EPI_O_HB8CFG3</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset, ui32Reg;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a8e07c362c8fb4f71625b707f509bfd7f">EPI_O_HB8CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a7ddce2750424b23a00b3e85da89c5e29">EPI_O_HB8CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Preserve the bits that will not be modified.</span>
    <span class="comment">//</span>
    ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) &amp; ~<a class="code" href="group__epi__api.html#ga96755362386f5ced366f5ae9a46ea513">EPI_HB8_CS_MASK</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the target chip select HostBus8 configuration fields.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) = (ui32Reg | ui32Config);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga6637f518ffb554224100f386f0c13936"></a><!-- doxytag: member="epi.c::EPIConfigHB8Set" ref="ga6637f518ffb554224100f386f0c13936" args="(uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32MaxWait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga6637f518ffb554224100f386f0c13936">EPIConfigHB8Set</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MaxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the interface for Host-bus 8 operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the interface configuration. </td></tr>
    <tr><td class="paramname">ui32MaxWait</td><td>is the maximum number of external clocks to wait if a FIFO ready signal is holding off the transaction, 0-255.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the interface when used in host-bus 8 operation as chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Host-bus 8 submode, select one of:<ul>
<li><b>EPI_HB8_MODE_ADMUX</b> sets data and address muxed, AD[7:0]</li>
<li><b>EPI_HB8_MODE_ADDEMUX</b> sets up data and address separate, D[7:0]</li>
<li><b>EPI_HB8_MODE_SRAM</b> as <b>EPI_HB8_MODE_ADDEMUX</b>, but uses address switch for multiple reads instead of OEn strobing, D[7:0]</li>
<li><b>EPI_HB8_MODE_FIFO</b> adds XFIFO with sense of XFIFO full and XFIFO empty, D[7:0]</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB8_USE_TXEMPTY</b> enables TXEMPTY signal with FIFO</li>
<li><b>EPI_HB8_USE_RXFULL</b> enables RXFULL signal with FIFO</li>
<li><b>EPI_HB8_WRHIGH</b> sets active high write strobe, otherwise it is active low</li>
<li><b>EPI_HB8_RDHIGH</b> sets active high read strobe, otherwise it is active low</li>
</ul>
<ul>
<li>Write wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_WRWAIT_0</b> sets write wait state to 2 EPI clocks (default)</li>
<li><b>EPI_HB8_WRWAIT_1</b> sets write wait state to 4 EPI clocks</li>
<li><b>EPI_HB8_WRWAIT_2</b> sets write wait state to 6 EPI clocks</li>
<li><b>EPI_HB8_WRWAIT_3</b> sets write wait state to 8 EPI clocks</li>
</ul>
</li>
</ul>
<ul>
<li>Read wait state when <b>EPI_HB8_BAUD</b> is used, select one of:<ul>
<li><b>EPI_HB8_RDWAIT_0</b> sets read wait state to 2 EPI clocks (default)</li>
<li><b>EPI_HB8_RDWAIT_1</b> sets read wait state to 4 EPI clocks</li>
<li><b>EPI_HB8_RDWAIT_2</b> sets read wait state to 6 EPI clocks</li>
<li><b>EPI_HB8_RDWAIT_3</b> sets read wait state to 8 EPI clocks</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB8_WORD_ACCESS</b> - use Word Access mode to route bytes to the correct byte lanes allowing data to be stored in bits [31:8]. If absent, all data transfers use bits [7:0].</li>
</ul>
<ul>
<li><b>EPI_HB8_CLOCK_GATE_IDLE</b> sets the EPI clock to be held low when no data is available to read or write</li>
<li><b>EPI_HB8_CLOCK_INVERT</b> inverts the EPI clock</li>
<li><b>EPI_HB8_IN_READY_EN</b> sets EPIS032 as a ready/stall signal, active high</li>
<li><b>EPI_HB8_IN_READY_EN_INVERT</b> sets EPIS032 as ready/stall signal, active low</li>
<li><b>EPI_HB8_ALE_HIGH</b> sets the address latch active high (default)</li>
<li><b>EPI_HB8_ALE_LOW</b> sets address latch active low</li>
<li><b>EPI_HB8_CSBAUD</b> use different baud rates when accessing devices on each chip select. CS0n uses the baud rate specified by the lower 16 bits of the divider passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> and CS1n uses the divider passed in the upper 16 bits. If this option is absent, both chip selects use the baud rate resulting from the divider in the lower 16 bits of the parameter passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a>.</li>
</ul>
<p>In addition, some parts support CS2n and CS3n for a total of 4 chip selects. If <b>EPI_HB8_CSBAUD</b> is configured, <a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet()</a> should be used to to configure the divider for CS2n and CS3n. They both also use the lower 16 bits passed to <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet()</a> if this option is absent.</p>
<p>The use of <b>EPI_HB8_CSBAUD</b> also allows for unique chip select configurations. CS0n, CS1n, CS2n, and CS3n can each be configured by calling <a class="el" href="group__epi__api.html#ga0c8d1ad6326357040fa3a8805cfeeb0d">EPIConfigHB8CSSet()</a> if <b>EPI_HB8_CSBAUD</b> is used. Otherwise, the configuration provided in <em>ui32Config</em> is used for all chip selects enabled.</p>
<ul>
<li>Chip select configuration, select one of:<ul>
<li><b>EPI_HB8_CSCFG_CS</b> sets EPIS030 to operate as a chip select signal.</li>
<li><b>EPI_HB8_CSCFG_ALE</b> sets EPIS030 to operate as an address latch (ALE).</li>
<li><b>EPI_HB8_CSCFG_DUAL_CS</b> sets EPIS030 to operate as CS0n and EPIS027 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB8_CSCFG_ALE_DUAL_CS</b> sets EPIS030 as an address latch (ALE), EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select determined from the most significant address bit for the respective external address map.</li>
<li><b>EPI_HB8_CSCFG_ALE_SINGLE_CS</b> sets EPIS030 to operate as an address latch (ALE) and EPIS027 is used as a chip select.</li>
<li><b>EPI_HB8_CSCFG_QUAD_CS</b> sets EPIS030 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n.</li>
<li><b>EPI_HB8_CSCFG_ALE_QUAD_CS</b> sets EPIS030 as an address latch (ALE), EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n. <dl class="note"><dt><b>Note:</b></dt><dd>Dual or quad chip select configurations cannot be used with EPI_HB8_MODE_SRAM.</dd></dl>
The parameter <em>ui32MaxWait</em> is used if the FIFO mode is chosen. If a FIFO is used aint32_t with RXFULL or TXEMPTY ready signals, then this parameter determines the maximum number of clocks to wait when the transaction is being held off by by the FIFO using one of these ready signals. A value of 0 means to wait forever.</li>
</ul>
</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Availability of configuration options varies based on the Tiva part in use. Please consult the data sheet to determine if the features desired are available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00569">569</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="epi_8h_source.html#l00137">EPI_HB8_CSBAUD</a>, <a class="el" href="epi_8h_source.html#l00145">EPI_HB8_CSCFG_MASK</a>, <a class="el" href="hw__epi_8h_source.html#l00253">EPI_HB8CFG2_CSBAUD</a>, <a class="el" href="hw__epi_8h_source.html#l00228">EPI_HB8CFG_MAXWAIT_M</a>, <a class="el" href="hw__epi_8h_source.html#l00244">EPI_HB8CFG_MAXWAIT_S</a>, <a class="el" href="hw__epi_8h_source.html#l00056">EPI_O_HB8CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00057">EPI_O_HB8CFG2</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32MaxWait &lt; 256);

    <span class="comment">//</span>
    <span class="comment">// Determine the CS and word access modes.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a994c0867fe83905f0ed75203221415a8">EPI_O_HB8CFG2</a>) =
        ((ui32Config &amp; <a class="code" href="epi_8h.html#a2646dcc71e26d1a67d8a9385977f571f">EPI_HB8_CSBAUD</a>) ? <a class="code" href="hw__epi_8h.html#ae2405bc6dcf30c3fd894760eaae87538">EPI_HB8CFG2_CSBAUD</a> : 0) |
        ((ui32Config &amp; <a class="code" href="epi_8h.html#adcaad25b802e5ff5be31d78494020bb3">EPI_HB8_CSCFG_MASK</a>) &lt;&lt; 15);

    <span class="comment">//</span>
    <span class="comment">// Fill in the max wait field of the configuration word.</span>
    <span class="comment">//</span>
    ui32Config &amp;= ~<a class="code" href="hw__epi_8h.html#a33d4bd8b3216d3b7640594224fe49d0a">EPI_HB8CFG_MAXWAIT_M</a>;
    ui32Config |= ui32MaxWait &lt;&lt; <a class="code" href="hw__epi_8h.html#a409426476729a4e122c8052fd7b1fc8a">EPI_HB8CFG_MAXWAIT_S</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the main HostBus8 configuration register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8e07c362c8fb4f71625b707f509bfd7f">EPI_O_HB8CFG</a>) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga1a2bf596b8c09862989df76bc781c2e3"></a><!-- doxytag: member="epi.c::EPIConfigHB8TimingSet" ref="ga1a2bf596b8c09862989df76bc781c2e3" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga1a2bf596b8c09862989df76bc781c2e3">EPIConfigHB8TimingSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the individual chip select timing settings for the Host-bus 8 interface.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select value to configure. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set individual chip select timings for the Host-bus 8 interface mode.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li>Input ready stall delay, select one of:<ul>
<li><b>EPI_HB8_IN_READY_DELAY_1</b> sets the stall on input ready (EPIS032) to start 1 EPI clock after signaled.</li>
<li><b>EPI_HB8_IN_READY_DELAY_2</b> sets the stall on input ready (EPIS032) to start 2 EPI clocks after signaled.</li>
<li><b>EPI_HB8_IN_READY_DELAY_3</b> sets the stall on input ready (EPIS032) to start 3 EPI clocks after signaled.</li>
</ul>
</li>
</ul>
<ul>
<li>Host bus transfer delay, select one of:<ul>
<li><b>EPI_HB8_CAP_WIDTH_1</b> defines the inter-transfer capture width to create a delay of 1 EPI clock.</li>
<li><b>EPI_HB8_CAP_WIDTH_2</b> defines the inter-transfer capture width to create a delay of 2 EPI clocks.</li>
</ul>
</li>
</ul>
<ul>
<li><b>EPI_HB8_WRWAIT_MINUS_DISABLE</b> disables the additional write wait state reduction.</li>
<li><b>EPI_HB8_WRWAIT_MINUS_ENABLE</b> enables a 1 EPI clock write wait state reduction.</li>
<li><b>EPI_HB8_RDWAIT_MINUS_DISABLE</b> disables the additional read wait state reduction.</li>
<li><b>EPI_HB8_RDWAIT_MINUS_ENABLE</b> enables a 1 EPI clock read wait state reduction.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of unique chip select timings within Host-bus 8 interface mode varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00958">958</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00088">EPI_O_HB8TIME</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Write the target chip select HostBus8 timing register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + (<a class="code" href="hw__epi_8h.html#a8fe4aaaa853881272cd4ca85f8b4f475">EPI_O_HB8TIME</a> + (ui32CS &lt;&lt; 2))) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga7ab51fb7dee81c5e5dfc6a3cce5f8711"></a><!-- doxytag: member="epi.c::EPIConfigSDRAMSet" ref="ga7ab51fb7dee81c5e5dfc6a3cce5f8711" args="(uint32_t ui32Base, uint32_t ui32Config, uint32_t ui32Refresh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga7ab51fb7dee81c5e5dfc6a3cce5f8711">EPIConfigSDRAMSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Refresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the SDRAM mode of operation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the SDRAM interface configuration. </td></tr>
    <tr><td class="paramname">ui32Refresh</td><td>is the refresh count in core clocks (0-2047).</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure the SDRAM interface, when the SDRAM mode is chosen with the function <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet()</a>. The parameter <em>ui32Config</em> is the logical OR of several sets of choices:</p>
<p>The processor core frequency must be specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_CORE_FREQ_0_15</b> defines core clock as 0 MHz &lt; clk &lt;= 15 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_15_30</b> defines core clock as 15 MHz &lt; clk &lt;= 30 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_30_50</b> defines core clock as 30 MHz &lt; clk &lt;= 50 MHz</li>
<li><b>EPI_SDRAM_CORE_FREQ_50_100</b> defines core clock as 50 MHz &lt; clk &lt;= 100 MHz</li>
</ul>
<p>The low power mode is specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_LOW_POWER</b> enter low power, self-refresh state.</li>
<li><b>EPI_SDRAM_FULL_POWER</b> normal operating state.</li>
</ul>
<p>The SDRAM device size is specified with one of the following:</p>
<ul>
<li><b>EPI_SDRAM_SIZE_64MBIT</b> size is a 64 Mbit device (8 MB).</li>
<li><b>EPI_SDRAM_SIZE_128MBIT</b> size is a 128 Mbit device (16 MB).</li>
<li><b>EPI_SDRAM_SIZE_256MBIT</b> size is a 256 Mbit device (32 MB).</li>
<li><b>EPI_SDRAM_SIZE_512MBIT</b> size is a 512 Mbit device (64 MB).</li>
</ul>
<p>The parameter <em>ui16Refresh</em> sets the refresh counter in units of core clock ticks. It is an 11-bit value with a range of 0 - 2047 counts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00444">444</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00055">EPI_O_SDRAMCFG</a>, <a class="el" href="hw__epi_8h_source.html#l00204">EPI_SDRAMCFG_RFSH_M</a>, <a class="el" href="hw__epi_8h_source.html#l00211">EPI_SDRAMCFG_RFSH_S</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Refresh &lt; 2048);

    <span class="comment">//</span>
    <span class="comment">// Fill in the refresh count field of the configuration word.</span>
    <span class="comment">//</span>
    ui32Config &amp;= ~<a class="code" href="hw__epi_8h.html#a3f92e058bce0738d303009917d8f21b5">EPI_SDRAMCFG_RFSH_M</a>;
    ui32Config |= ui32Refresh &lt;&lt; <a class="code" href="hw__epi_8h.html#a036dc7e81b774736d3f8c8a9b9c78871">EPI_SDRAMCFG_RFSH_S</a>;

    <span class="comment">//</span>
    <span class="comment">// Write the SDRAM configuration register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a9803b49f1186c9ec6e906eec62ca6306">EPI_O_SDRAMCFG</a>) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gad0477da26c8bbb3746ecdc2f4329cb71"></a><!-- doxytag: member="epi.c::EPIDividerCSSet" ref="gad0477da26c8bbb3746ecdc2f4329cb71" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32Divider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gad0477da26c8bbb3746ecdc2f4329cb71">EPIDividerCSSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the clock divider for the specified CS in the EPI module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select to modify and has a valid range of 0-3. </td></tr>
    <tr><td class="paramname">ui32Divider</td><td>is the value of the clock divider to be applied to the external interface (0-65535).</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the clock divider(s) for the specified CS that is used to determine the clock rate of the external interface. The <em>ui32Divider</em> value is used to derive the EPI clock rate from the system clock based on the following formula.</p>
<p>EPIClk = (Divider == 0) ? SysClk : (SysClk / (((Divider / 2) + 1) * 2))</p>
<p>For example, a divider value of 1 results in an EPI clock rate of half the system clock, value of 2 or 3 yields one quarter of the system clock and a value of 4 results in one sixth of the system clock rate.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of CS2n and CS3n varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00339">339</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00050">EPI_O_BAUD</a>, <a class="el" href="hw__epi_8h_source.html#l00051">EPI_O_BAUD2</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Reg;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Write the divider value to the register bitfield.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a04b8f6a26cd70596ea1a031d1bc128a5">EPI_O_BAUD</a>) &amp; ~(0xffff &lt;&lt; (16 * ui32CS));
        ui32Reg |= ((ui32Divider &amp; 0xffff) &lt;&lt; (16 * ui32CS));
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a04b8f6a26cd70596ea1a031d1bc128a5">EPI_O_BAUD</a>) = ui32Reg;
    }
    <span class="keywordflow">else</span>
    {
        ui32Reg = (<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a98b93188bd9f702e166aee2dceb396db">EPI_O_BAUD2</a>) &amp;
                   ~(0xffff &lt;&lt; (16 * (ui32CS - 2))));
        ui32Reg |= ((ui32Divider &amp; 0xffff) &lt;&lt; (16 * (ui32CS - 2)));
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a98b93188bd9f702e166aee2dceb396db">EPI_O_BAUD2</a>) = ui32Reg;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5b5bc021fe841f7910b9c441c9e645e4"></a><!-- doxytag: member="epi.c::EPIDividerSet" ref="ga5b5bc021fe841f7910b9c441c9e645e4" args="(uint32_t ui32Base, uint32_t ui32Divider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga5b5bc021fe841f7910b9c441c9e645e4">EPIDividerSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the clock divider for the EPI module's CS0n/CS1n.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Divider</td><td>is the value of the clock divider to be applied to the external interface (0-65535).</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the clock divider(s) that is used to determine the clock rate of the external interface. The <em>ui32Divider</em> value is used to derive the EPI clock rate from the system clock based on the following formula.</p>
<p>EPIClk = (Divider == 0) ? SysClk : (SysClk / (((Divider / 2) + 1) * 2))</p>
<p>For example, a divider value of 1 results in an EPI clock rate of half the system clock, value of 2 or 3 yields one quarter of the system clock and a value of 4 results in one sixth of the system clock rate.</p>
<p>In cases where a dual chip select mode is in use and different clock rates are required for each chip select, the <em>ui32Divider</em> parameter must contain two dividers. The lower 16 bits define the divider to be used with CS0n and the upper 16 bits define the divider for CS1n.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00298">298</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00050">EPI_O_BAUD</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Write the divider value to the register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a04b8f6a26cd70596ea1a031d1bc128a5">EPI_O_BAUD</a>) = ui32Divider;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga7bb1dc9e6eed9bfcf5565cd930b0f22b"></a><!-- doxytag: member="epi.c::EPIDMATxCount" ref="ga7bb1dc9e6eed9bfcf5565cd930b0f22b" args="(uint32_t ui32Base, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga7bb1dc9e6eed9bfcf5565cd930b0f22b">EPIDMATxCount</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the transfer count for uDMA transmit operations on EPI.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of units to transmit by uDMA to WRFIFO.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to help configure the EPI uDMA transmit operations. A non-zero transmit count in combination with a FIFO threshold trigger asserts an EPI uDMA transmit.</p>
<p>Note that, although the EPI peripheral can handle counts of up to 65535, a single uDMA transfer has a maximum length of 1024 units so <em>ui32Count</em> should be set to values less than or equal to 1024.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of the EPI DMA TX count varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00391">391</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00078">EPI_O_DMATXCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Count &lt;= 1024);

    <span class="comment">//</span>
    <span class="comment">// Assign the DMA TX count value provided.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a358faa9a598fa6661b2957bfedd7e407">EPI_O_DMATXCNT</a>) = ui32Count &amp; 0xffff;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9c11b58182855b534e42cf0357b4db72"></a><!-- doxytag: member="epi.c::EPIFIFOConfig" ref="ga9c11b58182855b534e42cf0357b4db72" args="(uint32_t ui32Base, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga9c11b58182855b534e42cf0357b4db72">EPIFIFOConfig</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the read FIFO.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the FIFO configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FIFO trigger levels and error generation. The parameter <em>ui32Config</em> is the logical OR of the following:</p>
<ul>
<li><b>EPI_FIFO_CONFIG_WTFULLERR</b> enables an error interrupt when a write is attempted and the write FIFO is full</li>
<li><b>EPI_FIFO_CONFIG_RSTALLERR</b> enables an error interrupt when a read is stalled due to an interleaved write or other reason</li>
<li>FIFO TX trigger level, select one of:<ul>
<li><b>EPI_FIFO_CONFIG_TX_EMPTY</b> sets the FIFO TX trigger level to empty.</li>
<li><b>EPI_FIFO_CONFIG_TX_1_4</b> sets the FIFO TX trigger level to 1/4.</li>
<li><b>EPI_FIFO_CONFIG_TX_1_2</b> sets the FIFO TX trigger level to 1/2.</li>
<li><b>EPI_FIFO_CONFIG_TX_3_4</b> sets the FIFO TX trigger level to 3/4.</li>
</ul>
</li>
<li>FIFO RX trigger level, select one of:<ul>
<li><b>EPI_FIFO_CONFIG_RX_1_8</b> sets the FIFO RX trigger level to 1/8.</li>
<li><b>EPI_FIFO_CONFIG_RX_1_4</b> sets the FIFO RX trigger level to 1/4.</li>
<li><b>EPI_FIFO_CONFIG_RX_1_2</b> sets the FIFO RX trigger level to 1/2.</li>
<li><b>EPI_FIFO_CONFIG_RX_3_4</b> sets the FIFO RX trigger level to 3/4.</li>
<li><b>EPI_FIFO_CONFIG_RX_7_8</b> sets the FIFO RX trigger level to 7/8.</li>
<li><b>EPI_FIFO_CONFIG_RX_FULL</b> sets the FIFO RX trigger level to full.</li>
</ul>
</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01830">1830</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00076">EPI_O_FIFOLVL</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Config == (ui32Config &amp; 0x00030077));

    <span class="comment">//</span>
    <span class="comment">// Load the configuration into the FIFO config reg.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#aaf0bcc8fff757a5543bfd81005dab502">EPI_O_FIFOLVL</a>) = ui32Config;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac477f3e293ed8e771fc05450cd6c28d5"></a><!-- doxytag: member="epi.c::EPIIntDisable" ref="gac477f3e293ed8e771fc05450cd6c28d5" args="(uint32_t ui32Base, uint32_t ui32IntFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gac477f3e293ed8e771fc05450cd6c28d5">EPIIntDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables EPI interrupt sources.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the specified EPI sources for interrupt generation. The <em>ui32IntFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01927">1927</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00079">EPI_O_IM</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32IntFlags &lt; 17);

    <span class="comment">//</span>
    <span class="comment">// Write the interrupt flags mask to the mask register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a6031a185f1291b951d4f358565a13dac">EPI_O_IM</a>) &amp;= ~ui32IntFlags;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0231d902fde7ee8a0bd73d43cee6d636"></a><!-- doxytag: member="epi.c::EPIIntEnable" ref="ga0231d902fde7ee8a0bd73d43cee6d636" args="(uint32_t ui32Base, uint32_t ui32IntFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables EPI interrupt sources.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32IntFlags</td><td>is a bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the specified EPI sources to generate interrupts. The <em>ui32IntFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01892">1892</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00079">EPI_O_IM</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32IntFlags &lt; 17);

    <span class="comment">//</span>
    <span class="comment">// Write the interrupt flags mask to the mask register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a6031a185f1291b951d4f358565a13dac">EPI_O_IM</a>) |= ui32IntFlags;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga14adf0b4a609b3635ef98c2223ada115"></a><!-- doxytag: member="epi.c::EPIIntErrorClear" ref="ga14adf0b4a609b3635ef98c2223ada115" args="(uint32_t ui32Base, uint32_t ui32ErrFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga14adf0b4a609b3635ef98c2223ada115">EPIIntErrorClear</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32ErrFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears pending EPI error sources.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32ErrFlags</td><td>is a bit mask of the error sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified pending EPI errors. The <em>ui32ErrFlags</em> parameter can be the logical OR of any of the following values:</p>
<ul>
<li><b>EPI_INT_ERR_DMAWRIC</b> clears the EPI_INT_DMA_TX_DONE as an interrupt source</li>
<li><b>EPI_INT_ERR_DMARDIC</b> clears the EPI_INT_DMA_RX_DONE as an interrupt source</li>
<li><b>EPI_INT_ERR_WTFULL</b> occurs when a write stalled when the transaction FIFO was full</li>
<li><b>EPI_INT_ERR_RSTALL</b> occurs when a read stalled</li>
<li><b>EPI_INT_ERR_TIMEOUT</b> occurs when the external clock enable held off a transaction longer than the configured maximum wait time</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l02042">2042</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00082">EPI_O_EISC</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32ErrFlags &lt; 0x20);

    <span class="comment">//</span>
    <span class="comment">// Write the error flags to the register to clear the pending errors.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8289cddbe9fa2e2d2fcd93eb1dac9ff7">EPI_O_EISC</a>) = ui32ErrFlags;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gad6fcb9023d51da8af50f924dd64e9e72"></a><!-- doxytag: member="epi.c::EPIIntErrorStatus" ref="gad6fcb9023d51da8af50f924dd64e9e72" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gad6fcb9023d51da8af50f924dd64e9e72">EPIIntErrorStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the EPI error interrupt status.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the error status of the EPI. If the return value of the function <a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus()</a> has the flag <b>EPI_INT_ERR</b> set, then this function can be used to determine the cause of the error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a bit mask of error flags, which can be the logical OR of any of the following:</dd></dl>
<ul>
<li><b>EPI_INT_ERR_WTFULL</b> occurs when a write stalled when the transaction FIFO was full</li>
<li><b>EPI_INT_ERR_RSTALL</b> occurs when a read stalled</li>
<li><b>EPI_INT_ERR_TIMEOUT</b> occurs when the external clock enable held off a transaction longer than the configured maximum wait time </li>
</ul>

<p>Definition at line <a class="el" href="epi_8c_source.html#l02005">2005</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00082">EPI_O_EISC</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Read the error status and return to caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8289cddbe9fa2e2d2fcd93eb1dac9ff7">EPI_O_EISC</a>));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga4b2d512849c4f92fc15196d62ff30bd2"></a><!-- doxytag: member="epi.c::EPIIntRegister" ref="ga4b2d512849c4f92fc15196d62ff30bd2" args="(uint32_t ui32Base, void(*pfnHandler)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga4b2d512849c4f92fc15196d62ff30bd2">EPIIntRegister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers an interrupt handler for the EPI module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the interrupt is activated.</td></tr>
  </table>
  </dd>
</dl>
<p>This sets and enables the handler to be called when the EPI module generates an interrupt. Specific EPI interrupts must still be enabled with the <a class="el" href="group__epi__api.html#ga0231d902fde7ee8a0bd73d43cee6d636">EPIIntEnable()</a> function.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l02111">2111</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="epi_8c_source.html#l02070">_EPIIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="interrupt_8c_source.html#l00610">IntEnable()</a>, and <a class="el" href="interrupt_8c_source.html#l00309">IntRegister()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(pfnHandler);

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number for the EPI interface.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85">_EPIIntNumberGet</a>(ui32Base);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Register the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister</a>(ui32Int, pfnHandler);

    <span class="comment">//</span>
    <span class="comment">// Enable the EPI interface interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__epi__api_ga4b2d512849c4f92fc15196d62ff30bd2_cgraph.png" border="0" usemap="#group__epi__api_ga4b2d512849c4f92fc15196d62ff30bd2_cgraph" alt=""/></div>
<map name="group__epi__api_ga4b2d512849c4f92fc15196d62ff30bd2_cgraph" id="group__epi__api_ga4b2d512849c4f92fc15196d62ff30bd2_cgraph">
<area shape="rect" id="node3" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85" title="_EPIIntNumberGet" alt="" coords="163,5,296,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce" title="IntEnable" alt="" coords="191,59,268,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9" title="IntRegister" alt="" coords="187,112,272,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga198a1b608d1cf1565e96ce27d967aea4"></a><!-- doxytag: member="epi.c::EPIIntStatus" ref="ga198a1b608d1cf1565e96ce27d967aea4" args="(uint32_t ui32Base, bool bMasked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#ga198a1b608d1cf1565e96ce27d967aea4">EPIIntStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the EPI interrupt status.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is set <b>true</b> to get the masked interrupt status, or <b>false</b> to get the raw interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the EPI interrupt status. It can return either the raw or masked interrupt status.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the masked or raw EPI interrupt status, as a bit field of any of the following values:</dd></dl>
<ul>
<li><b>EPI_INT_TXREQ</b> interrupt when transmit FIFO is below the trigger level.</li>
<li><b>EPI_INT_RXREQ</b> interrupt when read FIFO is above the trigger level.</li>
<li><b>EPI_INT_ERR</b> interrupt when an error condition occurs.</li>
<li><b>EPI_INT_DMA_TX_DONE</b> interrupt when the transmit DMA completes.</li>
<li><b>EPI_INT_DMA_RX_DONE</b> interrupt when the read DMA completes. </li>
</ul>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01963">1963</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00081">EPI_O_MIS</a>, <a class="el" href="hw__epi_8h_source.html#l00080">EPI_O_RIS</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Return either the interrupt status or the raw interrupt status as</span>
    <span class="comment">// requested.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bMasked)
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a3a1e714eb3024d262f45084d473ecb7f">EPI_O_MIS</a>));
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a65abd7f445f99b9887cd3547426cc16e">EPI_O_RIS</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9375b854f9a595e2b0b0a712829cf8aa"></a><!-- doxytag: member="epi.c::EPIIntUnregister" ref="ga9375b854f9a595e2b0b0a712829cf8aa" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga9375b854f9a595e2b0b0a712829cf8aa">EPIIntUnregister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a registered interrupt handler for the EPI module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables and clears the handler to be called when the EPI interrupt occurs.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l02155">2155</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="epi_8c_source.html#l02070">_EPIIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="interrupt_8c_source.html#l00684">IntDisable()</a>, and <a class="el" href="interrupt_8c_source.html#l00381">IntUnregister()</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number for the EPI interface.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85">_EPIIntNumberGet</a>(ui32Base);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Disable the EPI interface interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable</a>(ui32Int);

    <span class="comment">//</span>
    <span class="comment">// Unregister the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__epi__api_ga9375b854f9a595e2b0b0a712829cf8aa_cgraph.png" border="0" usemap="#group__epi__api_ga9375b854f9a595e2b0b0a712829cf8aa_cgraph" alt=""/></div>
<map name="group__epi__api_ga9375b854f9a595e2b0b0a712829cf8aa_cgraph" id="group__epi__api_ga9375b854f9a595e2b0b0a712829cf8aa_cgraph">
<area shape="rect" id="node3" href="group__epi__api.html#gad2c7e37d7576307a5d9b903f65f42a85" title="_EPIIntNumberGet" alt="" coords="173,5,307,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334" title="IntDisable" alt="" coords="200,59,280,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a" title="IntUnregister" alt="" coords="192,112,288,141"/><area shape="rect" id="node9" href="group__interrupt__api.html#gaef37c406caeeb884ba343265b953120d" title="_IntDefaultHandler" alt="" coords="355,112,485,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga68bb056cd29fa04275e955323ab18239"></a><!-- doxytag: member="epi.c::EPIModeSet" ref="ga68bb056cd29fa04275e955323ab18239" args="(uint32_t ui32Base, uint32_t ui32Mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga68bb056cd29fa04275e955323ab18239">EPIModeSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the usage mode of the EPI module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>is the usage mode of the EPI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions sets the operating mode of the EPI module. The parameter <em>ui32Mode</em> must be one of the following:</p>
<ul>
<li><b>EPI_MODE_GENERAL</b> - use for general-purpose mode operation</li>
<li><b>EPI_MODE_SDRAM</b> - use with SDRAM device</li>
<li><b>EPI_MODE_HB8</b> - use with host-bus 8-bit interface</li>
<li><b>EPI_MODE_HB16</b> - use with host-bus 16-bit interface</li>
<li><b>EPI_MODE_DISABLE</b> - disable the EPI module</li>
</ul>
<p>Selection of any of the above modes enables the EPI module, except for <b>EPI_MODE_DISABLE</b>, which is used to disable the module.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l00252">252</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="epi_8h_source.html#l00063">EPI_MODE_DISABLE</a>, <a class="el" href="epi_8h_source.html#l00059">EPI_MODE_GENERAL</a>, <a class="el" href="epi_8h_source.html#l00062">EPI_MODE_HB16</a>, <a class="el" href="epi_8h_source.html#l00061">EPI_MODE_HB8</a>, <a class="el" href="epi_8h_source.html#l00060">EPI_MODE_SDRAM</a>, <a class="el" href="hw__epi_8h_source.html#l00049">EPI_O_CFG</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Mode == <a class="code" href="epi_8h.html#a729eeab60066a39337793c3f363649b1">EPI_MODE_GENERAL</a>) ||
           (ui32Mode == <a class="code" href="epi_8h.html#ae30aaee9658b57e352f3aeac2bfa3ad2">EPI_MODE_SDRAM</a>) ||
           (ui32Mode == <a class="code" href="epi_8h.html#aa0ccd99a1265d2880c7c0942fe39dfab">EPI_MODE_HB8</a>) ||
           (ui32Mode == <a class="code" href="epi_8h.html#ada4b2e48b1e178591ff3dca7eddb96b9">EPI_MODE_HB16</a>) ||
           (ui32Mode == <a class="code" href="epi_8h.html#af43bd43bff8a405a63626ea423a3b0fb">EPI_MODE_DISABLE</a>));

    <span class="comment">//</span>
    <span class="comment">// Write the mode word to the register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a9063d1bfdc05bf936500da72ca429798">EPI_O_CFG</a>) = ui32Mode;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaecfc47bee6a379ced21c9ecf984f2888"></a><!-- doxytag: member="epi.c::EPINonBlockingReadAvail" ref="gaecfc47bee6a379ced21c9ecf984f2888" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gaecfc47bee6a379ced21c9ecf984f2888">EPINonBlockingReadAvail</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the count of items available in the read FIFO.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the number of items that are available to read in the read FIFO. The read FIFO is filled by a non-blocking read transaction which is configured by the functions <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure()</a> and <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items available to read in the read FIFO. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01620">1620</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00067">EPI_O_RFIFOCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Read the FIFO count and return it to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga09d3a1b329d16480537f5afbbd54a547"></a><!-- doxytag: member="epi.c::EPINonBlockingReadConfigure" ref="ga09d3a1b329d16480537f5afbbd54a547" args="(uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32DataSize, uint32_t ui32Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures a non-blocking read transaction.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1). </td></tr>
    <tr><td class="paramname">ui32DataSize</td><td>is the size of the data items to read. </td></tr>
    <tr><td class="paramname">ui32Address</td><td>is the starting address to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to configure a non-blocking read channel for a transaction. Two channels are available that can be used in a ping-pong method for continuous reading. It is not necessary to use both channels to perform a non-blocking read.</p>
<p>The parameter <em>ui8DataSize</em> is one of <b>EPI_NBCONFIG_SIZE_8</b>, <b>EPI_NBCONFIG_SIZE_16</b>, or <b>EPI_NBCONFIG_SIZE_32</b> for 8-bit, 16-bit, or 32-bit sized data transfers.</p>
<p>The parameter <em>ui32Address</em> is the starting address for the read, relative to the external device. The start of the device is address 0.</p>
<p>Once configured, the non-blocking read is started by calling <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart()</a>. If the addresses to be read from the device are in a sequence, it is not necessary to call this function multiple times. Until it is changed, the EPI module stores the last address that was used for a non-blocking read (per channel).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01460">1460</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00061">EPI_O_RADDR0</a>, <a class="el" href="hw__epi_8h_source.html#l00060">EPI_O_RSIZE0</a>, <a class="el" href="hw__epi_8h_source.html#l00063">EPI_O_RSIZE1</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Channel &lt; 2);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32DataSize &lt; 4);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Address &lt; 0x20000000);

    <span class="comment">//</span>
    <span class="comment">// Compute the offset needed to select the correct channel regs.</span>
    <span class="comment">//</span>
    ui32Offset = ui32Channel * (<a class="code" href="hw__epi_8h.html#a752d331b65b48399db43d293b81123f6">EPI_O_RSIZE1</a> - <a class="code" href="hw__epi_8h.html#aceaa6ba4ce9c8b72d16e789d034e97dc">EPI_O_RSIZE0</a>);

    <span class="comment">//</span>
    <span class="comment">// Write the data size register for the channel.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#aceaa6ba4ce9c8b72d16e789d034e97dc">EPI_O_RSIZE0</a> + ui32Offset) = ui32DataSize;

    <span class="comment">//</span>
    <span class="comment">// Write the starting address register for the channel.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a36b844ff2593d7da3cfa8edcb534fa81">EPI_O_RADDR0</a> + ui32Offset) = ui32Address;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3decd0254b5104255b9dbe1e02936ff6"></a><!-- doxytag: member="epi.c::EPINonBlockingReadCount" ref="ga3decd0254b5104255b9dbe1e02936ff6" args="(uint32_t ui32Base, uint32_t ui32Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#ga3decd0254b5104255b9dbe1e02936ff6">EPINonBlockingReadCount</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the count remaining for a non-blocking transaction.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1).</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the remaining count of items for a non-blocking read transaction.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items remaining in the non-blocking read transaction. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01584">1584</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00062">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h_source.html#l00065">EPI_O_RPSTD1</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Channel &lt; 2);

    <span class="comment">//</span>
    <span class="comment">// Compute the offset needed to select the correct channel regs.</span>
    <span class="comment">//</span>
    ui32Offset = ui32Channel * (<a class="code" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a> - <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>);

    <span class="comment">//</span>
    <span class="comment">// Read the count remaining and return the value to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a> + ui32Offset));
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaac0645c23368a2e768a27010e714e7cf"></a><!-- doxytag: member="epi.c::EPINonBlockingReadGet16" ref="gaac0645c23368a2e768a27010e714e7cf" args="(uint32_t ui32Base, uint32_t ui32Count, uint16_t *pui16Buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gaac0645c23368a2e768a27010e714e7cf">EPINonBlockingReadGet16</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read available data from the read FIFO, as 16-bit data items.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui16Buf</td><td>is the caller-supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 16-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items read from the FIFO. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01707">1707</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00068">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h_source.html#l00067">EPI_O_RFIFOCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32CountRead = 0;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Count &lt; 4096);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(pui16Buf);

    <span class="comment">//</span>
    <span class="comment">// Read from the FIFO while there are any items to read, and</span>
    <span class="comment">// the caller&#39;s specified count is not exceeded.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>) &amp;&amp; ui32Count--)
    {
        <span class="comment">//</span>
        <span class="comment">// Read from the FIFO and store in the caller-supplied buffer.</span>
        <span class="comment">//</span>
        *pui16Buf = (uint16_t)<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>);

        <span class="comment">//</span>
        <span class="comment">// Update the caller&#39;s buffer pointer and the count of items read.</span>
        <span class="comment">//</span>
        pui16Buf++;
        ui32CountRead++;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the count of items read to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ui32CountRead);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac8a09fac58328065e92a61fdd31cdcc0"></a><!-- doxytag: member="epi.c::EPINonBlockingReadGet32" ref="gac8a09fac58328065e92a61fdd31cdcc0" args="(uint32_t ui32Base, uint32_t ui32Count, uint32_t *pui32Buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gac8a09fac58328065e92a61fdd31cdcc0">EPINonBlockingReadGet32</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read available data from the read FIFO, as 32-bit data items.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui32Buf</td><td>is the caller supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 32-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items read from the FIFO. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01652">1652</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00068">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h_source.html#l00067">EPI_O_RFIFOCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32CountRead = 0;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Count &lt; 4096);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(pui32Buf);

    <span class="comment">//</span>
    <span class="comment">// Read from the FIFO while there are any items to read and</span>
    <span class="comment">// the caller&#39;s specified count is not exceeded.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>) &amp;&amp; ui32Count--)
    {
        <span class="comment">//</span>
        <span class="comment">// Read from the FIFO and store in the caller supplied buffer.</span>
        <span class="comment">//</span>
        *pui32Buf = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>);

        <span class="comment">//</span>
        <span class="comment">// Update the caller&#39;s buffer pointer and the count of items read.</span>
        <span class="comment">//</span>
        pui32Buf++;
        ui32CountRead++;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the count of items read to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ui32CountRead);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf7df76c4aa477ec5f48e682d9a420903"></a><!-- doxytag: member="epi.c::EPINonBlockingReadGet8" ref="gaf7df76c4aa477ec5f48e682d9a420903" args="(uint32_t ui32Base, uint32_t ui32Count, uint8_t *pui8Buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gaf7df76c4aa477ec5f48e682d9a420903">EPINonBlockingReadGet8</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read available data from the read FIFO, as 8-bit data items.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the maximum count of items to read. </td></tr>
    <tr><td class="paramname">pui8Buf</td><td>is the caller-supplied buffer where the read data is stored.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads 8-bit data items from the read FIFO and stores the values in a caller-supplied buffer. The function reads and stores data from the FIFO until there is no more data in the FIFO or the maximum count is reached as specified in the parameter <em>ui32Count</em>. The actual count of items is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items read from the FIFO. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01762">1762</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00068">EPI_O_READFIFO0</a>, <a class="el" href="hw__epi_8h_source.html#l00067">EPI_O_RFIFOCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32CountRead = 0;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Count &lt; 4096);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(pui8Buf);

    <span class="comment">//</span>
    <span class="comment">// Read from the FIFO while there are any items to read, and</span>
    <span class="comment">// the caller&#39;s specified count is not exceeded.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a8dfbe0ffe319ce28bbd17b90601ca070">EPI_O_RFIFOCNT</a>) &amp;&amp; ui32Count--)
    {
        <span class="comment">//</span>
        <span class="comment">// Read from the FIFO and store in the caller supplied buffer.</span>
        <span class="comment">//</span>
        *pui8Buf = (uint8_t)<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a1438ca1474eee18e6f8209eee3501d78">EPI_O_READFIFO0</a>);

        <span class="comment">//</span>
        <span class="comment">// Update the caller&#39;s buffer pointer and the count of items read.</span>
        <span class="comment">//</span>
        pui8Buf++;
        ui32CountRead++;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the count of items read to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ui32CountRead);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabd38827e4a7a2c21cad1f58e61dd4053"></a><!-- doxytag: member="epi.c::EPINonBlockingReadStart" ref="gabd38827e4a7a2c21cad1f58e61dd4053" args="(uint32_t ui32Base, uint32_t ui32Channel, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gabd38827e4a7a2c21cad1f58e61dd4053">EPINonBlockingReadStart</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts a non-blocking read transaction.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1). </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of items to read (1-4095).</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts a non-blocking read that was previously configured with the function <a class="el" href="group__epi__api.html#ga09d3a1b329d16480537f5afbbd54a547">EPINonBlockingReadConfigure()</a>. Once this function is called, the EPI module begins reading data from the external device into the read FIFO. The EPI stops reading when the FIFO fills up and resumes reading when the application drains the FIFO, until the total specified count of data items has been read.</p>
<p>Once a read transaction is completed and the FIFO drained, another transaction can be started from the next address by calling this function again.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01512">1512</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00062">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h_source.html#l00065">EPI_O_RPSTD1</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Channel &lt; 2);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Count &lt; 4096);

    <span class="comment">//</span>
    <span class="comment">// Compute the offset needed to select the correct channel regs.</span>
    <span class="comment">//</span>
    ui32Offset = ui32Channel * (<a class="code" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a> - <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>);

    <span class="comment">//</span>
    <span class="comment">// Write to the read count register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a> + ui32Offset) = ui32Count;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa5fa0e80a591d62a6b84f09f47a71afa"></a><!-- doxytag: member="epi.c::EPINonBlockingReadStop" ref="gaa5fa0e80a591d62a6b84f09f47a71afa" args="(uint32_t ui32Base, uint32_t ui32Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gaa5fa0e80a591d62a6b84f09f47a71afa">EPINonBlockingReadStop</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops a non-blocking read transaction.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32Channel</td><td>is the read channel (0 or 1).</td></tr>
  </table>
  </dd>
</dl>
<p>This function cancels a non-blocking read transaction that is already in progress.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01549">1549</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00062">EPI_O_RPSTD0</a>, <a class="el" href="hw__epi_8h_source.html#l00065">EPI_O_RPSTD1</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Channel &lt; 2);

    <span class="comment">//</span>
    <span class="comment">// Compute the offset needed to select the correct channel regs.</span>
    <span class="comment">//</span>
    ui32Offset = ui32Channel * (<a class="code" href="hw__epi_8h.html#a5b28d76d289b97ae7e8dbf295ec50363">EPI_O_RPSTD1</a> - <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a>);

    <span class="comment">//</span>
    <span class="comment">// Write a 0 to the read count register, which cancels the transaction.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#aaceb4f8fa0280960b6a32226a308375e">EPI_O_RPSTD0</a> + ui32Offset) = 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac078ff4e388a21abdd0e63aae2d96960"></a><!-- doxytag: member="epi.c::EPIPSRAMConfigRegGet" ref="gac078ff4e388a21abdd0e63aae2d96960" args="(uint32_t ui32Base, uint32_t ui32CS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gac078ff4e388a21abdd0e63aae2d96960">EPIPSRAMConfigRegGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the contents of the EPI PSRAM configuration register.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target.</td></tr>
  </table>
  </dd>
</dl>
<p>This function retrieves the EPI PSRAM configuration register. The register is read once the EPI PSRAM configuration register read enable signal is de-asserted.</p>
<p>The Host-bus 16 interface mode should be set up and <a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead()</a> should be called prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of PSRAM support varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01258">1258</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00148">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00085">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h_source.html#l00096">EPI_O_HBPSRAM</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Wait for PSRAM read enable to deassert if necessary.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) &amp; <a class="code" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Return the EPI PSRAM configuration register contents.</span>
    <span class="comment">// Only the lower 16 bits are valid on a read.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>) &amp; 0xffff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga7028e21f0e37f8f79e94855c56ce0d8c"></a><!-- doxytag: member="epi.c::EPIPSRAMConfigRegGetNonBlocking" ref="ga7028e21f0e37f8f79e94855c56ce0d8c" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t *pui32CR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__epi__api.html#ga7028e21f0e37f8f79e94855c56ce0d8c">EPIPSRAMConfigRegGetNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32CR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the contents of the EPI PSRAM configuration register.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target. </td></tr>
    <tr><td class="paramname">pui32CR</td><td>is the provided storage used to hold the register value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies the contents of the EPI PSRAM configuration register to the provided storage if the PSRAM read configuration register enable is no longer asserted. Otherwise the provided storage is not modified.</p>
<p>The Host-bus 16 interface mode should be set up and <a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead()</a> should be called prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The <em>pui32CR</em> parameter is a pointer to provided storage used to hold the register value.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of PSRAM support varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the value was copied to the provided storage and <b>false</b> if it was not. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01188">1188</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00148">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00085">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h_source.html#l00096">EPI_O_HBPSRAM</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Verify PSRAM read enable is not asserted.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) &amp; <a class="code" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>)
    {
        <span class="keywordflow">return</span>(<span class="keyword">false</span>);
    }

    <span class="comment">//</span>
    <span class="comment">// Copy the PSRAM configuration register value to the provided storage.</span>
    <span class="comment">// Only the lower 16 bits are valid on a read.</span>
    <span class="comment">//</span>
    *pui32CR = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>) &amp; 0xffff;

    <span class="comment">//</span>
    <span class="comment">// Notify caller the provided storage holds the EPI PSRAM configuration</span>
    <span class="comment">// register contents.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<span class="keyword">true</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga52fb7f5686e6c29a42ded8694ea8accb"></a><!-- doxytag: member="epi.c::EPIPSRAMConfigRegRead" ref="ga52fb7f5686e6c29a42ded8694ea8accb" args="(uint32_t ui32Base, uint32_t ui32CS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga52fb7f5686e6c29a42ded8694ea8accb">EPIPSRAMConfigRegRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Requests a configuration register read from the PSRAM.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target.</td></tr>
  </table>
  </dd>
</dl>
<p>This function requests a read of the PSRAM's configuration register. The Host-bus 16 interface mode should be configured prior to calling this function. The <a class="el" href="group__epi__api.html#gac078ff4e388a21abdd0e63aae2d96960">EPIPSRAMConfigRegGet()</a> and <a class="el" href="group__epi__api.html#ga7028e21f0e37f8f79e94855c56ce0d8c">EPIPSRAMConfigRegGetNonBlocking()</a> can be used to retrieve the configuration register value.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of PSRAM support varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01131">1131</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00148">EPI_HB16CFG_RDCRE</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00085">EPI_O_HB16CFG3</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Set the PSRAM configuration register read enable.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) |= <a class="code" href="hw__epi_8h.html#a3708f4b546761cebcd7708a00863c019">EPI_HB16CFG_RDCRE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabcbbd4afec4caf570bc1dbfdd0169c99"></a><!-- doxytag: member="epi.c::EPIPSRAMConfigRegSet" ref="gabcbbd4afec4caf570bc1dbfdd0169c99" args="(uint32_t ui32Base, uint32_t ui32CS, uint32_t ui32CR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gabcbbd4afec4caf570bc1dbfdd0169c99">EPIPSRAMConfigRegSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32CR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the PSRAM configuration register.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address. </td></tr>
    <tr><td class="paramname">ui32CS</td><td>is the chip select target. </td></tr>
    <tr><td class="paramname">ui32CR</td><td>is the PSRAM configuration register value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PSRAM's configuration register by using the PSRAM configuration register enable signal. The Host-bus 16 interface mode should be configured prior to calling this function.</p>
<p>The <em>ui32Base</em> parameter is the base address for the EPI hardware module. The <em>ui32CS</em> parameter specifies the chip select to configure and has a valid range of 0-3. The parameter <em>ui32CR</em> value is determined by consulting the PSRAM's data sheet.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The availability of PSRAM support varies based on the Tiva part in use. Please consult the data sheet to determine if this feature is available.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01072">1072</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00146">EPI_HB16CFG_WRCRE</a>, <a class="el" href="hw__epi_8h_source.html#l00052">EPI_O_HB16CFG</a>, <a class="el" href="hw__epi_8h_source.html#l00085">EPI_O_HB16CFG3</a>, <a class="el" href="hw__epi_8h_source.html#l00096">EPI_O_HBPSRAM</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Offset;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32CS &lt; 4);

    <span class="comment">//</span>
    <span class="comment">// Determine the register offset based on the ui32CS provided.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32CS &lt; 2)
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a2a7775d0ea8edfc8fce81c520c8a75cf">EPI_O_HB16CFG</a> + (ui32CS &lt;&lt; 2);
    }
    <span class="keywordflow">else</span>
    {
        ui32Offset = <a class="code" href="hw__epi_8h.html#a496b0a575c1fa23d68923b41dc210e92">EPI_O_HB16CFG3</a> + ((ui32CS - 2) &lt;&lt; 2);
    }

    <span class="comment">//</span>
    <span class="comment">// Setup for the PSRAM configuration register write.  Only 21 bits are</span>
    <span class="comment">// valid on a write.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#ab37db48428f96991875175d0b41caa28">EPI_O_HBPSRAM</a>) = (ui32CR &amp; 0x1fffff);

    <span class="comment">//</span>
    <span class="comment">// Set the PSRAM configuration register write enable.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + ui32Offset) |= <a class="code" href="hw__epi_8h.html#abf137f9a17f0640dd8bc7b84c1f6e5e3">EPI_HB16CFG_WRCRE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5fdafd7c230548f932c7c97bf10edede"></a><!-- doxytag: member="epi.c::EPIWorkaroundByteRead" ref="ga5fdafd7c230548f932c7c97bf10edede" args="(uint8_t *pui8Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="group__epi__api.html#ga5fdafd7c230548f932c7c97bf10edede">EPIWorkaroundByteRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely reads a byte from the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui8Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading bytes from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 8-bit byte stored at address <em>pui8Addr</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77ba9dc9e83289991e8f14761c878700"></a><!-- doxytag: member="epi.c::EPIWorkaroundByteWrite" ref="ga77ba9dc9e83289991e8f14761c878700" args="(uint8_t *pui8Addr, uint8_t ui8Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#ga77ba9dc9e83289991e8f14761c878700">EPIWorkaroundByteWrite</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely writes a byte to the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui8Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui8Value</td><td>is the 8-bit byte to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing bytes to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad71f8ad921035840a193e61195043f19"></a><!-- doxytag: member="epi.c::EPIWorkaroundHWordRead" ref="gad71f8ad921035840a193e61195043f19" args="(uint16_t *pui16Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="group__epi__api.html#gad71f8ad921035840a193e61195043f19">EPIWorkaroundHWordRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely reads a half-word from the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui16Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading half-words from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 16-bit word stored at address <em>pui16Addr</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a50bfa91729092980cca2ec63ec84f"></a><!-- doxytag: member="epi.c::EPIWorkaroundHWordWrite" ref="gae0a50bfa91729092980cca2ec63ec84f" args="(uint16_t *pui16Addr, uint16_t ui16Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gae0a50bfa91729092980cca2ec63ec84f">EPIWorkaroundHWordWrite</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely writes a half-word to the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui16Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui16Value</td><td>is the 16-bit half-word to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing half-words to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47dd18169c4f1dd367fc7ac6d0256c98"></a><!-- doxytag: member="epi.c::EPIWorkaroundWordRead" ref="ga47dd18169c4f1dd367fc7ac6d0256c98" args="(uint32_t *pui32Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#ga47dd18169c4f1dd367fc7ac6d0256c98">EPIWorkaroundWordRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely reads a word from the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Addr</td><td>is the address which is to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when reading words from EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 32-bit word stored at address <em>pui32Addr</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf954738021f0632426c67962aedf8e7"></a><!-- doxytag: member="epi.c::EPIWorkaroundWordWrite" ref="gaaf954738021f0632426c67962aedf8e7" args="(uint32_t *pui32Addr, uint32_t ui32Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__epi__api.html#gaaf954738021f0632426c67962aedf8e7">EPIWorkaroundWordWrite</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Safely writes a word to the EPI 0x10000000 address space.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pui32Addr</td><td>is the address which is to be written. </td></tr>
    <tr><td class="paramname">ui32Value</td><td>is the 32-bit word to write.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be used when writing words to EPI-attached memory configured to use the address space at 0x10000000 on devices affected by the EPI#01 erratum. Direct access to memory in these cases can cause data corruption depending upon memory accesses immediately before or after the EPI access but using this function will allow EPI accesses to complete correctly. The function is defined as ``inline'' in <a class="el" href="epi_8h.html">epi.h</a>.</p>
<p>Use of this function on a device not affected by the erratum is safe but will impact performance due to an additional overhead of at least 2 cycles per access. This erratum affects only the 0x10000000 address space typically used to store the LCD controller frame buffer. The 0x60000000 address space is not affected and applications using this address mapping need not use this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9983fa4529a274cd1b09f5a10cbbdd0"></a><!-- doxytag: member="epi.c::EPIWriteFIFOCountGet" ref="gab9983fa4529a274cd1b09f5a10cbbdd0" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__epi__api.html#gab9983fa4529a274cd1b09f5a10cbbdd0">EPIWriteFIFOCountGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the number of empty slots in the write transaction FIFO.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the EPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the number of slots available in the transaction FIFO. It can be used in a polling method to avoid attempting a write that would stall.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of empty slots in the transaction FIFO. </dd></dl>

<p>Definition at line <a class="el" href="epi_8c_source.html#l01858">1858</a> of file <a class="el" href="epi_8c_source.html">epi.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__memmap_8h_source.html#l00129">EPI0_BASE</a>, <a class="el" href="hw__epi_8h_source.html#l00077">EPI_O_WFIFOCNT</a>, and <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Base == <a class="code" href="hw__memmap_8h.html#a17519eee3f6761696196069467f68c87">EPI0_BASE</a>);

    <span class="comment">//</span>
    <span class="comment">// Read the FIFO count and return it to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__epi_8h.html#a4d5028cd2b406879600cb46047a9deb0">EPI_O_WFIFOCNT</a>));
}
</pre></div>
</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jan 27 2015 21:45:35 for EE 445M by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
