<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EE 445M: Pwm_api</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">EE 445M
   
   </div>
   <div id="projectbrief">Real Time Operating Systems taken at University of Texas Spring 2015</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__pwm__api.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Pwm_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(_mod_, _gen_)&#160;&#160;&#160;((_mod_) + (_gen_))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(_mod_, _gen_)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga4563e3820191c9d6e73156340b715264">PWM_OUT_BADDR</a>(_mod_, _out_)&#160;&#160;&#160;((_mod_) + ((_out_) &amp; 0xFFFFFFC0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga7904efa054c5e221ee9aa2e438f37100">PWM_IS_OUTPUT_ODD</a>(_out_)&#160;&#160;&#160;((_out_) &amp; 0x00000001)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0ec9d188f8e72f597f4f5bf41152468d">PWMGenPeriodSet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Period)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga318c7e9cfc0c4abc0c1efc3154bc0810">PWMGenPeriodGet</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gac83fa6b41c14ed89bb8c1882c59ac190">PWMGenEnable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga2829ffb434e65a7aa27ee69977fdc122">PWMGenDisable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga2abde7fc411bf9cad8de0c5dc070c78c">PWMPulseWidthSet</a> (uint32_t ui32Base, uint32_t ui32PWMOut, uint32_t ui32Width)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gae361688d19da3c776f82e31607392f3f">PWMPulseWidthGet</a> (uint32_t ui32Base, uint32_t ui32PWMOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gabe610ec6fd50251becf382a1479ca32f">PWMDeadBandEnable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint16_t ui16Rise, uint16_t ui16Fall)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0330312868b4d7df496759563635690c">PWMDeadBandDisable</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga32a04801267751f323f528cd3d5f2da5">PWMSyncUpdate</a> (uint32_t ui32Base, uint32_t ui32GenBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gadd7281936c715b7286746bbae6c24a6a">PWMSyncTimeBase</a> (uint32_t ui32Base, uint32_t ui32GenBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga372c69ae52fe1136454b60230f38beb1">PWMOutputState</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bEnable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf233159a77a070f2dc60d50da3939ba9">PWMOutputInvert</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bInvert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga35b6c40b99278f7d78c186cd275b7a05">PWMOutputFaultLevel</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bDriveHigh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga10e1cb93f663c916cf5403e29e1be898">PWMOutputFault</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bFaultSuppress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d">_PWMGenIntNumberGet</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga1bd27374e6dce2e1a2689166b79be9f6">PWMGenIntRegister</a> (uint32_t ui32Base, uint32_t ui32Gen, void(*pfnIntHandler)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga93c72c556d0febbd7d641df12f30d7b1">PWMGenIntUnregister</a> (uint32_t ui32Base, uint32_t ui32Gen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90">_PWMFaultIntNumberGet</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gada200e22c312dd4015e26717821ffb39">PWMFaultIntRegister</a> (uint32_t ui32Base, void(*pfnIntHandler)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaa5b9971717f517bdac7c1f1e3885e541">PWMFaultIntUnregister</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga31055ec13555e774fa6702e35b774518">PWMGenIntTrigEnable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gafdd8f3c8343e5b06916bb6ba5ead9533">PWMGenIntTrigDisable</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga645372a9dd99a0683d7c8e53006357ed">PWMGenIntStatus</a> (uint32_t ui32Base, uint32_t ui32Gen, bool bMasked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga0d4748e1865ceae4814aef2296a9604a">PWMGenIntClear</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Ints)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable</a> (uint32_t ui32Base, uint32_t ui32GenFault)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable</a> (uint32_t ui32Base, uint32_t ui32GenFault)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf389ca1c69300d556fdc5113cccf5060">PWMFaultIntClear</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gac90f2873671ff65e9225d8238e068a14">PWMIntStatus</a> (uint32_t ui32Base, bool bMasked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga9c0e721a969daed808a148607859e21d">PWMFaultIntClearExt</a> (uint32_t ui32Base, uint32_t ui32FaultInts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga16ca060d2c4e997682912cba1d6d1962">PWMGenFaultConfigure</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32MinFaultPeriod, uint32_t ui32FaultSenses)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gae7fb9968efcd45b0525dc1f3bca86819">PWMGenFaultTriggerSet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga59e1b382bd20206868f6bb0af0af98df">PWMGenFaultTriggerGet</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gaf2cd851dc65dccee7c2c885f15bbfc4a">PWMGenFaultStatus</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga3c00a35459dd8714d57bb35c1b2e5621">PWMGenFaultClear</a> (uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#gabe29ab284505972d4c172e6b33daabd9">PWMClockSet</a> (uint32_t ui32Base, uint32_t ui32Config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga6f57a49f895de360f84c363f608eebed">PWMClockGet</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pwm__api.html#ga77b64a04eb1bd9daf99c10d549a8ada5">PWMOutputUpdateMode</a> (uint32_t ui32Base, uint32_t ui32PWMOutBits, uint32_t ui32Mode)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7fa2c9868b0c6fe74c9a90ade752130a"></a><!-- doxytag: member="pwm.c::PWM_GEN_BADDR" ref="ga7fa2c9868b0c6fe74c9a90ade752130a" args="(_mod_, _gen_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_gen_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((_mod_) + (_gen_))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00064">64</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l00624">PWMDeadBandDisable()</a>, <a class="el" href="pwm_8c_source.html#l00581">PWMDeadBandEnable()</a>, <a class="el" href="pwm_8c_source.html#l00200">PWMGenConfigure()</a>, <a class="el" href="pwm_8c_source.html#l00412">PWMGenDisable()</a>, <a class="el" href="pwm_8c_source.html#l00383">PWMGenEnable()</a>, <a class="el" href="pwm_8c_source.html#l01691">PWMGenFaultConfigure()</a>, <a class="el" href="pwm_8c_source.html#l01822">PWMGenFaultTriggerGet()</a>, <a class="el" href="pwm_8c_source.html#l01759">PWMGenFaultTriggerSet()</a>, <a class="el" href="pwm_8c_source.html#l01451">PWMGenIntClear()</a>, <a class="el" href="pwm_8c_source.html#l01396">PWMGenIntStatus()</a>, <a class="el" href="pwm_8c_source.html#l01357">PWMGenIntTrigDisable()</a>, <a class="el" href="pwm_8c_source.html#l01315">PWMGenIntTrigEnable()</a>, <a class="el" href="pwm_8c_source.html#l00336">PWMGenPeriodGet()</a>, and <a class="el" href="pwm_8c_source.html#l00278">PWMGenPeriodSet()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf81b183094f6f00cb1108caec1d91e6b"></a><!-- doxytag: member="pwm.c::PWM_GEN_EXT_BADDR" ref="gaf81b183094f6f00cb1108caec1d91e6b" args="(_mod_, _gen_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_gen_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((_mod_) + <a class="code" href="pwm_8h.html#a949d66a43a7014ea1893875a343ed948">PWM_GEN_EXT_0</a> +                    \
                                 ((_gen_) - <a class="code" href="pwm_8h.html#a9e2cd841eb589469e7f862b392d29088">PWM_GEN_0</a>) * 2)
</pre></div>
<p>Definition at line <a class="el" href="pwm_8c_source.html#l00066">66</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l01930">PWMGenFaultClear()</a>, <a class="el" href="pwm_8c_source.html#l01691">PWMGenFaultConfigure()</a>, and <a class="el" href="pwm_8c_source.html#l01881">PWMGenFaultStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7904efa054c5e221ee9aa2e438f37100"></a><!-- doxytag: member="pwm.c::PWM_IS_OUTPUT_ODD" ref="ga7904efa054c5e221ee9aa2e438f37100" args="(_out_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__pwm__api.html#ga7904efa054c5e221ee9aa2e438f37100">PWM_IS_OUTPUT_ODD</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_</td><td>)</td>
          <td>&#160;&#160;&#160;((_out_) &amp; 0x00000001)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00071">71</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l00518">PWMPulseWidthGet()</a>, and <a class="el" href="pwm_8c_source.html#l00447">PWMPulseWidthSet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4563e3820191c9d6e73156340b715264"></a><!-- doxytag: member="pwm.c::PWM_OUT_BADDR" ref="ga4563e3820191c9d6e73156340b715264" args="(_mod_, _out_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__pwm__api.html#ga4563e3820191c9d6e73156340b715264">PWM_OUT_BADDR</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_mod_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((_mod_) + ((_out_) &amp; 0xFFFFFFC0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00069">69</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l00518">PWMPulseWidthGet()</a>, and <a class="el" href="pwm_8c_source.html#l00447">PWMPulseWidthSet()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa68283bbefea2c30c9e44fff9ec52f90"></a><!-- doxytag: member="pwm.c::_PWMFaultIntNumberGet" ref="gaa68283bbefea2c30c9e44fff9ec52f90" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t <a class="el" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90">_PWMFaultIntNumberGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the PWM fault interrupt number.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the fault interrupt number of the corresponding PWM module.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the interrupt number. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01179">1179</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="hw__types_8h_source.html#l00093">CLASS_IS_TM4C123</a>, <a class="el" href="hw__types_8h_source.html#l00099">CLASS_IS_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00073">INT_PWM0_FAULT_TM4C123</a>, <a class="el" href="hw__ints_8h_source.html#l00185">INT_PWM0_FAULT_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00168">INT_PWM1_FAULT_TM4C123</a>, and <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l01221">PWMFaultIntRegister()</a>, and <a class="el" href="pwm_8c_source.html#l01266">PWMFaultIntUnregister()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Return the fault interrupt number.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
    {
        <span class="keywordflow">return</span>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) ? <a class="code" href="hw__ints_8h.html#a688d5fcb3cc45acb02ae6f19c5a65c2d">INT_PWM0_FAULT_TM4C123</a> :
               <a class="code" href="hw__ints_8h.html#ae4cba4db5c68cf02b0dc3942ffc392ad">INT_PWM1_FAULT_TM4C123</a>);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
    {
        <span class="keywordflow">return</span>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) ? <a class="code" href="hw__ints_8h.html#ad6cc575a0ec0cdaed888c4997cc0dc8b">INT_PWM0_FAULT_TM4C129</a> : 0);
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(0);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_gaa68283bbefea2c30c9e44fff9ec52f90_icgraph.png" border="0" usemap="#group__pwm__api_gaa68283bbefea2c30c9e44fff9ec52f90_icgraph" alt=""/></div>
<map name="group__pwm__api_gaa68283bbefea2c30c9e44fff9ec52f90_icgraph" id="group__pwm__api_gaa68283bbefea2c30c9e44fff9ec52f90_icgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#gada200e22c312dd4015e26717821ffb39" title="PWMFaultIntRegister" alt="" coords="233,5,380,35"/><area shape="rect" id="node5" href="group__pwm__api.html#gaa5b9971717f517bdac7c1f1e3885e541" title="PWMFaultIntUnregister" alt="" coords="228,59,385,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0656fb50e678e2694d5cf4ad830b688d"></a><!-- doxytag: member="pwm.c::_PWMGenIntNumberGet" ref="ga0656fb50e678e2694d5cf4ad830b688d" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t <a class="el" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d">_PWMGenIntNumberGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the PWM generator interrupt number.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator in question. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt number of the corresponding PWM generator.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the interrupt number. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00923">923</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="hw__types_8h_source.html#l00093">CLASS_IS_TM4C123</a>, <a class="el" href="hw__types_8h_source.html#l00099">CLASS_IS_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00074">INT_PWM0_0_TM4C123</a>, <a class="el" href="hw__ints_8h_source.html#l00186">INT_PWM0_0_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00187">INT_PWM0_1_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00188">INT_PWM0_2_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00219">INT_PWM0_3_TM4C129</a>, <a class="el" href="hw__ints_8h_source.html#l00164">INT_PWM1_0_TM4C123</a>, <a class="el" href="hw__ints_8h_source.html#l00165">INT_PWM1_1_TM4C123</a>, <a class="el" href="hw__ints_8h_source.html#l00166">INT_PWM1_2_TM4C123</a>, <a class="el" href="hw__ints_8h_source.html#l00167">INT_PWM1_3_TM4C123</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00134">PWM_GEN_0</a>, <a class="el" href="pwm_8h_source.html#l00135">PWM_GEN_1</a>, <a class="el" href="pwm_8h_source.html#l00136">PWM_GEN_2</a>, and <a class="el" href="pwm_8h_source.html#l00137">PWM_GEN_3</a>.</p>

<p>Referenced by <a class="el" href="pwm_8c_source.html#l01088">PWMGenIntRegister()</a>, and <a class="el" href="pwm_8c_source.html#l01138">PWMGenIntUnregister()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Determine the generator and PWM module in question.</span>
    <span class="comment">//</span>
    <span class="keywordflow">switch</span>(ui32Base + ui32Gen)
    {
        <span class="comment">//</span>
        <span class="comment">// The first PWM generator in the first PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a> + <a class="code" href="pwm_8h.html#a9e2cd841eb589469e7f862b392d29088">PWM_GEN_0</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#a8dffb66507d8b6b0b34b820bddba9fd7">INT_PWM0_0_TM4C123</a>);
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#ace5fa8d65be2d0eed4d7b7c39497cb47">INT_PWM0_0_TM4C129</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The second PWM generator in the first PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a> + <a class="code" href="pwm_8h.html#af9a0b11f6bab7e099db4e0559f1077e3">PWM_GEN_1</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#a45d773b903e91947d616cb8ecdc264b5">INT_PWM0_1_TM4C129</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The third PWM generator in the first PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a> + <a class="code" href="pwm_8h.html#a7535e334f3ca165c97373c876c453a79">PWM_GEN_2</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#a1b6afb2a6c48def5badfa54f82134ab2">INT_PWM0_2_TM4C129</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The fourth PWM generator in the first PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a> + <a class="code" href="pwm_8h.html#a0977700eb99b5a5b67483c98784975b4">PWM_GEN_3</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ad585839948168b2f3b39c3dbf2cbe200">CLASS_IS_TM4C129</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#ac0641829045f3c51a119a68d17a377b3">INT_PWM0_3_TM4C129</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The first PWM generator in the second PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a> + <a class="code" href="pwm_8h.html#a9e2cd841eb589469e7f862b392d29088">PWM_GEN_0</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#afe966f2ede3fbc686c9bf2ce57f7351d">INT_PWM1_0_TM4C123</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The first PWM generator in the second PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a> + <a class="code" href="pwm_8h.html#af9a0b11f6bab7e099db4e0559f1077e3">PWM_GEN_1</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#a5025d892a481162a035d7884a16ff227">INT_PWM1_1_TM4C123</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The first PWM generator in the second PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a> + <a class="code" href="pwm_8h.html#a7535e334f3ca165c97373c876c453a79">PWM_GEN_2</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#ad1ce3effb86d047e56d58e91e16ce23e">INT_PWM1_2_TM4C123</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// The first PWM generator in the second PWM module.</span>
        <span class="comment">//</span>
        <span class="keywordflow">case</span> <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a> + <a class="code" href="pwm_8h.html#a0977700eb99b5a5b67483c98784975b4">PWM_GEN_3</a>:
        {
            <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#aed400510c15509bdc6296e5c233f6cd3">CLASS_IS_TM4C123</a>)
            {
                <span class="keywordflow">return</span>(<a class="code" href="hw__ints_8h.html#ab7d06299c32323352689f8c15300a5be">INT_PWM1_3_TM4C123</a>);
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span>(0);
            }
        }

        <span class="comment">//</span>
        <span class="comment">// An unknown PWM module/generator was specified.</span>
        <span class="comment">//</span>
        <span class="keywordflow">default</span>:
        {
            <span class="keywordflow">return</span>(0);
        }
    }
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_ga0656fb50e678e2694d5cf4ad830b688d_icgraph.png" border="0" usemap="#group__pwm__api_ga0656fb50e678e2694d5cf4ad830b688d_icgraph" alt=""/></div>
<map name="group__pwm__api_ga0656fb50e678e2694d5cf4ad830b688d_icgraph" id="group__pwm__api_ga0656fb50e678e2694d5cf4ad830b688d_icgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#ga1bd27374e6dce2e1a2689166b79be9f6" title="PWMGenIntRegister" alt="" coords="228,5,369,35"/><area shape="rect" id="node5" href="group__pwm__api.html#ga93c72c556d0febbd7d641df12f30d7b1" title="PWMGenIntUnregister" alt="" coords="221,59,376,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga6f57a49f895de360f84c363f608eebed"></a><!-- doxytag: member="pwm.c::PWMClockGet" ref="ga6f57a49f895de360f84c363f608eebed" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#ga6f57a49f895de360f84c363f608eebed">PWMClockGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the current PWM clock configuration.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current PWM clock configuration.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should not be used with TM4C123 devices. For TM4C123 devices, the <a class="el" href="group__sysctl__api.html#gaaccf3eef212a6be9e924103bd100f54f">SysCtlPWMClockGet()</a> function should be used.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current PWM clock configuration; is one of <b>PWM_SYSCLK_DIV_1</b>, <b>PWM_SYSCLK_DIV_2</b>, <b>PWM_SYSCLK_DIV_4</b>, <b>PWM_SYSCLK_DIV_8</b>, <b>PWM_SYSCLK_DIV_16</b>, <b>PWM_SYSCLK_DIV_32</b>, or <b>PWM_SYSCLK_DIV_64</b>. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l02030">2030</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l01539">PWM_CC_PWMDIV_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01538">PWM_CC_USEPWM</a>, <a class="el" href="hw__pwm_8h_source.html#l00144">PWM_O_CC</a>, and <a class="el" href="pwm_8h_source.html#l00225">PWM_SYSCLK_DIV_1</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));

    <span class="comment">//</span>
    <span class="comment">// Return the current PWM clock configuration.  Make sure that</span>
    <span class="comment">// PWM_SYSCLK_DIV_1 is returned in all cases where the divider is disabled.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(!(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ab5a57d9436b22e33fb6b09f1a1840eb0">PWM_O_CC</a>) &amp; <a class="code" href="hw__pwm_8h.html#a605057ac657acf6e7f7c429c7ea294d3">PWM_CC_USEPWM</a>))
    {
        <span class="comment">//</span>
        <span class="comment">// The divider is not active so reflect this in the value we return.</span>
        <span class="comment">//</span>
        <span class="keywordflow">return</span>(<a class="code" href="pwm_8h.html#ad5f9b94ddde950254207806d904ab939">PWM_SYSCLK_DIV_1</a>);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// The divider is active so directly return the masked register value.</span>
        <span class="comment">//</span>
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ab5a57d9436b22e33fb6b09f1a1840eb0">PWM_O_CC</a>) &amp; (PWM_CC_USEPWM | <a class="code" href="hw__pwm_8h.html#a6a780c4d4e71c5a713c21e4ec29e36a6">PWM_CC_PWMDIV_M</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabe29ab284505972d4c172e6b33daabd9"></a><!-- doxytag: member="pwm.c::PWMClockSet" ref="gabe29ab284505972d4c172e6b33daabd9" args="(uint32_t ui32Base, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gabe29ab284505972d4c172e6b33daabd9">PWMClockSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the PWM clock configuration.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration for the PWM clock; it must be one of <b>PWM_SYSCLK_DIV_1</b>, <b>PWM_SYSCLK_DIV_2</b>, <b>PWM_SYSCLK_DIV_4</b>, <b>PWM_SYSCLK_DIV_8</b>, <b>PWM_SYSCLK_DIV_16</b>, <b>PWM_SYSCLK_DIV_32</b>, or <b>PWM_SYSCLK_DIV_64</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PWM clock divider as the PWM clock source. It also configures the clock frequency to the PWM module as a division of the system clock. This clock is used by the PWM module to generate PWM signals; its rate forms the basis for all PWM signals.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should not be used with TM4C123 devices. For TM4C123 devices, the <a class="el" href="group__sysctl__api.html#gaaccf3eef212a6be9e924103bd100f54f">SysCtlPWMClockGet()</a> function should be used.</dd>
<dd>
The clocking of the PWM is dependent upon the system clock rate as configured by <a class="el" href="group__sysctl__api.html#ga21032362a556673829fb41e4f057ec5a">SysCtlClockFreqSet()</a>.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01990">1990</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l01539">PWM_CC_PWMDIV_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01538">PWM_CC_USEPWM</a>, <a class="el" href="hw__pwm_8h_source.html#l00144">PWM_O_CC</a>, <a class="el" href="pwm_8h_source.html#l00229">PWM_SYSCLK_DIV_16</a>, <a class="el" href="pwm_8h_source.html#l00226">PWM_SYSCLK_DIV_2</a>, <a class="el" href="pwm_8h_source.html#l00230">PWM_SYSCLK_DIV_32</a>, <a class="el" href="pwm_8h_source.html#l00227">PWM_SYSCLK_DIV_4</a>, <a class="el" href="pwm_8h_source.html#l00231">PWM_SYSCLK_DIV_64</a>, and <a class="el" href="pwm_8h_source.html#l00228">PWM_SYSCLK_DIV_8</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Config == <a class="code" href="pwm_8h.html#a57c0f23ba712cfefe6760519e0eb141c">PWM_SYSCLK_DIV_2</a>) ||
           (ui32Config == <a class="code" href="pwm_8h.html#a5188d85bb65da7c5cc93b81e62b8db2b">PWM_SYSCLK_DIV_4</a>) ||
           (ui32Config == <a class="code" href="pwm_8h.html#ab258dd5b22ae166a001ae55798168563">PWM_SYSCLK_DIV_8</a>) ||
           (ui32Config == <a class="code" href="pwm_8h.html#a1937908aaa20e2f0353ab46a1753a2bd">PWM_SYSCLK_DIV_16</a>) ||
           (ui32Config == <a class="code" href="pwm_8h.html#a15fa39599af1d710077c31eff81d2766">PWM_SYSCLK_DIV_32</a>) ||
           (ui32Config == <a class="code" href="pwm_8h.html#ae816ee293d38e8f19c97975a7876a56e">PWM_SYSCLK_DIV_64</a>));

    <span class="comment">//</span>
    <span class="comment">// Set the PWM clock configuration into the PWM clock configuration</span>
    <span class="comment">// register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ab5a57d9436b22e33fb6b09f1a1840eb0">PWM_O_CC</a>) = ((<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ab5a57d9436b22e33fb6b09f1a1840eb0">PWM_O_CC</a>) &amp;
                                   ~(<a class="code" href="hw__pwm_8h.html#a605057ac657acf6e7f7c429c7ea294d3">PWM_CC_USEPWM</a> | <a class="code" href="hw__pwm_8h.html#a6a780c4d4e71c5a713c21e4ec29e36a6">PWM_CC_PWMDIV_M</a>)) |
                                  ui32Config);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0330312868b4d7df496759563635690c"></a><!-- doxytag: member="pwm.c::PWMDeadBandDisable" ref="ga0330312868b4d7df496759563635690c" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga0330312868b4d7df496759563635690c">PWMDeadBandDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the PWM dead band output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to modify. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the dead band mode for the specified PWM generator. Doing so decouples the <b>OutA</b> and <b>OutB</b> signals.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00624">624</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01562">PWM_O_X_DBCTL</a>, and <a class="el" href="hw__pwm_8h_source.html#l01783">PWM_X_DBCTL_ENABLE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Disable the deadband functionality.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#a762c22322a7e8a3c36ea73eca9511606">PWM_O_X_DBCTL</a>) &amp;=
        ~(<a class="code" href="hw__pwm_8h.html#ab163da9a3bbe119198faae71c507a08e">PWM_X_DBCTL_ENABLE</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabe610ec6fd50251becf382a1479ca32f"></a><!-- doxytag: member="pwm.c::PWMDeadBandEnable" ref="gabe610ec6fd50251becf382a1479ca32f" args="(uint32_t ui32Base, uint32_t ui32Gen, uint16_t ui16Rise, uint16_t ui16Fall)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gabe610ec6fd50251becf382a1479ca32f">PWMDeadBandEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Rise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16Fall</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the PWM dead band output and sets the dead band delays.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to modify. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui16Rise</td><td>specifies the width of delay from the rising edge. </td></tr>
    <tr><td class="paramname">ui16Fall</td><td>specifies the width of delay from the falling edge.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the dead bands for the specified PWM generator, where the dead bands are defined as the number of <b>PWM</b> clock ticks from the rising or falling edge of the generator's <b>OutA</b> signal. Note that this function causes the coupling of <b>OutB</b> to <b>OutA</b>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00581">581</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01562">PWM_O_X_DBCTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01564">PWM_O_X_DBFALL</a>, <a class="el" href="hw__pwm_8h_source.html#l01563">PWM_O_X_DBRISE</a>, and <a class="el" href="hw__pwm_8h_source.html#l01783">PWM_X_DBCTL_ENABLE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui16Rise &lt; 4096);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui16Fall &lt; 4096);

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32Gen = <a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen);

    <span class="comment">//</span>
    <span class="comment">// Write the dead band delay values.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a2005668be89cca30a5af88eb975d7610">PWM_O_X_DBRISE</a>) = ui16Rise;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a2bdb3c2f96f185cb81f1ea3609d636d1">PWM_O_X_DBFALL</a>) = ui16Fall;

    <span class="comment">//</span>
    <span class="comment">// Enable the deadband functionality.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a762c22322a7e8a3c36ea73eca9511606">PWM_O_X_DBCTL</a>) |= <a class="code" href="hw__pwm_8h.html#ab163da9a3bbe119198faae71c507a08e">PWM_X_DBCTL_ENABLE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf389ca1c69300d556fdc5113cccf5060"></a><!-- doxytag: member="pwm.c::PWMFaultIntClear" ref="gaf389ca1c69300d556fdc5113cccf5060" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gaf389ca1c69300d556fdc5113cccf5060">PWMFaultIntClear</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the fault interrupt for a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the fault interrupt by writing to the appropriate bit of the interrupt status register for the selected PWM module.</p>
<p>This function clears only the FAULT0 interrupt and is retained for backwards compatibility. It is recommended that <a class="el" href="group__pwm__api.html#ga9c0e721a969daed808a148607859e21d">PWMFaultIntClearExt()</a> be used instead because it supports all fault interrupts supported on devices with and without extended PWM fault handling support.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01564">1564</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00244">PWM_ISC_INTFAULT0</a>, and <a class="el" href="hw__pwm_8h_source.html#l00055">PWM_O_ISC</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));

    <span class="comment">//</span>
    <span class="comment">// Write the only writeable bit in the module&#39;s interrupt register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a9d0350ade304a5e3da0172223ccef8e8">PWM_O_ISC</a>) = <a class="code" href="hw__pwm_8h.html#ac6582d448a6f9fbf8553ab27622aadb7">PWM_ISC_INTFAULT0</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga9c0e721a969daed808a148607859e21d"></a><!-- doxytag: member="pwm.c::PWMFaultIntClearExt" ref="ga9c0e721a969daed808a148607859e21d" args="(uint32_t ui32Base, uint32_t ui32FaultInts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga9c0e721a969daed808a148607859e21d">PWMFaultIntClearExt</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultInts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the fault interrupt for a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32FaultInts</td><td>specifies the fault interrupts to clear.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears one or more fault interrupts by writing to the appropriate bit of the PWM interrupt status register. The parameter <em>ui32FaultInts</em> must be the logical OR of any of <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</p>
<p>The fault interrupts are derived by performing a logical OR of each of the configured fault trigger signals for a given generator. Therefore, these interrupts are not directly related to the four possible FAULTn inputs to the device but indicate that a fault has been signaled to one of the four possible PWM generators.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01646">1646</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00123">PWM_INT_FAULT0</a>, <a class="el" href="pwm_8h_source.html#l00124">PWM_INT_FAULT1</a>, <a class="el" href="pwm_8h_source.html#l00125">PWM_INT_FAULT2</a>, <a class="el" href="pwm_8h_source.html#l00126">PWM_INT_FAULT3</a>, and <a class="el" href="hw__pwm_8h_source.html#l00055">PWM_O_ISC</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32FaultInts &amp; ~(<a class="code" href="pwm_8h.html#a8d5c7e94c45b9eae8da1631f86f98d8c">PWM_INT_FAULT0</a> | <a class="code" href="pwm_8h.html#a27e565978748aab899996a0ff7a1819b">PWM_INT_FAULT1</a> |
                              <a class="code" href="pwm_8h.html#a063b3a167d74802df3f5534878394a94">PWM_INT_FAULT2</a> | <a class="code" href="pwm_8h.html#a9b210b75ac3ce8363ad91f066c9fb5b2">PWM_INT_FAULT3</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Clear the supplied fault bits.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a9d0350ade304a5e3da0172223ccef8e8">PWM_O_ISC</a>) = ui32FaultInts;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gada200e22c312dd4015e26717821ffb39"></a><!-- doxytag: member="pwm.c::PWMFaultIntRegister" ref="gada200e22c312dd4015e26717821ffb39" args="(uint32_t ui32Base, void(*pfnIntHandler)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gada200e22c312dd4015e26717821ffb39">PWMFaultIntRegister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnIntHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers an interrupt handler for a fault condition detected in a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">pfnIntHandler</td><td>is a pointer to the function to be called when the PWM fault interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function ensures that the interrupt handler specified by <em>pfnIntHandler</em> is called when a fault interrupt is detected for the selected PWM module. This function also enables the PWM fault interrupt in the NVIC; the PWM fault interrupt must also be enabled at the module level using <a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01221">1221</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="pwm_8c_source.html#l01179">_PWMFaultIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="interrupt_8c_source.html#l00610">IntEnable()</a>, <a class="el" href="interrupt_8c_source.html#l00309">IntRegister()</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, and <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number associated with the specified module.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90">_PWMFaultIntNumberGet</a>(ui32Base);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Register the interrupt handler, returning an error if one occurs.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister</a>(ui32Int, pfnIntHandler);

    <span class="comment">//</span>
    <span class="comment">// Enable the PWM fault interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_gada200e22c312dd4015e26717821ffb39_cgraph.png" border="0" usemap="#group__pwm__api_gada200e22c312dd4015e26717821ffb39_cgraph" alt=""/></div>
<map name="group__pwm__api_gada200e22c312dd4015e26717821ffb39_cgraph" id="group__pwm__api_gada200e22c312dd4015e26717821ffb39_cgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90" title="_PWMFaultIntNumberGet" alt="" coords="203,5,376,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce" title="IntEnable" alt="" coords="251,59,328,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9" title="IntRegister" alt="" coords="247,112,332,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaa5b9971717f517bdac7c1f1e3885e541"></a><!-- doxytag: member="pwm.c::PWMFaultIntUnregister" ref="gaa5b9971717f517bdac7c1f1e3885e541" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gaa5b9971717f517bdac7c1f1e3885e541">PWMFaultIntUnregister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the PWM fault condition interrupt handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function removes the interrupt handler for a PWM fault interrupt from the selected PWM module. This function also disables the PWM fault interrupt in the NVIC; the PWM fault interrupt must also be disabled at the module level using <a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01266">1266</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="pwm_8c_source.html#l01179">_PWMFaultIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="interrupt_8c_source.html#l00684">IntDisable()</a>, <a class="el" href="interrupt_8c_source.html#l00381">IntUnregister()</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, and <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number associated with the specified module.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90">_PWMFaultIntNumberGet</a>(ui32Base);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Disable the PWM fault interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable</a>(ui32Int);

    <span class="comment">//</span>
    <span class="comment">// Unregister the interrupt handler, returning an error if one occurs.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_gaa5b9971717f517bdac7c1f1e3885e541_cgraph.png" border="0" usemap="#group__pwm__api_gaa5b9971717f517bdac7c1f1e3885e541_cgraph" alt=""/></div>
<map name="group__pwm__api_gaa5b9971717f517bdac7c1f1e3885e541_cgraph" id="group__pwm__api_gaa5b9971717f517bdac7c1f1e3885e541_cgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#gaa68283bbefea2c30c9e44fff9ec52f90" title="_PWMFaultIntNumberGet" alt="" coords="213,5,387,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334" title="IntDisable" alt="" coords="260,59,340,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a" title="IntUnregister" alt="" coords="252,112,348,141"/><area shape="rect" id="node9" href="group__interrupt__api.html#gaef37c406caeeb884ba343265b953120d" title="_IntDefaultHandler" alt="" coords="435,112,565,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4fb48f68ba82e698c6ce1913d5300754"></a><!-- doxytag: member="pwm.c::PWMGenConfigure" ref="ga4fb48f68ba82e698c6ce1913d5300754" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures a PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to configure. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Config</td><td>is the configuration for the PWM generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to set the mode of operation for a PWM generator. The counting mode, synchronization mode, and debug behavior are all configured. After configuration, the generator is left in the disabled state.</p>
<p>A PWM generator can count in two different modes: count down mode or count up/down mode. In count down mode, it counts from a value down to zero, and then resets to the preset value, producing left-aligned PWM signals (that is, the rising edge of the two PWM signals produced by the generator occur at the same time). In count up/down mode, it counts up from zero to the preset value, counts back down to zero, and then repeats the process, producing center-aligned PWM signals (that is, the middle of the high/low period of the PWM signals produced by the generator occurs at the same time).</p>
<p>When the PWM generator parameters (period and pulse width) are modified, their effect on the output PWM signals can be delayed. In synchronous mode, the parameter updates are not applied until a synchronization event occurs. This mode allows multiple parameters to be modified and take effect simultaneously, instead of one at a time. Additionally, parameters to multiple PWM generators in synchronous mode can be updated simultaneously, allowing them to be treated as if they were a unified generator. In non-synchronous mode, the parameter updates are not delayed until a synchronization event. In either mode, the parameter updates only occur when the counter is at zero to help prevent oddly formed PWM signals during the update (that is, a PWM pulse that is too short or too long).</p>
<p>The PWM generator can either pause or continue running when the processor is stopped via the debugger. If configured to pause, it continues to count until it reaches zero, at which point it pauses until the processor is restarted. If configured to continue running, it keeps counting as if nothing had happened.</p>
<p>The <em>ui32Config</em> parameter contains the desired configuration. It is the logical OR of the following:</p>
<ul>
<li><b>PWM_GEN_MODE_DOWN</b> or <b>PWM_GEN_MODE_UP_DOWN</b> to specify the counting mode</li>
<li><b>PWM_GEN_MODE_SYNC</b> or <b>PWM_GEN_MODE_NO_SYNC</b> to specify the counter load and comparator update synchronization mode</li>
<li><b>PWM_GEN_MODE_DBG_RUN</b> or <b>PWM_GEN_MODE_DBG_STOP</b> to specify the debug behavior</li>
<li><b>PWM_GEN_MODE_GEN_NO_SYNC</b>, <b>PWM_GEN_MODE_GEN_SYNC_LOCAL</b>, or <b>PWM_GEN_MODE_GEN_SYNC_GLOBAL</b> to specify the update synchronization mode for generator counting mode changes</li>
<li><b>PWM_GEN_MODE_DB_NO_SYNC</b>, <b>PWM_GEN_MODE_DB_SYNC_LOCAL</b>, or <b>PWM_GEN_MODE_DB_SYNC_GLOBAL</b> to specify the deadband parameter synchronization mode</li>
<li><b>PWM_GEN_MODE_FAULT_LATCHED</b> or <b>PWM_GEN_MODE_FAULT_UNLATCHED</b> to specify whether fault conditions are latched or not</li>
<li><b>PWM_GEN_MODE_FAULT_MINPER</b> or <b>PWM_GEN_MODE_FAULT_NO_MINPER</b> to specify whether minimum fault period support is required</li>
<li><b>PWM_GEN_MODE_FAULT_EXT</b> or <b>PWM_GEN_MODE_FAULT_LEGACY</b> to specify whether extended fault source selection support is enabled or not</li>
</ul>
<p>Setting <b>PWM_GEN_MODE_FAULT_MINPER</b> allows an application to set the minimum duration of a PWM fault signal. Faults are signaled for at least this time even if the external fault pin deasserts earlier. Care should be taken when using this mode because during the fault signal period, the fault interrupt from the PWM generator remains asserted. The fault interrupt handler may, therefore, reenter immediately if it exits prior to expiration of the fault timer.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Changes to the counter mode affect the period of the PWM signals produced. <a class="el" href="group__pwm__api.html#ga0ec9d188f8e72f597f4f5bf41152468d">PWMGenPeriodSet()</a> and <a class="el" href="group__pwm__api.html#ga2abde7fc411bf9cad8de0c5dc070c78c">PWMPulseWidthSet()</a> should be called after any changes to the counter mode of a generator.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00200">200</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01560">PWM_O_X_GENA</a>, <a class="el" href="hw__pwm_8h_source.html#l01561">PWM_O_X_GENB</a>, <a class="el" href="hw__pwm_8h_source.html#l01602">PWM_X_CTL_CMPAUPD</a>, <a class="el" href="hw__pwm_8h_source.html#l01601">PWM_X_CTL_CMPBUPD</a>, <a class="el" href="hw__pwm_8h_source.html#l01589">PWM_X_CTL_DBCTLUPD_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01581">PWM_X_CTL_DBFALLUPD_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01585">PWM_X_CTL_DBRISEUPD_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01604">PWM_X_CTL_DEBUG</a>, <a class="el" href="hw__pwm_8h_source.html#l01580">PWM_X_CTL_FLTSRC</a>, <a class="el" href="hw__pwm_8h_source.html#l01597">PWM_X_CTL_GENAUPD_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01593">PWM_X_CTL_GENBUPD_M</a>, <a class="el" href="hw__pwm_8h_source.html#l01578">PWM_X_CTL_LATCH</a>, <a class="el" href="hw__pwm_8h_source.html#l01603">PWM_X_CTL_LOADUPD</a>, <a class="el" href="hw__pwm_8h_source.html#l01579">PWM_X_CTL_MINFLTPER</a>, <a class="el" href="hw__pwm_8h_source.html#l01605">PWM_X_CTL_MODE</a>, <a class="el" href="hw__pwm_8h_source.html#l01713">PWM_X_GENA_ACTCMPAD_ZERO</a>, <a class="el" href="hw__pwm_8h_source.html#l01722">PWM_X_GENA_ACTCMPAU_ONE</a>, <a class="el" href="hw__pwm_8h_source.html#l01727">PWM_X_GENA_ACTLOAD_ONE</a>, <a class="el" href="hw__pwm_8h_source.html#l01743">PWM_X_GENB_ACTCMPBD_ZERO</a>, <a class="el" href="hw__pwm_8h_source.html#l01752">PWM_X_GENB_ACTCMPBU_ONE</a>, and <a class="el" href="hw__pwm_8h_source.html#l01771">PWM_X_GENB_ACTLOAD_ONE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32Gen = <a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen);

    <span class="comment">//</span>
    <span class="comment">// Change the global configuration of the generator.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) = ((<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp;
                                     ~(<a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a> | <a class="code" href="hw__pwm_8h.html#aa04ab63928ca0d6efb6d98443ba84293">PWM_X_CTL_DEBUG</a> |
                                       <a class="code" href="hw__pwm_8h.html#a1b14e86b1b9377033b19cf2ed339067e">PWM_X_CTL_LATCH</a> | <a class="code" href="hw__pwm_8h.html#a5bee63e93113439a5ba9cc14f7433290">PWM_X_CTL_MINFLTPER</a> |
                                       <a class="code" href="hw__pwm_8h.html#ae45443465b62c459268588d01e89bf66">PWM_X_CTL_FLTSRC</a> |
                                       <a class="code" href="hw__pwm_8h.html#a3df19391507336e30070335f8fbcc2e9">PWM_X_CTL_DBFALLUPD_M</a> |
                                       <a class="code" href="hw__pwm_8h.html#a0d2e5acbfab7a3357649abaa6d045495">PWM_X_CTL_DBRISEUPD_M</a> |
                                       <a class="code" href="hw__pwm_8h.html#a7ede77f55b7eeec2c76f7f27b73351f3">PWM_X_CTL_DBCTLUPD_M</a> |
                                       <a class="code" href="hw__pwm_8h.html#ad2b46d15ca6721de55f0d3435ebdf218">PWM_X_CTL_GENBUPD_M</a> |
                                       <a class="code" href="hw__pwm_8h.html#a915dd4946178c2b30325547cd1d91401">PWM_X_CTL_GENAUPD_M</a> |
                                       <a class="code" href="hw__pwm_8h.html#a9a482de4debd05182f584b0ea051e598">PWM_X_CTL_LOADUPD</a> | <a class="code" href="hw__pwm_8h.html#ac231d2a6e2e8d6042557ff6343fd8bae">PWM_X_CTL_CMPAUPD</a> |
                                       <a class="code" href="hw__pwm_8h.html#a2e608213744e870d4efdd62385c70da4">PWM_X_CTL_CMPBUPD</a>)) | ui32Config);

    <span class="comment">//</span>
    <span class="comment">// Set the individual PWM generator controls.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Config &amp; <a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// In up/down count mode, set the signal high on up count comparison</span>
        <span class="comment">// and low on down count comparison (that is, center align the</span>
        <span class="comment">// signals).</span>
        <span class="comment">//</span>
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#adee263f57f90072b39ad294945d10a8d">PWM_O_X_GENA</a>) = (<a class="code" href="hw__pwm_8h.html#a32df13b4e3a961cefa3a3c9efd5f7524">PWM_X_GENA_ACTCMPAU_ONE</a> |
                                         <a class="code" href="hw__pwm_8h.html#a16125678170a23bb1de53bcd0897ee22">PWM_X_GENA_ACTCMPAD_ZERO</a>);
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#aba6dc832079c2bfc1508f7413ff5c590">PWM_O_X_GENB</a>) = (<a class="code" href="hw__pwm_8h.html#a8de45bc6e9cfc6fdcfb21b38c45082f4">PWM_X_GENB_ACTCMPBU_ONE</a> |
                                         <a class="code" href="hw__pwm_8h.html#ad0e966d06c9d3dbf7c2e148e4148c9c6">PWM_X_GENB_ACTCMPBD_ZERO</a>);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// In down count mode, set the signal high on load and low on count</span>
        <span class="comment">// comparison (that is, left align the signals).</span>
        <span class="comment">//</span>
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#adee263f57f90072b39ad294945d10a8d">PWM_O_X_GENA</a>) = (<a class="code" href="hw__pwm_8h.html#a6a010fe664fb7fdb414da57e110d6e67">PWM_X_GENA_ACTLOAD_ONE</a> |
                                         <a class="code" href="hw__pwm_8h.html#a16125678170a23bb1de53bcd0897ee22">PWM_X_GENA_ACTCMPAD_ZERO</a>);
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#aba6dc832079c2bfc1508f7413ff5c590">PWM_O_X_GENB</a>) = (<a class="code" href="hw__pwm_8h.html#af62f4dd6e48ac386e5eebee56bdd0cee">PWM_X_GENB_ACTLOAD_ONE</a> |
                                         <a class="code" href="hw__pwm_8h.html#ad0e966d06c9d3dbf7c2e148e4148c9c6">PWM_X_GENB_ACTCMPBD_ZERO</a>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga2829ffb434e65a7aa27ee69977fdc122"></a><!-- doxytag: member="pwm.c::PWMGenDisable" ref="ga2829ffb434e65a7aa27ee69977fdc122" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga2829ffb434e65a7aa27ee69977fdc122">PWMGenDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the timer/counter for a PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be disabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function blocks the PWM clock from driving the timer/counter for the specified generator block.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00412">412</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, and <a class="el" href="hw__pwm_8h_source.html#l01606">PWM_X_CTL_ENABLE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Disable the PWM generator.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp;=
        ~(<a class="code" href="hw__pwm_8h.html#ad9ec4407dce1d1c6778ac532f5b1d4b8">PWM_X_CTL_ENABLE</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac83fa6b41c14ed89bb8c1882c59ac190"></a><!-- doxytag: member="pwm.c::PWMGenEnable" ref="gac83fa6b41c14ed89bb8c1882c59ac190" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gac83fa6b41c14ed89bb8c1882c59ac190">PWMGenEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the timer/counter for a PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be enabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the PWM clock to drive the timer/counter for the specified generator block.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00383">383</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, and <a class="el" href="hw__pwm_8h_source.html#l01606">PWM_X_CTL_ENABLE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Enable the PWM generator.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) |= <a class="code" href="hw__pwm_8h.html#ad9ec4407dce1d1c6778ac532f5b1d4b8">PWM_X_CTL_ENABLE</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3c00a35459dd8714d57bb35c1b2e5621"></a><!-- doxytag: member="pwm.c::PWMGenFaultClear" ref="ga3c00a35459dd8714d57bb35c1b2e5621" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga3c00a35459dd8714d57bb35c1b2e5621">PWMGenFaultClear</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears one or more latched fault triggers for a given PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault trigger states are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>. </td></tr>
    <tr><td class="paramname">ui32FaultTriggers</td><td>is the set of fault triggers which are to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to clear the fault triggers for a given PWM generator. This function is only required if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> has previously been called with flag <b>PWM_GEN_MODE_FAULT_LATCHED</b> in parameter <em>ui32Config</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01930">1930</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00196">PWM_FAULT_DCMP0</a>, <a class="el" href="pwm_8h_source.html#l00197">PWM_FAULT_DCMP1</a>, <a class="el" href="pwm_8h_source.html#l00198">PWM_FAULT_DCMP2</a>, <a class="el" href="pwm_8h_source.html#l00199">PWM_FAULT_DCMP3</a>, <a class="el" href="pwm_8h_source.html#l00200">PWM_FAULT_DCMP4</a>, <a class="el" href="pwm_8h_source.html#l00201">PWM_FAULT_DCMP5</a>, <a class="el" href="pwm_8h_source.html#l00202">PWM_FAULT_DCMP6</a>, <a class="el" href="pwm_8h_source.html#l00203">PWM_FAULT_DCMP7</a>, <a class="el" href="pwm_8h_source.html#l00180">PWM_FAULT_FAULT0</a>, <a class="el" href="pwm_8h_source.html#l00181">PWM_FAULT_FAULT1</a>, <a class="el" href="pwm_8h_source.html#l00182">PWM_FAULT_FAULT2</a>, <a class="el" href="pwm_8h_source.html#l00183">PWM_FAULT_FAULT3</a>, <a class="el" href="pwm_8h_source.html#l00178">PWM_FAULT_GROUP_0</a>, <a class="el" href="pwm_8h_source.html#l00194">PWM_FAULT_GROUP_1</a>, <a class="el" href="pwm_8c_source.html#l00066">PWM_GEN_EXT_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01842">PWM_O_X_FLTSTAT0</a>, and <a class="el" href="hw__pwm_8h_source.html#l01843">PWM_O_X_FLTSTAT1</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check for valid parameters.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) ||
           (ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) &amp;&amp;
           ((ui32FaultTriggers &amp; ~(<a class="code" href="pwm_8h.html#a37b2ef6bfc0511a75bfc221acfb2f282">PWM_FAULT_FAULT0</a> | <a class="code" href="pwm_8h.html#a2de219e7c64d0a82f07acb1ce363212b">PWM_FAULT_FAULT1</a> |
                                   <a class="code" href="pwm_8h.html#ab4561423d7ed5dc2cae3327bb044108e">PWM_FAULT_FAULT2</a> | <a class="code" href="pwm_8h.html#ad338d635d6054bb91167fd1643abc224">PWM_FAULT_FAULT3</a>)) ==
            0));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>) &amp;&amp;
           ((ui32FaultTriggers &amp; ~(<a class="code" href="pwm_8h.html#ad2bece5821ff52377343022bdabeab51">PWM_FAULT_DCMP0</a> | <a class="code" href="pwm_8h.html#a55e073420dc94b3bdd9ad88f08ef9373">PWM_FAULT_DCMP1</a> |
                                   <a class="code" href="pwm_8h.html#ae648186a8bd297c1b768db78a1d3f234">PWM_FAULT_DCMP2</a> | <a class="code" href="pwm_8h.html#a1f9acad37271f0909222c5a78cb86d5f">PWM_FAULT_DCMP3</a> |
                                   <a class="code" href="pwm_8h.html#aba60e29625dd113c3517673ed3c1e985">PWM_FAULT_DCMP4</a> | <a class="code" href="pwm_8h.html#acc867cc4692548fdce3ccdd724300e2a">PWM_FAULT_DCMP5</a> |
                                   <a class="code" href="pwm_8h.html#a71477c795dda5ef83e3ce3b634e992b4">PWM_FAULT_DCMP6</a> | <a class="code" href="pwm_8h.html#aa35e11e224f1235bec4919afb7e52828">PWM_FAULT_DCMP7</a>)) == 0));

    <span class="comment">//</span>
    <span class="comment">// Clear the given faults.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#ad66db8d3c401131c8ea65342d7ad1cfe">PWM_O_X_FLTSTAT0</a>) =
            ui32FaultTriggers;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#ab35abcbf20873c22e00c1f805b419a1c">PWM_O_X_FLTSTAT1</a>) =
            ui32FaultTriggers;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga16ca060d2c4e997682912cba1d6d1962"></a><!-- doxytag: member="pwm.c::PWMGenFaultConfigure" ref="ga16ca060d2c4e997682912cba1d6d1962" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32MinFaultPeriod, uint32_t ui32FaultSenses)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga16ca060d2c4e997682912cba1d6d1962">PWMGenFaultConfigure</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32MinFaultPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultSenses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the minimum fault period and fault pin senses for a given PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault configuration is being set. This function must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32MinFaultPeriod</td><td>is the minimum fault active period expressed in PWM clock cycles. </td></tr>
    <tr><td class="paramname">ui32FaultSenses</td><td>indicates which sense of each FAULT input should be considered the ``asserted'' state. Valid values are logical OR combinations of <b>PWM_FAULTn_SENSE_HIGH</b> and <b>PWM_FAULTn_SENSE_LOW</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the minimum fault period for a given generator along with the sense of each of the 4 possible fault inputs. The minimum fault period is expressed in PWM clock cycles and takes effect only if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> is called with flag <b>PWM_GEN_MODE_FAULT_PER</b> set in the <em>ui32Config</em> parameter. When a fault input is asserted, the minimum fault period timer ensures that it remains asserted for at least the number of clock cycles specified.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01691">1691</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00210">PWM_FAULT0_SENSE_HIGH</a>, <a class="el" href="pwm_8h_source.html#l00211">PWM_FAULT0_SENSE_LOW</a>, <a class="el" href="pwm_8h_source.html#l00212">PWM_FAULT1_SENSE_HIGH</a>, <a class="el" href="pwm_8h_source.html#l00213">PWM_FAULT1_SENSE_LOW</a>, <a class="el" href="pwm_8h_source.html#l00214">PWM_FAULT2_SENSE_HIGH</a>, <a class="el" href="pwm_8h_source.html#l00215">PWM_FAULT2_SENSE_LOW</a>, <a class="el" href="pwm_8h_source.html#l00216">PWM_FAULT3_SENSE_HIGH</a>, <a class="el" href="pwm_8h_source.html#l00217">PWM_FAULT3_SENSE_LOW</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="pwm_8c_source.html#l00066">PWM_GEN_EXT_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01841">PWM_O_X_FLTSEN</a>, <a class="el" href="hw__pwm_8h_source.html#l01567">PWM_O_X_MINFLTPER</a>, and <a class="el" href="hw__pwm_8h_source.html#l01833">PWM_X_MINFLTPER_M</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32MinFaultPeriod &lt; <a class="code" href="hw__pwm_8h.html#afb2bf78fec61af1321f7062b25e56437">PWM_X_MINFLTPER_M</a>);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32FaultSenses &amp; ~(<a class="code" href="pwm_8h.html#ae1898a129cd918f54d40c370980d5d27">PWM_FAULT0_SENSE_HIGH</a> | <a class="code" href="pwm_8h.html#ae9eafc660541a15517f39b753b788a9a">PWM_FAULT0_SENSE_LOW</a> |
                                <a class="code" href="pwm_8h.html#a9d8be9c03b3f12ae2f44a4c79fe5839d">PWM_FAULT1_SENSE_HIGH</a> | <a class="code" href="pwm_8h.html#a25dbf614be4747c3723ae9d0f0cec895">PWM_FAULT1_SENSE_LOW</a> |
                                <a class="code" href="pwm_8h.html#a6a8b1e98c4d7d4c7efaac896f93dd63a">PWM_FAULT2_SENSE_HIGH</a> | <a class="code" href="pwm_8h.html#ae8ecf97a09d05bd5a85b0d5beeb1fcbc">PWM_FAULT2_SENSE_LOW</a> |
                                <a class="code" href="pwm_8h.html#a6cad9e4bc6b8bcc4471dbef8c5e64345">PWM_FAULT3_SENSE_HIGH</a> |
                                <a class="code" href="pwm_8h.html#a6ad11de5b0f121f845fd306b0c58bb65">PWM_FAULT3_SENSE_LOW</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Write the minimum fault period.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#a570cc52ca9513e758f5f81f085950527">PWM_O_X_MINFLTPER</a>) =
        ui32MinFaultPeriod;

    <span class="comment">//</span>
    <span class="comment">// Write the fault senses.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#aacb65de854609f47c23e0b6d76bfedea">PWM_O_X_FLTSEN</a>) =
        ui32FaultSenses;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf2cd851dc65dccee7c2c885f15bbfc4a"></a><!-- doxytag: member="pwm.c::PWMGenFaultStatus" ref="gaf2cd851dc65dccee7c2c885f15bbfc4a" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#gaf2cd851dc65dccee7c2c885f15bbfc4a">PWMGenFaultStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current state of the fault triggers for a given PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault trigger states are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to query the current state of each of the fault trigger inputs to a given PWM generator. The current state of each fault trigger input is returned unless <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> has previously been called with flag <b>PWM_GEN_MODE_FAULT_LATCHED</b> in the <em>ui32Config</em> parameter, in which case the returned status is the latched fault trigger status.</p>
<p>If latched faults are configured, the application must call <a class="el" href="group__pwm__api.html#ga3c00a35459dd8714d57bb35c1b2e5621">PWMGenFaultClear()</a> to clear each trigger.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current state of the fault triggers for the given PWM generator. A set bit indicates that the associated trigger is active. For <b>PWM_FAULT_GROUP_0</b>, the returned value is a logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, the return value is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01881">1881</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00178">PWM_FAULT_GROUP_0</a>, <a class="el" href="pwm_8h_source.html#l00194">PWM_FAULT_GROUP_1</a>, <a class="el" href="pwm_8c_source.html#l00066">PWM_GEN_EXT_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01842">PWM_O_X_FLTSTAT0</a>, and <a class="el" href="hw__pwm_8h_source.html#l01843">PWM_O_X_FLTSTAT1</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check for valid parameters.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) ||
           (ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>));

    <span class="comment">//</span>
    <span class="comment">// Return the current fault status.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>)
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#ad66db8d3c401131c8ea65342d7ad1cfe">PWM_O_X_FLTSTAT0</a>));
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#gaf81b183094f6f00cb1108caec1d91e6b">PWM_GEN_EXT_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#ab35abcbf20873c22e00c1f805b419a1c">PWM_O_X_FLTSTAT1</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga59e1b382bd20206868f6bb0af0af98df"></a><!-- doxytag: member="pwm.c::PWMGenFaultTriggerGet" ref="ga59e1b382bd20206868f6bb0af0af98df" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#ga59e1b382bd20206868f6bb0af0af98df">PWMGenFaultTriggerGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the set of fault triggers currently configured for a given PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault triggers are being queried. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of faults that are being queried. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows an application to query the current set of inputs that contribute to the generation of a fault condition to a given PWM generator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the current fault triggers configured for the fault group provided. For <b>PWM_FAULT_GROUP_0</b>, the returned value is a logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, the return value is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01822">1822</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00178">PWM_FAULT_GROUP_0</a>, <a class="el" href="pwm_8h_source.html#l00194">PWM_FAULT_GROUP_1</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01565">PWM_O_X_FLTSRC0</a>, and <a class="el" href="hw__pwm_8h_source.html#l01566">PWM_O_X_FLTSRC1</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check for valid parameters.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) ||
           (ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>));

    <span class="comment">//</span>
    <span class="comment">// Return the current fault triggers.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>)
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#af88fd2eb8364885839995381d19c7ae6">PWM_O_X_FLTSRC0</a>));
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#acdf9c6571cc83557c90982727c55f874">PWM_O_X_FLTSRC1</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae7fb9968efcd45b0525dc1f3bca86819"></a><!-- doxytag: member="pwm.c::PWMGenFaultTriggerSet" ref="gae7fb9968efcd45b0525dc1f3bca86819" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Group, uint32_t ui32FaultTriggers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gae7fb9968efcd45b0525dc1f3bca86819">PWMGenFaultTriggerSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32FaultTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the set of fault triggers for a given PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator for which fault triggers are being set. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Group</td><td>indicates the subset of possible faults that are to be configured. This parameter must be <b>PWM_FAULT_GROUP_0</b> or <b>PWM_FAULT_GROUP_1</b>. </td></tr>
    <tr><td class="paramname">ui32FaultTriggers</td><td>defines the set of inputs that are to contribute towards generation of the fault signal to the given PWM generator. For <b>PWM_FAULT_GROUP_0</b>, this is the logical OR of <b>PWM_FAULT_FAULT0</b>, <b>PWM_FAULT_FAULT1</b>, <b>PWM_FAULT_FAULT2</b>, or <b>PWM_FAULT_FAULT3</b>. For <b>PWM_FAULT_GROUP_1</b>, this is the logical OR of <b>PWM_FAULT_DCMP0</b>, <b>PWM_FAULT_DCMP1</b>, <b>PWM_FAULT_DCMP2</b>, <b>PWM_FAULT_DCMP3</b>, <b>PWM_FAULT_DCMP4</b>, <b>PWM_FAULT_DCMP5</b>, <b>PWM_FAULT_DCMP6</b>, or <b>PWM_FAULT_DCMP7</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows selection of the set of fault inputs that is combined to generate a fault condition to a given PWM generator. By default, all generators use only FAULT0 (for backwards compatibility) but if <a class="el" href="group__pwm__api.html#ga4fb48f68ba82e698c6ce1913d5300754">PWMGenConfigure()</a> is called with flag <b>PWM_GEN_MODE_FAULT_SRC</b> in the <em>ui32Config</em> parameter, extended fault handling is enabled and this function must be called to configure the fault triggers.</p>
<p>The fault signal to the PWM generator is generated by ORing together each of the signals specified in the <em>ui32FaultTriggers</em> parameter after having adjusted the sense of each FAULTn input based on the configuration previously set using a call to <a class="el" href="group__pwm__api.html#ga16ca060d2c4e997682912cba1d6d1962">PWMGenFaultConfigure()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on devices supporting extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01759">1759</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00196">PWM_FAULT_DCMP0</a>, <a class="el" href="pwm_8h_source.html#l00197">PWM_FAULT_DCMP1</a>, <a class="el" href="pwm_8h_source.html#l00198">PWM_FAULT_DCMP2</a>, <a class="el" href="pwm_8h_source.html#l00199">PWM_FAULT_DCMP3</a>, <a class="el" href="pwm_8h_source.html#l00200">PWM_FAULT_DCMP4</a>, <a class="el" href="pwm_8h_source.html#l00201">PWM_FAULT_DCMP5</a>, <a class="el" href="pwm_8h_source.html#l00202">PWM_FAULT_DCMP6</a>, <a class="el" href="pwm_8h_source.html#l00203">PWM_FAULT_DCMP7</a>, <a class="el" href="pwm_8h_source.html#l00180">PWM_FAULT_FAULT0</a>, <a class="el" href="pwm_8h_source.html#l00181">PWM_FAULT_FAULT1</a>, <a class="el" href="pwm_8h_source.html#l00182">PWM_FAULT_FAULT2</a>, <a class="el" href="pwm_8h_source.html#l00183">PWM_FAULT_FAULT3</a>, <a class="el" href="pwm_8h_source.html#l00178">PWM_FAULT_GROUP_0</a>, <a class="el" href="pwm_8h_source.html#l00194">PWM_FAULT_GROUP_1</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01565">PWM_O_X_FLTSRC0</a>, and <a class="el" href="hw__pwm_8h_source.html#l01566">PWM_O_X_FLTSRC1</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check for valid parameters.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) ||
           (ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>) &amp;&amp;
           ((ui32FaultTriggers &amp; ~(<a class="code" href="pwm_8h.html#a37b2ef6bfc0511a75bfc221acfb2f282">PWM_FAULT_FAULT0</a> | <a class="code" href="pwm_8h.html#a2de219e7c64d0a82f07acb1ce363212b">PWM_FAULT_FAULT1</a> |
                                   <a class="code" href="pwm_8h.html#ab4561423d7ed5dc2cae3327bb044108e">PWM_FAULT_FAULT2</a> | <a class="code" href="pwm_8h.html#ad338d635d6054bb91167fd1643abc224">PWM_FAULT_FAULT3</a>)) ==
            0));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Group == <a class="code" href="pwm_8h.html#a269c3a4c4fac9bf112ce4c38ef947a90">PWM_FAULT_GROUP_1</a>) &amp;&amp;
           ((ui32FaultTriggers &amp; ~(<a class="code" href="pwm_8h.html#ad2bece5821ff52377343022bdabeab51">PWM_FAULT_DCMP0</a> | <a class="code" href="pwm_8h.html#a55e073420dc94b3bdd9ad88f08ef9373">PWM_FAULT_DCMP1</a> |
                                   <a class="code" href="pwm_8h.html#ae648186a8bd297c1b768db78a1d3f234">PWM_FAULT_DCMP2</a> | <a class="code" href="pwm_8h.html#a1f9acad37271f0909222c5a78cb86d5f">PWM_FAULT_DCMP3</a> |
                                   <a class="code" href="pwm_8h.html#aba60e29625dd113c3517673ed3c1e985">PWM_FAULT_DCMP4</a> | <a class="code" href="pwm_8h.html#acc867cc4692548fdce3ccdd724300e2a">PWM_FAULT_DCMP5</a> |
                                   <a class="code" href="pwm_8h.html#a71477c795dda5ef83e3ce3b634e992b4">PWM_FAULT_DCMP6</a> | <a class="code" href="pwm_8h.html#aa35e11e224f1235bec4919afb7e52828">PWM_FAULT_DCMP7</a>)) == 0));

    <span class="comment">//</span>
    <span class="comment">// Write the fault triggers to the appropriate register.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Group == <a class="code" href="pwm_8h.html#aae7a8dd052da3e6c5364cdd71af4b9af">PWM_FAULT_GROUP_0</a>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#af88fd2eb8364885839995381d19c7ae6">PWM_O_X_FLTSRC0</a>) =
            ui32FaultTriggers;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#acdf9c6571cc83557c90982727c55f874">PWM_O_X_FLTSRC1</a>) =
            ui32FaultTriggers;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0d4748e1865ceae4814aef2296a9604a"></a><!-- doxytag: member="pwm.c::PWMGenIntClear" ref="ga0d4748e1865ceae4814aef2296a9604a" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Ints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga0d4748e1865ceae4814aef2296a9604a">PWMGenIntClear</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the specified interrupt(s) for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Ints</td><td>specifies the interrupts to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified interrupt(s) by writing a 1 to the specified bits of the interrupt status register for the specified PWM generator. The <em>ui32Ints</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, or <b>PWM_INT_CNT_BD</b>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01451">1451</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="pwm_8h_source.html#l00104">PWM_INT_CNT_AD</a>, <a class="el" href="pwm_8h_source.html#l00103">PWM_INT_CNT_AU</a>, <a class="el" href="pwm_8h_source.html#l00106">PWM_INT_CNT_BD</a>, <a class="el" href="pwm_8h_source.html#l00105">PWM_INT_CNT_BU</a>, <a class="el" href="pwm_8h_source.html#l00102">PWM_INT_CNT_LOAD</a>, <a class="el" href="pwm_8h_source.html#l00101">PWM_INT_CNT_ZERO</a>, and <a class="el" href="hw__pwm_8h_source.html#l01555">PWM_O_X_ISC</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Ints &amp;
            ~(<a class="code" href="pwm_8h.html#aeb1d75227023b5c383bb73e208295065">PWM_INT_CNT_ZERO</a> | <a class="code" href="pwm_8h.html#a1d726e323158250c6ddd76fad72aac07">PWM_INT_CNT_LOAD</a> | <a class="code" href="pwm_8h.html#a56aaed0ca7989fe08077dd07e9eabc4c">PWM_INT_CNT_AU</a> |
              <a class="code" href="pwm_8h.html#a40abc328f76d4a0d04a80d2a03e82a1f">PWM_INT_CNT_AD</a> | <a class="code" href="pwm_8h.html#a089507419b0b2dbdb037119669d4da6d">PWM_INT_CNT_BU</a> | <a class="code" href="pwm_8h.html#a9d85a0bcc075114071bb308dc383c2cd">PWM_INT_CNT_BD</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Clear the requested interrupts by writing ones to the specified bit</span>
    <span class="comment">// of the module&#39;s interrupt enable register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#a48bfde513714c0a770d3fc66932a0ab9">PWM_O_X_ISC</a>) = ui32Ints;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga1bd27374e6dce2e1a2689166b79be9f6"></a><!-- doxytag: member="pwm.c::PWMGenIntRegister" ref="ga1bd27374e6dce2e1a2689166b79be9f6" args="(uint32_t ui32Base, uint32_t ui32Gen, void(*pfnIntHandler)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga1bd27374e6dce2e1a2689166b79be9f6">PWMGenIntRegister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnIntHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers an interrupt handler for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator in question. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">pfnIntHandler</td><td>is a pointer to the function to be called when the PWM generator interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function ensures that the interrupt handler specified by <em>pfnIntHandler</em> is called when an interrupt is detected for the specified PWM generator block. This function also enables the corresponding PWM generator interrupt in the interrupt controller; individual generator interrupts and interrupt sources must be enabled with <a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable()</a> and <a class="el" href="group__pwm__api.html#ga31055ec13555e774fa6702e35b774518">PWMGenIntTrigEnable()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01088">1088</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="pwm_8c_source.html#l00923">_PWMGenIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="interrupt_8c_source.html#l00610">IntEnable()</a>, <a class="el" href="interrupt_8c_source.html#l00309">IntRegister()</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, and <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number associated with the specified generator.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d">_PWMGenIntNumberGet</a>(ui32Base, ui32Gen);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Register the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister</a>(ui32Int, pfnIntHandler);

    <span class="comment">//</span>
    <span class="comment">// Enable the PWMx interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce">IntEnable</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_ga1bd27374e6dce2e1a2689166b79be9f6_cgraph.png" border="0" usemap="#group__pwm__api_ga1bd27374e6dce2e1a2689166b79be9f6_cgraph" alt=""/></div>
<map name="group__pwm__api_ga1bd27374e6dce2e1a2689166b79be9f6_cgraph" id="group__pwm__api_ga1bd27374e6dce2e1a2689166b79be9f6_cgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d" title="_PWMGenIntNumberGet" alt="" coords="197,5,365,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga49fc9c3d1a0f8c42a20249f8c5d360ce" title="IntEnable" alt="" coords="243,59,320,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9" title="IntRegister" alt="" coords="239,112,324,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga645372a9dd99a0683d7c8e53006357ed"></a><!-- doxytag: member="pwm.c::PWMGenIntStatus" ref="ga645372a9dd99a0683d7c8e53006357ed" args="(uint32_t ui32Base, uint32_t ui32Gen, bool bMasked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#ga645372a9dd99a0683d7c8e53006357ed">PWMGenIntStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets interrupt status for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">bMasked</td><td>specifies whether masked or raw interrupt status is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>bMasked</em> is set as <b>true</b>, then the masked interrupt status is returned; otherwise, the raw interrupt status is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the contents of the interrupt status register or the contents of the raw interrupt status register for the specified PWM generator. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01396">1396</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01555">PWM_O_X_ISC</a>, and <a class="el" href="hw__pwm_8h_source.html#l01554">PWM_O_X_RIS</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32Gen = <a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen);

    <span class="comment">//</span>
    <span class="comment">// Read and return the specified generator&#39;s raw or enabled interrupt</span>
    <span class="comment">// status.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bMasked == <span class="keyword">true</span>)
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a48bfde513714c0a770d3fc66932a0ab9">PWM_O_X_ISC</a>));
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a8b93813a792b024247c320beeec344b2">PWM_O_X_RIS</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gafdd8f3c8343e5b06916bb6ba5ead9533"></a><!-- doxytag: member="pwm.c::PWMGenIntTrigDisable" ref="gafdd8f3c8343e5b06916bb6ba5ead9533" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gafdd8f3c8343e5b06916bb6ba5ead9533">PWMGenIntTrigDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntTrig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables interrupts for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to have interrupts and triggers disabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32IntTrig</td><td>specifies the interrupts and triggers to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function masks the specified interrupt(s) and trigger(s) by clearing the specified bits of the interrupt/trigger enable register for the specified PWM generator. The <em>ui32IntTrig</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, <b>PWM_INT_CNT_BD</b>, <b>PWM_TR_CNT_ZERO</b>, <b>PWM_TR_CNT_LOAD</b>, <b>PWM_TR_CNT_AU</b>, <b>PWM_TR_CNT_AD</b>, <b>PWM_TR_CNT_BU</b>, or <b>PWM_TR_CNT_BD</b>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01357">1357</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="pwm_8h_source.html#l00104">PWM_INT_CNT_AD</a>, <a class="el" href="pwm_8h_source.html#l00103">PWM_INT_CNT_AU</a>, <a class="el" href="pwm_8h_source.html#l00106">PWM_INT_CNT_BD</a>, <a class="el" href="pwm_8h_source.html#l00105">PWM_INT_CNT_BU</a>, <a class="el" href="pwm_8h_source.html#l00102">PWM_INT_CNT_LOAD</a>, <a class="el" href="pwm_8h_source.html#l00101">PWM_INT_CNT_ZERO</a>, <a class="el" href="hw__pwm_8h_source.html#l01553">PWM_O_X_INTEN</a>, <a class="el" href="pwm_8h_source.html#l00110">PWM_TR_CNT_AD</a>, <a class="el" href="pwm_8h_source.html#l00109">PWM_TR_CNT_AU</a>, <a class="el" href="pwm_8h_source.html#l00112">PWM_TR_CNT_BD</a>, <a class="el" href="pwm_8h_source.html#l00111">PWM_TR_CNT_BU</a>, <a class="el" href="pwm_8h_source.html#l00108">PWM_TR_CNT_LOAD</a>, and <a class="el" href="pwm_8h_source.html#l00107">PWM_TR_CNT_ZERO</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32IntTrig &amp; ~(<a class="code" href="pwm_8h.html#aeb1d75227023b5c383bb73e208295065">PWM_INT_CNT_ZERO</a> | <a class="code" href="pwm_8h.html#a1d726e323158250c6ddd76fad72aac07">PWM_INT_CNT_LOAD</a> |
                            <a class="code" href="pwm_8h.html#a56aaed0ca7989fe08077dd07e9eabc4c">PWM_INT_CNT_AU</a> | <a class="code" href="pwm_8h.html#a40abc328f76d4a0d04a80d2a03e82a1f">PWM_INT_CNT_AD</a> | <a class="code" href="pwm_8h.html#a089507419b0b2dbdb037119669d4da6d">PWM_INT_CNT_BU</a> |
                            <a class="code" href="pwm_8h.html#a9d85a0bcc075114071bb308dc383c2cd">PWM_INT_CNT_BD</a> | <a class="code" href="pwm_8h.html#a0294f9bca8e82bf7439e5558cf7d367e">PWM_TR_CNT_ZERO</a> |
                            <a class="code" href="pwm_8h.html#a585bcca497239612396a7bdc800eda17">PWM_TR_CNT_LOAD</a> | <a class="code" href="pwm_8h.html#a1749f452a9ddedc99002c49d38bd69ea">PWM_TR_CNT_AU</a> | <a class="code" href="pwm_8h.html#acf2e57970d238071dcd334185de293e8">PWM_TR_CNT_AD</a> |
                            <a class="code" href="pwm_8h.html#aef05b4f553d2cb63e8a9618210be07f6">PWM_TR_CNT_BU</a> | <a class="code" href="pwm_8h.html#a2bc4627c1acc21d6d53dde6b71af7b92">PWM_TR_CNT_BD</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Disable the specified interrupts/triggers.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#a274ce941a231d4940461015b72525b65">PWM_O_X_INTEN</a>) &amp;= ~(ui32IntTrig);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga31055ec13555e774fa6702e35b774518"></a><!-- doxytag: member="pwm.c::PWMGenIntTrigEnable" ref="ga31055ec13555e774fa6702e35b774518" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32IntTrig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga31055ec13555e774fa6702e35b774518">PWMGenIntTrigEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32IntTrig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables interrupts and triggers for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to have interrupts and triggers enabled. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32IntTrig</td><td>specifies the interrupts and triggers to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unmasks the specified interrupt(s) and trigger(s) by setting the specified bits of the interrupt/trigger enable register for the specified PWM generator. The <em>ui32IntTrig</em> parameter is the logical OR of <b>PWM_INT_CNT_ZERO</b>, <b>PWM_INT_CNT_LOAD</b>, <b>PWM_INT_CNT_AU</b>, <b>PWM_INT_CNT_AD</b>, <b>PWM_INT_CNT_BU</b>, <b>PWM_INT_CNT_BD</b>, <b>PWM_TR_CNT_ZERO</b>, <b>PWM_TR_CNT_LOAD</b>, <b>PWM_TR_CNT_AU</b>, <b>PWM_TR_CNT_AD</b>, <b>PWM_TR_CNT_BU</b>, or <b>PWM_TR_CNT_BD</b>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01315">1315</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="pwm_8h_source.html#l00104">PWM_INT_CNT_AD</a>, <a class="el" href="pwm_8h_source.html#l00103">PWM_INT_CNT_AU</a>, <a class="el" href="pwm_8h_source.html#l00106">PWM_INT_CNT_BD</a>, <a class="el" href="pwm_8h_source.html#l00105">PWM_INT_CNT_BU</a>, <a class="el" href="pwm_8h_source.html#l00102">PWM_INT_CNT_LOAD</a>, <a class="el" href="pwm_8h_source.html#l00101">PWM_INT_CNT_ZERO</a>, <a class="el" href="hw__pwm_8h_source.html#l01553">PWM_O_X_INTEN</a>, <a class="el" href="pwm_8h_source.html#l00110">PWM_TR_CNT_AD</a>, <a class="el" href="pwm_8h_source.html#l00109">PWM_TR_CNT_AU</a>, <a class="el" href="pwm_8h_source.html#l00112">PWM_TR_CNT_BD</a>, <a class="el" href="pwm_8h_source.html#l00111">PWM_TR_CNT_BU</a>, <a class="el" href="pwm_8h_source.html#l00108">PWM_TR_CNT_LOAD</a>, and <a class="el" href="pwm_8h_source.html#l00107">PWM_TR_CNT_ZERO</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32IntTrig &amp; ~(<a class="code" href="pwm_8h.html#aeb1d75227023b5c383bb73e208295065">PWM_INT_CNT_ZERO</a> | <a class="code" href="pwm_8h.html#a1d726e323158250c6ddd76fad72aac07">PWM_INT_CNT_LOAD</a> |
                            <a class="code" href="pwm_8h.html#a56aaed0ca7989fe08077dd07e9eabc4c">PWM_INT_CNT_AU</a> | <a class="code" href="pwm_8h.html#a40abc328f76d4a0d04a80d2a03e82a1f">PWM_INT_CNT_AD</a> | <a class="code" href="pwm_8h.html#a089507419b0b2dbdb037119669d4da6d">PWM_INT_CNT_BU</a> |
                            <a class="code" href="pwm_8h.html#a9d85a0bcc075114071bb308dc383c2cd">PWM_INT_CNT_BD</a> | <a class="code" href="pwm_8h.html#a0294f9bca8e82bf7439e5558cf7d367e">PWM_TR_CNT_ZERO</a> |
                            <a class="code" href="pwm_8h.html#a585bcca497239612396a7bdc800eda17">PWM_TR_CNT_LOAD</a> | <a class="code" href="pwm_8h.html#a1749f452a9ddedc99002c49d38bd69ea">PWM_TR_CNT_AU</a> | <a class="code" href="pwm_8h.html#acf2e57970d238071dcd334185de293e8">PWM_TR_CNT_AD</a> |
                            <a class="code" href="pwm_8h.html#aef05b4f553d2cb63e8a9618210be07f6">PWM_TR_CNT_BU</a> | <a class="code" href="pwm_8h.html#a2bc4627c1acc21d6d53dde6b71af7b92">PWM_TR_CNT_BD</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Enable the specified interrupts/triggers.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen) + <a class="code" href="hw__pwm_8h.html#a274ce941a231d4940461015b72525b65">PWM_O_X_INTEN</a>) |= ui32IntTrig;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga93c72c556d0febbd7d641df12f30d7b1"></a><!-- doxytag: member="pwm.c::PWMGenIntUnregister" ref="ga93c72c556d0febbd7d641df12f30d7b1" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga93c72c556d0febbd7d641df12f30d7b1">PWMGenIntUnregister</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes an interrupt handler for the specified PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator in question. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unregisters the interrupt handler for the specified PWM generator block. This function also disables the corresponding PWM generator interrupt in the interrupt controller; individual generator interrupts and interrupt sources must be disabled with <a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable()</a> and <a class="el" href="group__pwm__api.html#gafdd8f3c8343e5b06916bb6ba5ead9533">PWMGenIntTrigDisable()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01138">1138</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="pwm_8c_source.html#l00923">_PWMGenIntNumberGet()</a>, <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="interrupt_8c_source.html#l00684">IntDisable()</a>, <a class="el" href="interrupt_8c_source.html#l00381">IntUnregister()</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, and <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Int;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Get the interrupt number associated with the specified generator.</span>
    <span class="comment">//</span>
    ui32Int = <a class="code" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d">_PWMGenIntNumberGet</a>(ui32Base, ui32Gen);

    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Int != 0);

    <span class="comment">//</span>
    <span class="comment">// Disable the PWMx interrupt.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334">IntDisable</a>(ui32Int);

    <span class="comment">//</span>
    <span class="comment">// Unregister the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a">IntUnregister</a>(ui32Int);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__pwm__api_ga93c72c556d0febbd7d641df12f30d7b1_cgraph.png" border="0" usemap="#group__pwm__api_ga93c72c556d0febbd7d641df12f30d7b1_cgraph" alt=""/></div>
<map name="group__pwm__api_ga93c72c556d0febbd7d641df12f30d7b1_cgraph" id="group__pwm__api_ga93c72c556d0febbd7d641df12f30d7b1_cgraph">
<area shape="rect" id="node3" href="group__pwm__api.html#ga0656fb50e678e2694d5cf4ad830b688d" title="_PWMGenIntNumberGet" alt="" coords="208,5,376,35"/><area shape="rect" id="node5" href="group__interrupt__api.html#ga9af6b00884dc44e92b3d05ff821b5334" title="IntDisable" alt="" coords="252,59,332,88"/><area shape="rect" id="node7" href="group__interrupt__api.html#ga5dffc81c27c005f83e9bfc30f775982a" title="IntUnregister" alt="" coords="244,112,340,141"/><area shape="rect" id="node9" href="group__interrupt__api.html#gaef37c406caeeb884ba343265b953120d" title="_IntDefaultHandler" alt="" coords="424,112,555,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga318c7e9cfc0c4abc0c1efc3154bc0810"></a><!-- doxytag: member="pwm.c::PWMGenPeriodGet" ref="ga318c7e9cfc0c4abc0c1efc3154bc0810" args="(uint32_t ui32Base, uint32_t ui32Gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#ga318c7e9cfc0c4abc0c1efc3154bc0810">PWMGenPeriodGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the period of a PWM generator block.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to query. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the period of the specified PWM generator block. The period of the generator block is defined as the number of PWM clock ticks between pulses on the generator block zero signal.</p>
<p>If the update of the counter for the specified PWM generator has yet to be completed, the value returned may not be the active period. The value returned is the programmed period, measured in PWM clock ticks.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the programmed period of the specified generator block in PWM clock ticks. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00336">336</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01556">PWM_O_X_LOAD</a>, and <a class="el" href="hw__pwm_8h_source.html#l01605">PWM_X_CTL_MODE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32Gen = <a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen);

    <span class="comment">//</span>
    <span class="comment">// Figure out the counter mode.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp; <a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// The period is twice the reload register value.</span>
        <span class="comment">//</span>
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>) * 2);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// The period is the reload register value plus one.</span>
        <span class="comment">//</span>
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>) + 1);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0ec9d188f8e72f597f4f5bf41152468d"></a><!-- doxytag: member="pwm.c::PWMGenPeriodSet" ref="ga0ec9d188f8e72f597f4f5bf41152468d" args="(uint32_t ui32Base, uint32_t ui32Gen, uint32_t ui32Period)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga0ec9d188f8e72f597f4f5bf41152468d">PWMGenPeriodSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the period of a PWM generator.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32Gen</td><td>is the PWM generator to be modified. This parameter must be one of <b>PWM_GEN_0</b>, <b>PWM_GEN_1</b>, <b>PWM_GEN_2</b>, or <b>PWM_GEN_3</b>. </td></tr>
    <tr><td class="paramname">ui32Period</td><td>specifies the period of PWM generator output, measured in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the period of the specified PWM generator block, where the period of the generator block is defined as the number of PWM clock ticks between pulses on the generator block zero signal.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Any subsequent calls made to this function before an update occurs cause the previous values to be overwritten.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00278">278</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00064">PWM_GEN_BADDR</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01556">PWM_O_X_LOAD</a>, and <a class="el" href="hw__pwm_8h_source.html#l01605">PWM_X_CTL_MODE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMGenValid(ui32Gen));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32Gen = <a class="code" href="group__pwm__api.html#ga7fa2c9868b0c6fe74c9a90ade752130a">PWM_GEN_BADDR</a>(ui32Base, ui32Gen);

    <span class="comment">//</span>
    <span class="comment">// Set the reload register based on the mode.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp; <a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// In up/down count mode, set the reload register to half the requested</span>
        <span class="comment">// period.</span>
        <span class="comment">//</span>
        <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Period / 2) &lt; 65536);
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>) = ui32Period / 2;
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// In down count mode, set the reload register to the requested period</span>
        <span class="comment">// minus one.</span>
        <span class="comment">//</span>
        <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Period &lt;= 65536) &amp;&amp; (ui32Period != 0));
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Gen + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>) = ui32Period - 1;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gacaca72e1bc8b2f041b6e6ad290d54a12"></a><!-- doxytag: member="pwm.c::PWMIntDisable" ref="gacaca72e1bc8b2f041b6e6ad290d54a12" args="(uint32_t ui32Base, uint32_t ui32GenFault)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gacaca72e1bc8b2f041b6e6ad290d54a12">PWMIntDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables generator and fault interrupts for a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenFault</td><td>contains the interrupts to be disabled. This parameter must be a logical OR of any of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function masks the specified interrupt(s) by clearing the specified bits of the interrupt enable register for the selected PWM module.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01520">1520</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00123">PWM_INT_FAULT0</a>, <a class="el" href="pwm_8h_source.html#l00124">PWM_INT_FAULT1</a>, <a class="el" href="pwm_8h_source.html#l00125">PWM_INT_FAULT2</a>, <a class="el" href="pwm_8h_source.html#l00126">PWM_INT_FAULT3</a>, <a class="el" href="pwm_8h_source.html#l00119">PWM_INT_GEN_0</a>, <a class="el" href="pwm_8h_source.html#l00120">PWM_INT_GEN_1</a>, <a class="el" href="pwm_8h_source.html#l00121">PWM_INT_GEN_2</a>, <a class="el" href="pwm_8h_source.html#l00122">PWM_INT_GEN_3</a>, and <a class="el" href="hw__pwm_8h_source.html#l00053">PWM_O_INTEN</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32GenFault &amp; ~(<a class="code" href="pwm_8h.html#a56aad7e178b5d972a8a6b5eb257ec0ba">PWM_INT_GEN_0</a> | <a class="code" href="pwm_8h.html#abd67d92488cca4be6e17d7e73c1d3c25">PWM_INT_GEN_1</a> | <a class="code" href="pwm_8h.html#ae0faac61216d11e98df2c14a2ca03e62">PWM_INT_GEN_2</a> |
                             <a class="code" href="pwm_8h.html#a3f01d20bf00a797c6a2424e365768eba">PWM_INT_GEN_3</a> | <a class="code" href="pwm_8h.html#a8d5c7e94c45b9eae8da1631f86f98d8c">PWM_INT_FAULT0</a> | <a class="code" href="pwm_8h.html#a27e565978748aab899996a0ff7a1819b">PWM_INT_FAULT1</a> |
                             <a class="code" href="pwm_8h.html#a063b3a167d74802df3f5534878394a94">PWM_INT_FAULT2</a> | <a class="code" href="pwm_8h.html#a9b210b75ac3ce8363ad91f066c9fb5b2">PWM_INT_FAULT3</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s interrupt enable register and disable interrupts</span>
    <span class="comment">// for the specified PWM generators.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a8e0078f9d852870deb619339c9efec79">PWM_O_INTEN</a>) &amp;= ~(ui32GenFault);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf66b481a351b0be5f06e163640319838"></a><!-- doxytag: member="pwm.c::PWMIntEnable" ref="gaf66b481a351b0be5f06e163640319838" args="(uint32_t ui32Base, uint32_t ui32GenFault)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gaf66b481a351b0be5f06e163640319838">PWMIntEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables generator and fault interrupts for a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenFault</td><td>contains the interrupts to be enabled. This parameter must be a logical OR of any of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, or <b>PWM_INT_FAULT3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unmasks the specified interrupt(s) by setting the specified bits of the interrupt enable register for the selected PWM module.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01486">1486</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00123">PWM_INT_FAULT0</a>, <a class="el" href="pwm_8h_source.html#l00124">PWM_INT_FAULT1</a>, <a class="el" href="pwm_8h_source.html#l00125">PWM_INT_FAULT2</a>, <a class="el" href="pwm_8h_source.html#l00126">PWM_INT_FAULT3</a>, <a class="el" href="pwm_8h_source.html#l00119">PWM_INT_GEN_0</a>, <a class="el" href="pwm_8h_source.html#l00120">PWM_INT_GEN_1</a>, <a class="el" href="pwm_8h_source.html#l00121">PWM_INT_GEN_2</a>, <a class="el" href="pwm_8h_source.html#l00122">PWM_INT_GEN_3</a>, and <a class="el" href="hw__pwm_8h_source.html#l00053">PWM_O_INTEN</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32GenFault &amp; ~(<a class="code" href="pwm_8h.html#a56aad7e178b5d972a8a6b5eb257ec0ba">PWM_INT_GEN_0</a> | <a class="code" href="pwm_8h.html#abd67d92488cca4be6e17d7e73c1d3c25">PWM_INT_GEN_1</a> | <a class="code" href="pwm_8h.html#ae0faac61216d11e98df2c14a2ca03e62">PWM_INT_GEN_2</a> |
                             <a class="code" href="pwm_8h.html#a3f01d20bf00a797c6a2424e365768eba">PWM_INT_GEN_3</a> | <a class="code" href="pwm_8h.html#a8d5c7e94c45b9eae8da1631f86f98d8c">PWM_INT_FAULT0</a> | <a class="code" href="pwm_8h.html#a27e565978748aab899996a0ff7a1819b">PWM_INT_FAULT1</a> |
                             <a class="code" href="pwm_8h.html#a063b3a167d74802df3f5534878394a94">PWM_INT_FAULT2</a> | <a class="code" href="pwm_8h.html#a9b210b75ac3ce8363ad91f066c9fb5b2">PWM_INT_FAULT3</a>)) == 0);

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s interrupt enable register and enable interrupts</span>
    <span class="comment">// for the specified PWM generators.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a8e0078f9d852870deb619339c9efec79">PWM_O_INTEN</a>) |= ui32GenFault;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac90f2873671ff65e9225d8238e068a14"></a><!-- doxytag: member="pwm.c::PWMIntStatus" ref="gac90f2873671ff65e9225d8238e068a14" args="(uint32_t ui32Base, bool bMasked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#gac90f2873671ff65e9225d8238e068a14">PWMIntStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the interrupt status for a PWM module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">bMasked</td><td>specifies whether masked or raw interrupt status is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>bMasked</em> is set as <b>true</b>, then the masked interrupt status is returned; otherwise, the raw interrupt status is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current interrupt status, enumerated as a bit field of <b>PWM_INT_GEN_0</b>, <b>PWM_INT_GEN_1</b>, <b>PWM_INT_GEN_2</b>, <b>PWM_INT_GEN_3</b>, <b>PWM_INT_FAULT0</b>, <b>PWM_INT_FAULT1</b>, <b>PWM_INT_FAULT2</b>, and <b>PWM_INT_FAULT3</b>. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l01595">1595</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00055">PWM_O_ISC</a>, and <a class="el" href="hw__pwm_8h_source.html#l00054">PWM_O_RIS</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));

    <span class="comment">//</span>
    <span class="comment">// Read and return either the module&#39;s raw or enabled interrupt status.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bMasked == <span class="keyword">true</span>)
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a9d0350ade304a5e3da0172223ccef8e8">PWM_O_ISC</a>));
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a1e8693844e59d999ed5adc27a12510b0">PWM_O_RIS</a>));
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga10e1cb93f663c916cf5403e29e1be898"></a><!-- doxytag: member="pwm.c::PWMOutputFault" ref="ga10e1cb93f663c916cf5403e29e1be898" args="(uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bFaultSuppress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga10e1cb93f663c916cf5403e29e1be898">PWMOutputFault</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaultSuppress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the state of PWM outputs in response to a fault condition.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bFaultSuppress</td><td>determines if the signal is suppressed or passed through during an active fault condition.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the fault handling characteristics of the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bFaultSuppress</em> determines the fault handling characteristics for the selected outputs. If <em>bFaultSuppress</em> is <b>true</b>, then the selected outputs are made inactive. If <em>bFaultSuppress</em> is <b>false</b>, then the selected outputs are unaffected by the detected fault.</p>
<p>On devices supporting extended PWM fault handling, the state the affected output pins are driven to can be configured with <a class="el" href="group__pwm__api.html#ga35b6c40b99278f7d78c186cd275b7a05">PWMOutputFaultLevel()</a>. If not configured, or if the device does not support extended PWM fault handling, affected outputs are driven low on a fault condition.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00883">883</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00052">PWM_O_FAULT</a>, <a class="el" href="pwm_8h_source.html#l00163">PWM_OUT_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00164">PWM_OUT_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00165">PWM_OUT_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00166">PWM_OUT_3_BIT</a>, <a class="el" href="pwm_8h_source.html#l00167">PWM_OUT_4_BIT</a>, <a class="el" href="pwm_8h_source.html#l00168">PWM_OUT_5_BIT</a>, <a class="el" href="pwm_8h_source.html#l00169">PWM_OUT_6_BIT</a>, and <a class="el" href="pwm_8h_source.html#l00170">PWM_OUT_7_BIT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32PWMOutBits &amp; ~(<a class="code" href="pwm_8h.html#acabd0bfe1bc92990f0c80fd2a487cd7a">PWM_OUT_0_BIT</a> | <a class="code" href="pwm_8h.html#a4c37e5abc3e74aba9d26d432d2959aa6">PWM_OUT_1_BIT</a> | <a class="code" href="pwm_8h.html#a86757449ecf9f08f32fdba87e1cacae3">PWM_OUT_2_BIT</a> |
                                <a class="code" href="pwm_8h.html#af8d39d2e9a63d18838a59cab4ee54366">PWM_OUT_3_BIT</a> | <a class="code" href="pwm_8h.html#a981bc1d2b8c4b25ce6ed60feceee7197">PWM_OUT_4_BIT</a> | <a class="code" href="pwm_8h.html#a26f4802f7a8aca5be1a70e3efc63ba03">PWM_OUT_5_BIT</a> |
                                <a class="code" href="pwm_8h.html#aceec3429d6c81e8a6ab9649130791f31">PWM_OUT_6_BIT</a> | <a class="code" href="pwm_8h.html#a284915f39f8bd6de1be2aa6b75b2455a">PWM_OUT_7_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s FAULT output control register and set or clear the</span>
    <span class="comment">// requested bits.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bFaultSuppress == <span class="keyword">true</span>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#aa4e67baa28e0adad20315635a86c41b5">PWM_O_FAULT</a>) |= ui32PWMOutBits;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#aa4e67baa28e0adad20315635a86c41b5">PWM_O_FAULT</a>) &amp;= ~(ui32PWMOutBits);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga35b6c40b99278f7d78c186cd275b7a05"></a><!-- doxytag: member="pwm.c::PWMOutputFaultLevel" ref="ga35b6c40b99278f7d78c186cd275b7a05" args="(uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bDriveHigh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga35b6c40b99278f7d78c186cd275b7a05">PWMOutputFaultLevel</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDriveHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the level of PWM outputs suppressed in response to a fault condition.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bDriveHigh</td><td>determines if the signal is driven high or low during an active fault condition.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines whether a PWM output pin that is suppressed in response to a fault condition is driven high or low. The affected outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bDriveHigh</em> determines the output level for the pins identified by <em>ui32PWMOutBits</em>. If <em>bDriveHigh</em> is <b>true</b> then the selected outputs are driven high when a fault is detected. If it is <em>false</em>, the pins are driven low.</p>
<p>In a fault condition, pins which have not been configured to be suppressed via a call to <a class="el" href="group__pwm__api.html#ga10e1cb93f663c916cf5403e29e1be898">PWMOutputFault()</a> are unaffected by this function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is available only on devices which support extended PWM fault handling.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00830">830</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00057">PWM_O_FAULTVAL</a>, <a class="el" href="pwm_8h_source.html#l00163">PWM_OUT_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00164">PWM_OUT_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00165">PWM_OUT_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00166">PWM_OUT_3_BIT</a>, <a class="el" href="pwm_8h_source.html#l00167">PWM_OUT_4_BIT</a>, <a class="el" href="pwm_8h_source.html#l00168">PWM_OUT_5_BIT</a>, <a class="el" href="pwm_8h_source.html#l00169">PWM_OUT_6_BIT</a>, and <a class="el" href="pwm_8h_source.html#l00170">PWM_OUT_7_BIT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32PWMOutBits &amp; ~(<a class="code" href="pwm_8h.html#acabd0bfe1bc92990f0c80fd2a487cd7a">PWM_OUT_0_BIT</a> | <a class="code" href="pwm_8h.html#a4c37e5abc3e74aba9d26d432d2959aa6">PWM_OUT_1_BIT</a> | <a class="code" href="pwm_8h.html#a86757449ecf9f08f32fdba87e1cacae3">PWM_OUT_2_BIT</a> |
                                <a class="code" href="pwm_8h.html#af8d39d2e9a63d18838a59cab4ee54366">PWM_OUT_3_BIT</a> | <a class="code" href="pwm_8h.html#a981bc1d2b8c4b25ce6ed60feceee7197">PWM_OUT_4_BIT</a> | <a class="code" href="pwm_8h.html#a26f4802f7a8aca5be1a70e3efc63ba03">PWM_OUT_5_BIT</a> |
                                <a class="code" href="pwm_8h.html#aceec3429d6c81e8a6ab9649130791f31">PWM_OUT_6_BIT</a> | <a class="code" href="pwm_8h.html#a284915f39f8bd6de1be2aa6b75b2455a">PWM_OUT_7_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s FAULT output control register and set or clear the</span>
    <span class="comment">// requested bits.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bDriveHigh == <span class="keyword">true</span>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a566b715029a6b74a4c2b41267f8d8bf5">PWM_O_FAULTVAL</a>) |= ui32PWMOutBits;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a566b715029a6b74a4c2b41267f8d8bf5">PWM_O_FAULTVAL</a>) &amp;= ~(ui32PWMOutBits);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf233159a77a070f2dc60d50da3939ba9"></a><!-- doxytag: member="pwm.c::PWMOutputInvert" ref="gaf233159a77a070f2dc60d50da3939ba9" args="(uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bInvert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gaf233159a77a070f2dc60d50da3939ba9">PWMOutputInvert</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInvert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects the inversion mode for PWM outputs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bInvert</td><td>determines if the signal is inverted or passed through.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to select the inversion mode for the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bInvert</em> determines the inversion mode for the selected outputs. If <em>bInvert</em> is <b>true</b>, this function causes the specified PWM output signals to be inverted or made active low. If <em>bInvert</em> is <b>false</b>, the specified outputs are passed through as is or made active high.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00774">774</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00051">PWM_O_INVERT</a>, <a class="el" href="pwm_8h_source.html#l00163">PWM_OUT_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00164">PWM_OUT_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00165">PWM_OUT_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00166">PWM_OUT_3_BIT</a>, <a class="el" href="pwm_8h_source.html#l00167">PWM_OUT_4_BIT</a>, <a class="el" href="pwm_8h_source.html#l00168">PWM_OUT_5_BIT</a>, <a class="el" href="pwm_8h_source.html#l00169">PWM_OUT_6_BIT</a>, and <a class="el" href="pwm_8h_source.html#l00170">PWM_OUT_7_BIT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32PWMOutBits &amp; ~(<a class="code" href="pwm_8h.html#acabd0bfe1bc92990f0c80fd2a487cd7a">PWM_OUT_0_BIT</a> | <a class="code" href="pwm_8h.html#a4c37e5abc3e74aba9d26d432d2959aa6">PWM_OUT_1_BIT</a> | <a class="code" href="pwm_8h.html#a86757449ecf9f08f32fdba87e1cacae3">PWM_OUT_2_BIT</a> |
                                <a class="code" href="pwm_8h.html#af8d39d2e9a63d18838a59cab4ee54366">PWM_OUT_3_BIT</a> | <a class="code" href="pwm_8h.html#a981bc1d2b8c4b25ce6ed60feceee7197">PWM_OUT_4_BIT</a> | <a class="code" href="pwm_8h.html#a26f4802f7a8aca5be1a70e3efc63ba03">PWM_OUT_5_BIT</a> |
                                <a class="code" href="pwm_8h.html#aceec3429d6c81e8a6ab9649130791f31">PWM_OUT_6_BIT</a> | <a class="code" href="pwm_8h.html#a284915f39f8bd6de1be2aa6b75b2455a">PWM_OUT_7_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s INVERT output control register and set or clear the</span>
    <span class="comment">// requested bits.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bInvert == <span class="keyword">true</span>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a9699ee3e34950c4fd8d49ab3cd7213d9">PWM_O_INVERT</a>) |= ui32PWMOutBits;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#a9699ee3e34950c4fd8d49ab3cd7213d9">PWM_O_INVERT</a>) &amp;= ~(ui32PWMOutBits);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga372c69ae52fe1136454b60230f38beb1"></a><!-- doxytag: member="pwm.c::PWMOutputState" ref="ga372c69ae52fe1136454b60230f38beb1" args="(uint32_t ui32Base, uint32_t ui32PWMOutBits, bool bEnable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga372c69ae52fe1136454b60230f38beb1">PWMOutputState</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables or disables PWM outputs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">bEnable</td><td>determines if the signal is enabled or disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables the selected PWM outputs. The outputs are selected using the parameter <em>ui32PWMOutBits</em>. The parameter <em>bEnable</em> determines the state of the selected outputs. If <em>bEnable</em> is <b>true</b>, then the selected PWM outputs are enabled, or placed in the active state. If <em>bEnable</em> is <b>false</b>, then the selected outputs are disabled or placed in the inactive state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00726">726</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00050">PWM_O_ENABLE</a>, <a class="el" href="pwm_8h_source.html#l00163">PWM_OUT_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00164">PWM_OUT_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00165">PWM_OUT_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00166">PWM_OUT_3_BIT</a>, <a class="el" href="pwm_8h_source.html#l00167">PWM_OUT_4_BIT</a>, <a class="el" href="pwm_8h_source.html#l00168">PWM_OUT_5_BIT</a>, <a class="el" href="pwm_8h_source.html#l00169">PWM_OUT_6_BIT</a>, and <a class="el" href="pwm_8h_source.html#l00170">PWM_OUT_7_BIT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32PWMOutBits &amp; ~(<a class="code" href="pwm_8h.html#acabd0bfe1bc92990f0c80fd2a487cd7a">PWM_OUT_0_BIT</a> | <a class="code" href="pwm_8h.html#a4c37e5abc3e74aba9d26d432d2959aa6">PWM_OUT_1_BIT</a> | <a class="code" href="pwm_8h.html#a86757449ecf9f08f32fdba87e1cacae3">PWM_OUT_2_BIT</a> |
                                <a class="code" href="pwm_8h.html#af8d39d2e9a63d18838a59cab4ee54366">PWM_OUT_3_BIT</a> | <a class="code" href="pwm_8h.html#a981bc1d2b8c4b25ce6ed60feceee7197">PWM_OUT_4_BIT</a> | <a class="code" href="pwm_8h.html#a26f4802f7a8aca5be1a70e3efc63ba03">PWM_OUT_5_BIT</a> |
                                <a class="code" href="pwm_8h.html#aceec3429d6c81e8a6ab9649130791f31">PWM_OUT_6_BIT</a> | <a class="code" href="pwm_8h.html#a284915f39f8bd6de1be2aa6b75b2455a">PWM_OUT_7_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Read the module&#39;s ENABLE output control register and set or clear the</span>
    <span class="comment">// requested bits.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(bEnable == <span class="keyword">true</span>)
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ad4953999490890fdfcaf92f26cbf31a4">PWM_O_ENABLE</a>) |= ui32PWMOutBits;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ad4953999490890fdfcaf92f26cbf31a4">PWM_O_ENABLE</a>) &amp;= ~(ui32PWMOutBits);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga77b64a04eb1bd9daf99c10d549a8ada5"></a><!-- doxytag: member="pwm.c::PWMOutputUpdateMode" ref="ga77b64a04eb1bd9daf99c10d549a8ada5" args="(uint32_t ui32Base, uint32_t ui32PWMOutBits, uint32_t ui32Mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga77b64a04eb1bd9daf99c10d549a8ada5">PWMOutputUpdateMode</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOutBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the update mode or synchronization mode to the PWM outputs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOutBits</td><td>are the PWM outputs to be modified. This parameter must be the logical OR of any of <b>PWM_OUT_0_BIT</b>, <b>PWM_OUT_1_BIT</b>, <b>PWM_OUT_2_BIT</b>, <b>PWM_OUT_3_BIT</b>, <b>PWM_OUT_4_BIT</b>, <b>PWM_OUT_5_BIT</b>, <b>PWM_OUT_6_BIT</b>, or <b>PWM_OUT_7_BIT</b>. </td></tr>
    <tr><td class="paramname">ui32Mode</td><td>specifies the enable update mode to use when enabling or disabling PWM outputs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets one of three possible update modes to enable or disable the requested PWM outputs. The <em>ui32Mode</em> parameter controls when changes made via calls to <a class="el" href="group__pwm__api.html#ga372c69ae52fe1136454b60230f38beb1">PWMOutputState()</a> take effect. Possible values are:</p>
<ul>
<li><b>PWM_OUTPUT_MODE_NO_SYNC</b>, which enables/disables changes to take effect immediately.</li>
<li><b>PWM_OUTPUT_MODE_SYNC_LOCAL</b>, which causes changes to take effect when the local PWM generator's count next reaches 0.</li>
<li><b>PWM_OUTPUT_MODE_SYNC_GLOBAL</b>, which causes changes to take effect when the local PWM generator's count next reaches 0 following a call to <a class="el" href="group__pwm__api.html#ga32a04801267751f323f528cd3d5f2da5">PWMSyncUpdate()</a> which specifies the same generator in its <em>ui32GenBits</em> parameter.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only available on Snowflake class devices.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l02088">2088</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="hw__pwm_8h_source.html#l00058">PWM_O_ENUPD</a>, <a class="el" href="pwm_8h_source.html#l00163">PWM_OUT_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00164">PWM_OUT_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00165">PWM_OUT_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00166">PWM_OUT_3_BIT</a>, <a class="el" href="pwm_8h_source.html#l00167">PWM_OUT_4_BIT</a>, <a class="el" href="pwm_8h_source.html#l00168">PWM_OUT_5_BIT</a>, <a class="el" href="pwm_8h_source.html#l00169">PWM_OUT_6_BIT</a>, <a class="el" href="pwm_8h_source.html#l00170">PWM_OUT_7_BIT</a>, <a class="el" href="pwm_8h_source.html#l00239">PWM_OUTPUT_MODE_NO_SYNC</a>, <a class="el" href="pwm_8h_source.html#l00242">PWM_OUTPUT_MODE_SYNC_GLOBAL</a>, and <a class="el" href="pwm_8h_source.html#l00240">PWM_OUTPUT_MODE_SYNC_LOCAL</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint_fast8_t ui8Index;
    uint32_t ui32PWMOutputMask;
    uint32_t ui32UpdateValueMask;
    uint32_t ui32UpdateValue;
    uint32_t ui32Temp;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32PWMOutBits &amp; ~(<a class="code" href="pwm_8h.html#acabd0bfe1bc92990f0c80fd2a487cd7a">PWM_OUT_0_BIT</a> | <a class="code" href="pwm_8h.html#a4c37e5abc3e74aba9d26d432d2959aa6">PWM_OUT_1_BIT</a> | <a class="code" href="pwm_8h.html#a86757449ecf9f08f32fdba87e1cacae3">PWM_OUT_2_BIT</a> |
                                <a class="code" href="pwm_8h.html#af8d39d2e9a63d18838a59cab4ee54366">PWM_OUT_3_BIT</a> | <a class="code" href="pwm_8h.html#a981bc1d2b8c4b25ce6ed60feceee7197">PWM_OUT_4_BIT</a> | <a class="code" href="pwm_8h.html#a26f4802f7a8aca5be1a70e3efc63ba03">PWM_OUT_5_BIT</a> |
                                <a class="code" href="pwm_8h.html#aceec3429d6c81e8a6ab9649130791f31">PWM_OUT_6_BIT</a> | <a class="code" href="pwm_8h.html#a284915f39f8bd6de1be2aa6b75b2455a">PWM_OUT_7_BIT</a>)));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Mode == <a class="code" href="pwm_8h.html#a40a2968574390cf9b45a8c2032f14161">PWM_OUTPUT_MODE_NO_SYNC</a>) ||
           (ui32Mode == <a class="code" href="pwm_8h.html#acd1a7806e4fa48c67c522ed725d84b9c">PWM_OUTPUT_MODE_SYNC_LOCAL</a>) ||
           (ui32Mode == <a class="code" href="pwm_8h.html#a4371f0f35878e643f37d0093008dd296">PWM_OUTPUT_MODE_SYNC_GLOBAL</a>));

    <span class="comment">//</span>
    <span class="comment">// Initialize the local variables</span>
    <span class="comment">//</span>
    ui8Index = 0;
    ui32PWMOutputMask = 1;
    ui32UpdateValue = 0;
    ui32UpdateValueMask = 0;

    <span class="comment">//</span>
    <span class="comment">// Loop to find out which PWM outputs are to be modified.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(ui8Index &lt; 8)
    {
        <span class="comment">//</span>
        <span class="comment">// Check if this PWM output is to be modified.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(ui32PWMOutputMask &amp; ui32PWMOutBits)
        {
            <span class="comment">//</span>
            <span class="comment">// Set the update mode value for the requested PWM output by</span>
            <span class="comment">// writing to the appropriate field.</span>
            <span class="comment">//</span>
            ui32UpdateValue |= ui32Mode &lt;&lt; (ui8Index * 2);

            <span class="comment">//</span>
            <span class="comment">// Compute the mask for the bits to be updated.</span>
            <span class="comment">//</span>
            ui32UpdateValueMask |= 3 &lt;&lt; (ui8Index * 2);
        }

        <span class="comment">//</span>
        <span class="comment">// Update the PWM output to be checked and the index.</span>
        <span class="comment">//</span>
        ui32PWMOutputMask = ui32PWMOutputMask &lt;&lt; 1;
        ui8Index++;
    }

    <span class="comment">//</span>
    <span class="comment">// Read the Enable Update register and mask the bits that are to be</span>
    <span class="comment">// updated.</span>
    <span class="comment">//</span>
    ui32Temp = ~ui32UpdateValueMask &amp; <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#af92fbd4885657447d911331425fdd215">PWM_O_ENUPD</a>);

    <span class="comment">//</span>
    <span class="comment">// Write the updated values to Enable Update register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#af92fbd4885657447d911331425fdd215">PWM_O_ENUPD</a>) = ui32Temp | ui32UpdateValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae361688d19da3c776f82e31607392f3f"></a><!-- doxytag: member="pwm.c::PWMPulseWidthGet" ref="gae361688d19da3c776f82e31607392f3f" args="(uint32_t ui32Base, uint32_t ui32PWMOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__pwm__api.html#gae361688d19da3c776f82e31607392f3f">PWMPulseWidthGet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the pulse width of a PWM output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOut</td><td>is the PWM output to query. This parameter must be one of <b>PWM_OUT_0</b>, <b>PWM_OUT_1</b>, <b>PWM_OUT_2</b>, <b>PWM_OUT_3</b>, <b>PWM_OUT_4</b>, <b>PWM_OUT_5</b>, <b>PWM_OUT_6</b>, or <b>PWM_OUT_7</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the currently programmed pulse width for the specified PWM output. If the update of the comparator for the specified output has yet to be completed, the value returned may not be the active pulse width. The value returned is the programmed pulse width, measured in PWM clock ticks.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the width of the pulse in PWM clock ticks. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00518">518</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00071">PWM_IS_OUTPUT_ODD</a>, <a class="el" href="hw__pwm_8h_source.html#l01558">PWM_O_X_CMPA</a>, <a class="el" href="hw__pwm_8h_source.html#l01559">PWM_O_X_CMPB</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01556">PWM_O_X_LOAD</a>, <a class="el" href="pwm_8c_source.html#l00069">PWM_OUT_BADDR</a>, and <a class="el" href="hw__pwm_8h_source.html#l01605">PWM_X_CTL_MODE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32GenBase, ui32Reg, ui32Load;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMOutValid(ui32PWMOut));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32GenBase = <a class="code" href="group__pwm__api.html#ga4563e3820191c9d6e73156340b715264">PWM_OUT_BADDR</a>(ui32Base, ui32PWMOut);

    <span class="comment">//</span>
    <span class="comment">// Then compute the pulse width.  If mode is UpDown, set</span>
    <span class="comment">// width = (load - compare) * 2.  Otherwise, set width = load - compare.</span>
    <span class="comment">//</span>
    ui32Load = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>);
    <span class="keywordflow">if</span>(<a class="code" href="group__pwm__api.html#ga7904efa054c5e221ee9aa2e438f37100">PWM_IS_OUTPUT_ODD</a>(ui32PWMOut))
    {
        ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a3b74b07279be2652f559a58b0be56467">PWM_O_X_CMPB</a>);
    }
    <span class="keywordflow">else</span>
    {
        ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a29a199ff01230c7cef834f2a7993c9a6">PWM_O_X_CMPA</a>);
    }
    ui32Reg = ui32Load - ui32Reg;

    <span class="comment">//</span>
    <span class="comment">// If in up/down count mode, double the pulse width.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp; <a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a>)
    {
        ui32Reg = ui32Reg * 2;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the pulse width.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ui32Reg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga2abde7fc411bf9cad8de0c5dc070c78c"></a><!-- doxytag: member="pwm.c::PWMPulseWidthSet" ref="ga2abde7fc411bf9cad8de0c5dc070c78c" args="(uint32_t ui32Base, uint32_t ui32PWMOut, uint32_t ui32Width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga2abde7fc411bf9cad8de0c5dc070c78c">PWMPulseWidthSet</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32PWMOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the pulse width for the specified PWM output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32PWMOut</td><td>is the PWM output to modify. This parameter must be one of <b>PWM_OUT_0</b>, <b>PWM_OUT_1</b>, <b>PWM_OUT_2</b>, <b>PWM_OUT_3</b>, <b>PWM_OUT_4</b>, <b>PWM_OUT_5</b>, <b>PWM_OUT_6</b>, or <b>PWM_OUT_7</b>. </td></tr>
    <tr><td class="paramname">ui32Width</td><td>specifies the width of the positive portion of the pulse.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the pulse width for the specified PWM output, where the pulse width is defined as the number of PWM clock ticks.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Any subsequent calls made to this function before an update occurs cause the previous values to be overwritten.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00447">447</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8c_source.html#l00071">PWM_IS_OUTPUT_ODD</a>, <a class="el" href="hw__pwm_8h_source.html#l01558">PWM_O_X_CMPA</a>, <a class="el" href="hw__pwm_8h_source.html#l01559">PWM_O_X_CMPB</a>, <a class="el" href="hw__pwm_8h_source.html#l01552">PWM_O_X_CTL</a>, <a class="el" href="hw__pwm_8h_source.html#l01556">PWM_O_X_LOAD</a>, <a class="el" href="pwm_8c_source.html#l00069">PWM_OUT_BADDR</a>, and <a class="el" href="hw__pwm_8h_source.html#l01605">PWM_X_CTL_MODE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32GenBase, ui32Reg;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(_PWMOutValid(ui32PWMOut));

    <span class="comment">//</span>
    <span class="comment">// Compute the generator&#39;s base address.</span>
    <span class="comment">//</span>
    ui32GenBase = <a class="code" href="group__pwm__api.html#ga4563e3820191c9d6e73156340b715264">PWM_OUT_BADDR</a>(ui32Base, ui32PWMOut);

    <span class="comment">//</span>
    <span class="comment">// If the counter is in up/down count mode, divide the width by two.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#af96aa7f8e14f7d260d7cb610e78162c7">PWM_O_X_CTL</a>) &amp; <a class="code" href="hw__pwm_8h.html#ac2d9c2084af9f98e09e0610583daf5f4">PWM_X_CTL_MODE</a>)
    {
        ui32Width /= 2;
    }

    <span class="comment">//</span>
    <span class="comment">// Get the period.</span>
    <span class="comment">//</span>
    ui32Reg = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a96f1f6c95d33767b2b03da6cc1bf763b">PWM_O_X_LOAD</a>);

    <span class="comment">//</span>
    <span class="comment">// Make sure the width is not too large.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(ui32Width &lt; ui32Reg);

    <span class="comment">//</span>
    <span class="comment">// Compute the compare value.</span>
    <span class="comment">//</span>
    ui32Reg = ui32Reg - ui32Width;

    <span class="comment">//</span>
    <span class="comment">// Write to the appropriate registers.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__pwm__api.html#ga7904efa054c5e221ee9aa2e438f37100">PWM_IS_OUTPUT_ODD</a>(ui32PWMOut))
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a3b74b07279be2652f559a58b0be56467">PWM_O_X_CMPB</a>) = ui32Reg;
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32GenBase + <a class="code" href="hw__pwm_8h.html#a29a199ff01230c7cef834f2a7993c9a6">PWM_O_X_CMPA</a>) = ui32Reg;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="gadd7281936c715b7286746bbae6c24a6a"></a><!-- doxytag: member="pwm.c::PWMSyncTimeBase" ref="gadd7281936c715b7286746bbae6c24a6a" args="(uint32_t ui32Base, uint32_t ui32GenBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#gadd7281936c715b7286746bbae6c24a6a">PWMSyncTimeBase</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronizes the counters in one or multiple PWM generator blocks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenBits</td><td>are the PWM generator blocks to be synchronized. This parameter must be the logical OR of any of <b>PWM_GEN_0_BIT</b>, <b>PWM_GEN_1_BIT</b>, <b>PWM_GEN_2_BIT</b>, or <b>PWM_GEN_3_BIT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>For the selected PWM module, this function synchronizes the time base of the generator blocks by causing the specified generator counters to be reset to zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00688">688</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00139">PWM_GEN_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00140">PWM_GEN_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00141">PWM_GEN_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00142">PWM_GEN_3_BIT</a>, and <a class="el" href="hw__pwm_8h_source.html#l00049">PWM_O_SYNC</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32GenBits &amp; ~(<a class="code" href="pwm_8h.html#afe5ac10324a97c6ee62aa97644794797">PWM_GEN_0_BIT</a> | <a class="code" href="pwm_8h.html#a45b1af1f38880af1819c59ce9f866e72">PWM_GEN_1_BIT</a> | <a class="code" href="pwm_8h.html#abe8228eaeaa954637344598e18b716d1">PWM_GEN_2_BIT</a> |
                             <a class="code" href="pwm_8h.html#a70b3b6e55ffc99d2ca18bb4ef81d6657">PWM_GEN_3_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Synchronize the counters in the specified generators by writing to the</span>
    <span class="comment">// module&#39;s synchronization register.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#ade1351b0ef6a44dfe75cbc35560d362e">PWM_O_SYNC</a>) = ui32GenBits;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga32a04801267751f323f528cd3d5f2da5"></a><!-- doxytag: member="pwm.c::PWMSyncUpdate" ref="ga32a04801267751f323f528cd3d5f2da5" args="(uint32_t ui32Base, uint32_t ui32GenBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__pwm__api.html#ga32a04801267751f323f528cd3d5f2da5">PWMSyncUpdate</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GenBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronizes all pending updates.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the base address of the PWM module. </td></tr>
    <tr><td class="paramname">ui32GenBits</td><td>are the PWM generator blocks to be updated. This parameter must be the logical OR of any of <b>PWM_GEN_0_BIT</b>, <b>PWM_GEN_1_BIT</b>, <b>PWM_GEN_2_BIT</b>, or <b>PWM_GEN_3_BIT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>For the selected PWM generators, this function causes all queued updates to the period or pulse width to be applied the next time the corresponding counter becomes zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="pwm_8c_source.html#l00656">656</a> of file <a class="el" href="pwm_8c_source.html">pwm.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="hw__memmap_8h_source.html#l00077">PWM0_BASE</a>, <a class="el" href="hw__memmap_8h_source.html#l00078">PWM1_BASE</a>, <a class="el" href="pwm_8h_source.html#l00139">PWM_GEN_0_BIT</a>, <a class="el" href="pwm_8h_source.html#l00140">PWM_GEN_1_BIT</a>, <a class="el" href="pwm_8h_source.html#l00141">PWM_GEN_2_BIT</a>, <a class="el" href="pwm_8h_source.html#l00142">PWM_GEN_3_BIT</a>, and <a class="el" href="hw__pwm_8h_source.html#l00048">PWM_O_CTL</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Base == <a class="code" href="hw__memmap_8h.html#afd4cf3319d145ce948188816693d06d6">PWM0_BASE</a>) || (ui32Base == <a class="code" href="hw__memmap_8h.html#a8b7b369c2f714ba8ed9f34f1af48118b">PWM1_BASE</a>));
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(!(ui32GenBits &amp; ~(<a class="code" href="pwm_8h.html#afe5ac10324a97c6ee62aa97644794797">PWM_GEN_0_BIT</a> | <a class="code" href="pwm_8h.html#a45b1af1f38880af1819c59ce9f866e72">PWM_GEN_1_BIT</a> | <a class="code" href="pwm_8h.html#abe8228eaeaa954637344598e18b716d1">PWM_GEN_2_BIT</a> |
                             <a class="code" href="pwm_8h.html#a70b3b6e55ffc99d2ca18bb4ef81d6657">PWM_GEN_3_BIT</a>)));

    <span class="comment">//</span>
    <span class="comment">// Synchronize pending PWM register changes.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__pwm_8h.html#aa60b14599b5d419fea968d932c4fb6c3">PWM_O_CTL</a>) = ui32GenBits;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jan 27 2015 21:45:35 for EE 445M by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
