<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EE445M Real Time Operating Systems: Spi_flash_api</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">EE445M Real Time Operating Systems
   
   </div>
   <div id="projectbrief">Taken at the University of Texas Spring 2015</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__spi__flash__api.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spi_flash_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The state structure used when performing non-blocking SPI flash operations.  <a href="structt_s_p_i_flash_state.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gacf9ec38b37caa1223e957bba6058f626">CMD_WRSR</a>&#160;&#160;&#160;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>&#160;&#160;&#160;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga9c953a6c538020e644127ee080608021">CMD_READ</a>&#160;&#160;&#160;0x03</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaa98eb90657f02a0b7a4634174081799e">CMD_WRDI</a>&#160;&#160;&#160;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaf36d3b85d64c03760c6b76e916b443c1">CMD_RDSR</a>&#160;&#160;&#160;0x05</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga233ab2b77759d1d35814743f08c96347">CMD_WREN</a>&#160;&#160;&#160;0x06</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga95f7567ee4d9880eb6bcdacc88e0bdf9">CMD_FREAD</a>&#160;&#160;&#160;0x0b</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gab108a0bca1eff44cfc82862a6931b04f">CMD_SE</a>&#160;&#160;&#160;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gac7464fa85e0f285f4f293e4a5109b88a">CMD_DREAD</a>&#160;&#160;&#160;0x3b</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga4c5cce6b9a2f31616e9421737feb2f51">CMD_BE32</a>&#160;&#160;&#160;0x52</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaccf40d95b8aa697f4023b4ff334b61fa">CMD_QREAD</a>&#160;&#160;&#160;0x6b</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga7dcce537746ff1c0c717f6ac1f4af57b">CMD_RDID</a>&#160;&#160;&#160;0x9f</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga90f680398020583fafb3d1a9c03a2aeb">CMD_CE</a>&#160;&#160;&#160;0xc7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga2e6d2d790472ab4751450307d668fc6a">CMD_BE64</a>&#160;&#160;&#160;0xd8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaafff27c7165f059a969fe60fee51f683">STATE_IDLE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga24066dd67ecabc27f87c908010002988">STATE_ADDR1</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga37df3bc5709b8a9c3658aa65175e04d8">STATE_ADDR2</a>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga3b7208a6ce8258ad8bf6160d2ea35b2f">STATE_ADDR3</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaa2044cfac78a38212abe959061b73b93">STATE_READ_DUMMY</a>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga8a38e584b3df3a826f3e3604b59f1341">STATE_READ_DATA_SETUP</a>&#160;&#160;&#160;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaad5e20feb263b09e1be1f48394fdb50a">STATE_READ_DATA</a>&#160;&#160;&#160;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga91b29ddde291ec8eb0a75b7d1aa119f9">STATE_READ_DATA_DMA</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>&#160;&#160;&#160;9</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga75f5fdfe876583fac9954464e1bdacae">STATE_WRITE_DATA_SETUP</a>&#160;&#160;&#160;10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga76d26adac52cf8bd900415b001591008">STATE_WRITE_DATA</a>&#160;&#160;&#160;11</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga2a54f197080ab88952cb98579bf86d9e">STATE_WRITE_DATA_DMA</a>&#160;&#160;&#160;12</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>&#160;&#160;&#160;13</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga39a63f47dbd0d32d90990b2010684c13">SPIFlashInit</a> (uint32_t ui32Base, uint32_t ui32Clock, uint32_t ui32BitRate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga901b800fe1f8a373dcc1e269f4f40e04">SPIFlashWriteStatus</a> (uint32_t ui32Base, uint8_t ui8Status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga1bd70e866ded923d10aee1a43bc2b349">SPIFlashPageProgram</a> (uint32_t ui32Base, uint32_t ui32Addr, const uint8_t *pui8Data, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gab47e95a2c22ec3d0eafe80e8fad1e84f">SPIFlashPageProgramNonBlocking</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState, uint32_t ui32Base, uint32_t ui32Addr, const uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gad3dbb731a043f828f04867ff9146b07a">SPIFlashRead</a> (uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaf8c7a404794d8d63406154471c73540f">SPIFlashReadNonBlocking</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga86346f2b25c46fb16acdb7a0315f68c9">SPIFlashWriteDisable</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gadd97a4e0bcaa224283744a64c10a701c">SPIFlashWriteEnable</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga550aa252bfb93bfe45061f4aa73683b9">SPIFlashFastRead</a> (uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaaf27b3eebe2782b3986e0a4603ce9c5b">SPIFlashFastReadNonBlocking</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga058368211f1723e85295eb32b637360e">SPIFlashSectorErase</a> (uint32_t ui32Base, uint32_t ui32Addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga5d1b036b4baa2af303faaffb33bd2657">SPIFlashDualRead</a> (uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga3d18eb28e1f73b8dc45b564dbb422a67">SPIFlashDualReadNonBlocking</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gafa67db81dbf7cbe97458c24dd3945bfb">SPIFlashBlockErase32</a> (uint32_t ui32Base, uint32_t ui32Addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gae88d59957feec85adc1801777157b578">SPIFlashQuadRead</a> (uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gaa4ef70354c42d9ed4a78583e46c16ccd">SPIFlashQuadReadNonBlocking</a> (<a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#ga8d594d8bdd9e5f553ed8f626a118ed7c">SPIFlashReadID</a> (uint32_t ui32Base, uint8_t *pui8ManufacturerID, uint16_t *pui16DeviceID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gac9d54a0cd51fcd2f310ef08bff6c8541">SPIFlashChipErase</a> (uint32_t ui32Base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__flash__api.html#gad5901f8570e88ba3b56d7b9748180dbd">SPIFlashBlockErase64</a> (uint32_t ui32Base, uint32_t ui32Addr)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga4c5cce6b9a2f31616e9421737feb2f51"></a><!-- doxytag: member="spi_flash.c::CMD_BE32" ref="ga4c5cce6b9a2f31616e9421737feb2f51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga4c5cce6b9a2f31616e9421737feb2f51">CMD_BE32</a>&#160;&#160;&#160;0x52</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00060">60</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l02120">SPIFlashBlockErase32()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e6d2d790472ab4751450307d668fc6a"></a><!-- doxytag: member="spi_flash.c::CMD_BE64" ref="ga2e6d2d790472ab4751450307d668fc6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga2e6d2d790472ab4751450307d668fc6a">CMD_BE64</a>&#160;&#160;&#160;0xd8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00064">64</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l02458">SPIFlashBlockErase64()</a>.</p>

</div>
</div>
<a class="anchor" id="ga90f680398020583fafb3d1a9c03a2aeb"></a><!-- doxytag: member="spi_flash.c::CMD_CE" ref="ga90f680398020583fafb3d1a9c03a2aeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga90f680398020583fafb3d1a9c03a2aeb">CMD_CE</a>&#160;&#160;&#160;0xc7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00063">63</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l02427">SPIFlashChipErase()</a>.</p>

</div>
</div>
<a class="anchor" id="gac7464fa85e0f285f4f293e4a5109b88a"></a><!-- doxytag: member="spi_flash.c::CMD_DREAD" ref="gac7464fa85e0f285f4f293e4a5109b88a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gac7464fa85e0f285f4f293e4a5109b88a">CMD_DREAD</a>&#160;&#160;&#160;0x3b</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00059">59</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01921">SPIFlashDualRead()</a>, <a class="el" href="spi__flash_8c_source.html#l02065">SPIFlashDualReadNonBlocking()</a>, and <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga95f7567ee4d9880eb6bcdacc88e0bdf9"></a><!-- doxytag: member="spi_flash.c::CMD_FREAD" ref="ga95f7567ee4d9880eb6bcdacc88e0bdf9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga95f7567ee4d9880eb6bcdacc88e0bdf9">CMD_FREAD</a>&#160;&#160;&#160;0x0b</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00057">57</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01681">SPIFlashFastRead()</a>, and <a class="el" href="spi__flash_8c_source.html#l01827">SPIFlashFastReadNonBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2543fca56aeb170a41cc9f4d9b24c4cf"></a><!-- doxytag: member="spi_flash.c::CMD_PP" ref="ga2543fca56aeb170a41cc9f4d9b24c4cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00052">52</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>, <a class="el" href="spi__flash_8c_source.html#l01248">SPIFlashPageProgram()</a>, and <a class="el" href="spi__flash_8c_source.html#l01327">SPIFlashPageProgramNonBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="gaccf40d95b8aa697f4023b4ff334b61fa"></a><!-- doxytag: member="spi_flash.c::CMD_QREAD" ref="gaccf40d95b8aa697f4023b4ff334b61fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaccf40d95b8aa697f4023b4ff334b61fa">CMD_QREAD</a>&#160;&#160;&#160;0x6b</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00061">61</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>, <a class="el" href="spi__flash_8c_source.html#l02159">SPIFlashQuadRead()</a>, and <a class="el" href="spi__flash_8c_source.html#l02303">SPIFlashQuadReadNonBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7dcce537746ff1c0c717f6ac1f4af57b"></a><!-- doxytag: member="spi_flash.c::CMD_RDID" ref="ga7dcce537746ff1c0c717f6ac1f4af57b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga7dcce537746ff1c0c717f6ac1f4af57b">CMD_RDID</a>&#160;&#160;&#160;0x9f</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00062">62</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l02362">SPIFlashReadID()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf36d3b85d64c03760c6b76e916b443c1"></a><!-- doxytag: member="spi_flash.c::CMD_RDSR" ref="gaf36d3b85d64c03760c6b76e916b443c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaf36d3b85d64c03760c6b76e916b443c1">CMD_RDSR</a>&#160;&#160;&#160;0x05</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00055">55</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01587">SPIFlashReadStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c953a6c538020e644127ee080608021"></a><!-- doxytag: member="spi_flash.c::CMD_READ" ref="ga9c953a6c538020e644127ee080608021" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga9c953a6c538020e644127ee080608021">CMD_READ</a>&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00053">53</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>, <a class="el" href="spi__flash_8c_source.html#l01372">SPIFlashRead()</a>, and <a class="el" href="spi__flash_8c_source.html#l01510">SPIFlashReadNonBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="gab108a0bca1eff44cfc82862a6931b04f"></a><!-- doxytag: member="spi_flash.c::CMD_SE" ref="gab108a0bca1eff44cfc82862a6931b04f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gab108a0bca1eff44cfc82862a6931b04f">CMD_SE</a>&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00058">58</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01882">SPIFlashSectorErase()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa98eb90657f02a0b7a4634174081799e"></a><!-- doxytag: member="spi_flash.c::CMD_WRDI" ref="gaa98eb90657f02a0b7a4634174081799e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaa98eb90657f02a0b7a4634174081799e">CMD_WRDI</a>&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00054">54</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01560">SPIFlashWriteDisable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga233ab2b77759d1d35814743f08c96347"></a><!-- doxytag: member="spi_flash.c::CMD_WREN" ref="ga233ab2b77759d1d35814743f08c96347" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga233ab2b77759d1d35814743f08c96347">CMD_WREN</a>&#160;&#160;&#160;0x06</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00056">56</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01647">SPIFlashWriteEnable()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf9ec38b37caa1223e957bba6058f626"></a><!-- doxytag: member="spi_flash.c::CMD_WRSR" ref="gacf9ec38b37caa1223e957bba6058f626" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gacf9ec38b37caa1223e957bba6058f626">CMD_WRSR</a>&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00051">51</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l01212">SPIFlashWriteStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24066dd67ecabc27f87c908010002988"></a><!-- doxytag: member="spi_flash.c::STATE_ADDR1" ref="ga24066dd67ecabc27f87c908010002988" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga24066dd67ecabc27f87c908010002988">STATE_ADDR1</a>&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00073">73</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga37df3bc5709b8a9c3658aa65175e04d8"></a><!-- doxytag: member="spi_flash.c::STATE_ADDR2" ref="ga37df3bc5709b8a9c3658aa65175e04d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga37df3bc5709b8a9c3658aa65175e04d8">STATE_ADDR2</a>&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00074">74</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b7208a6ce8258ad8bf6160d2ea35b2f"></a><!-- doxytag: member="spi_flash.c::STATE_ADDR3" ref="ga3b7208a6ce8258ad8bf6160d2ea35b2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga3b7208a6ce8258ad8bf6160d2ea35b2f">STATE_ADDR3</a>&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00075">75</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga88c4e00f812e9b6becece01b8f60d678"></a><!-- doxytag: member="spi_flash.c::STATE_CMD" ref="ga88c4e00f812e9b6becece01b8f60d678" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00072">72</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l02065">SPIFlashDualReadNonBlocking()</a>, <a class="el" href="spi__flash_8c_source.html#l01827">SPIFlashFastReadNonBlocking()</a>, <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>, <a class="el" href="spi__flash_8c_source.html#l01327">SPIFlashPageProgramNonBlocking()</a>, <a class="el" href="spi__flash_8c_source.html#l02303">SPIFlashQuadReadNonBlocking()</a>, and <a class="el" href="spi__flash_8c_source.html#l01510">SPIFlashReadNonBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="gaafff27c7165f059a969fe60fee51f683"></a><!-- doxytag: member="spi_flash.c::STATE_IDLE" ref="gaafff27c7165f059a969fe60fee51f683" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaafff27c7165f059a969fe60fee51f683">STATE_IDLE</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00071">71</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad5e20feb263b09e1be1f48394fdb50a"></a><!-- doxytag: member="spi_flash.c::STATE_READ_DATA" ref="gaad5e20feb263b09e1be1f48394fdb50a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaad5e20feb263b09e1be1f48394fdb50a">STATE_READ_DATA</a>&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00078">78</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga91b29ddde291ec8eb0a75b7d1aa119f9"></a><!-- doxytag: member="spi_flash.c::STATE_READ_DATA_DMA" ref="ga91b29ddde291ec8eb0a75b7d1aa119f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga91b29ddde291ec8eb0a75b7d1aa119f9">STATE_READ_DATA_DMA</a>&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00079">79</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a0a8dfd33eacde71dfa36beccd55673"></a><!-- doxytag: member="spi_flash.c::STATE_READ_DATA_END" ref="ga0a0a8dfd33eacde71dfa36beccd55673" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00080">80</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a38e584b3df3a826f3e3604b59f1341"></a><!-- doxytag: member="spi_flash.c::STATE_READ_DATA_SETUP" ref="ga8a38e584b3df3a826f3e3604b59f1341" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga8a38e584b3df3a826f3e3604b59f1341">STATE_READ_DATA_SETUP</a>&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00077">77</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2044cfac78a38212abe959061b73b93"></a><!-- doxytag: member="spi_flash.c::STATE_READ_DUMMY" ref="gaa2044cfac78a38212abe959061b73b93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#gaa2044cfac78a38212abe959061b73b93">STATE_READ_DUMMY</a>&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00076">76</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga76d26adac52cf8bd900415b001591008"></a><!-- doxytag: member="spi_flash.c::STATE_WRITE_DATA" ref="ga76d26adac52cf8bd900415b001591008" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga76d26adac52cf8bd900415b001591008">STATE_WRITE_DATA</a>&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00082">82</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a54f197080ab88952cb98579bf86d9e"></a><!-- doxytag: member="spi_flash.c::STATE_WRITE_DATA_DMA" ref="ga2a54f197080ab88952cb98579bf86d9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga2a54f197080ab88952cb98579bf86d9e">STATE_WRITE_DATA_DMA</a>&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00083">83</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b1d1c61ab08460db62fe8441f7882ee"></a><!-- doxytag: member="spi_flash.c::STATE_WRITE_DATA_END" ref="ga6b1d1c61ab08460db62fe8441f7882ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00084">84</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga75f5fdfe876583fac9954464e1bdacae"></a><!-- doxytag: member="spi_flash.c::STATE_WRITE_DATA_SETUP" ref="ga75f5fdfe876583fac9954464e1bdacae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__spi__flash__api.html#ga75f5fdfe876583fac9954464e1bdacae">STATE_WRITE_DATA_SETUP</a>&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00081">81</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>Referenced by <a class="el" href="spi__flash_8c_source.html#l00103">SPIFlashIntHandler()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafa67db81dbf7cbe97458c24dd3945bfb"></a><!-- doxytag: member="spi_flash.c::SPIFlashBlockErase32" ref="gafa67db81dbf7cbe97458c24dd3945bfb" args="(uint32_t ui32Base, uint32_t ui32Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gafa67db81dbf7cbe97458c24dd3945bfb">SPIFlashBlockErase32</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases a 32 KB block of the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to erase.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a 32 KB block of the SPI flash. Each 32 KB block has a 32 KB alignment; the SPI flash will ignore the lower 15 bits of the address provided. The 32 KB block erase command is issued by this function; <a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus()</a> must be used to query the SPI flash to determine when the 32 KB block erase operation has completed. This uses the 0x52 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02120">2120</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00060">CMD_BE32</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the 32 KB block erase command command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga4c5cce6b9a2f31616e9421737feb2f51">CMD_BE32</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the 32 KB block to be erased, marking the last byte</span>
    <span class="comment">// of the address as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, ui32Addr &amp; 0xff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gad5901f8570e88ba3b56d7b9748180dbd"></a><!-- doxytag: member="spi_flash.c::SPIFlashBlockErase64" ref="gad5901f8570e88ba3b56d7b9748180dbd" args="(uint32_t ui32Base, uint32_t ui32Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gad5901f8570e88ba3b56d7b9748180dbd">SPIFlashBlockErase64</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases a 64 KB block of the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to erase.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a 64 KB block of the SPI flash. Each 64 KB block has a 64 KB alignment; the SPI flash will ignore the lower 16 bits of the address provided. The 64 KB block erase command is issued by this function; <a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus()</a> must be used to query the SPI flash to determine when the 64 KB block erase operation has completed. This uses the 0xd8 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02458">2458</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00064">CMD_BE64</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the 64 KB block erase command command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga2e6d2d790472ab4751450307d668fc6a">CMD_BE64</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the 64 KB block to be erased, marking the last byte</span>
    <span class="comment">// of the address as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, ui32Addr &amp; 0xff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gac9d54a0cd51fcd2f310ef08bff6c8541"></a><!-- doxytag: member="spi_flash.c::SPIFlashChipErase" ref="gac9d54a0cd51fcd2f310ef08bff6c8541" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gac9d54a0cd51fcd2f310ef08bff6c8541">SPIFlashChipErase</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases the entire SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This command erase the entire SPI flash. The chip erase command is issued by this function; <a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus()</a> must be used to query the SPI flash to determine when the chip erase operation has completed. This uses the 0xc7 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02427">2427</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00063">CMD_CE</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the chip erase command, marking this byte as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga90f680398020583fafb3d1a9c03a2aeb">CMD_CE</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5d1b036b4baa2af303faaffb33bd2657"></a><!-- doxytag: member="spi_flash.c::SPIFlashDualRead" ref="ga5d1b036b4baa2af303faaffb33bd2657" args="(uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga5d1b036b4baa2af303faaffb33bd2657">SPIFlashDualRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using Bi-SPI.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with Bi-SPI, using PIO mode. This function will not return until the read has completed. This uses the 0x3b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01921">1921</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00059">CMD_DREAD</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00109">SSI_ADV_MODE_BI_READ</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the dual read command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gac7464fa85e0f285f4f293e4a5109b88a">CMD_DREAD</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the first byte to read.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, ui32Addr &amp; 0xff);

    <span class="comment">//</span>
    <span class="comment">// Send a dummy byte.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into Bi-SPI read mode.  In this mode, dummy writes</span>
    <span class="comment">// are required in order to make the transfer occur; the SSI module will</span>
    <span class="comment">// ignore the data (the SPI flash will never see the dummy data since</span>
    <span class="comment">// Bi-SPI read mode is a uni-directional input mode).</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a0d3b574fbf3d0b60970d6f3357ac13bd">SSI_ADV_MODE_BI_READ</a>);

    <span class="comment">//</span>
    <span class="comment">// See if there is a single byte to be read.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Count == 1)
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a single dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a dummy write to prime the loop.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Loop while there is more than one byte left to be read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">while</span>(--ui32Count != 1)
        {
            <span class="comment">//</span>
            <span class="comment">// Perform a dummy write to keep the transmit FIFO from going</span>
            <span class="comment">// empty.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

            <span class="comment">//</span>
            <span class="comment">// Read the next data byte from the receive FIFO and place it into</span>
            <span class="comment">// the data buffer.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
            *pui8Data++ = ui32Addr &amp; 0xff;
        }

        <span class="comment">//</span>
        <span class="comment">// Perform the final dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Read the next data byte from the receive FIFO and place it into the</span>
        <span class="comment">// data buffer.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
        *pui8Data++ = ui32Addr &amp; 0xff;
    }

    <span class="comment">//</span>
    <span class="comment">// Read the final data byte from the receive FIFO and place it into the</span>
    <span class="comment">// data buffer.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
    *pui8Data++ = ui32Addr &amp; 0xff;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga3d18eb28e1f73b8dc45b564dbb422a67"></a><!-- doxytag: member="spi_flash.c::SPIFlashDualReadNonBlocking" ref="ga3d18eb28e1f73b8dc45b564dbb422a67" args="(tSPIFlashState *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga3d18eb28e1f73b8dc45b564dbb422a67">SPIFlashDualReadNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TxChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32RxChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using Bi-SPI in the background.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash state structure. </td></tr>
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read. </td></tr>
    <tr><td class="paramname">bUseDMA</td><td>is <b>true</b> if uDMA should be used and <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">ui32TxChannel</td><td>is the uDMA channel to be used for writing to the SSI module. </td></tr>
    <tr><td class="paramname">ui32RxChannel</td><td>is the uDMA channel to be used for reading from the SSI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with Bi-SPI, using either interrupts or uDMA to transfer the data. This function will return immediately and read the data in the background. In order for this to complete successfully, several conditions must be satisfied:</p>
<ul>
<li>Prior to calling this function:<ul>
<li>The SSI module must be enabled in SysCtl.</li>
<li>The SSI pins must be configured for use by the SSI module.</li>
<li>The SSI module interrupt must be enabled in NVIC.</li>
<li>The uDMA module must be enabled in SysCtl and the control table set (if using uDMA).</li>
<li>The uDMA channels must be assigned to the SSI module.</li>
</ul>
</li>
</ul>
<ul>
<li>After calling this function:<ul>
<li>The interrupt handler for the SSI module must call <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a>, passing the same pState structure pointer that was supplied to this function.</li>
<li>No other SPI flash operation can be called until this operation has completed.</li>
</ul>
</li>
</ul>
<p>Completion of the read operation is indicated when <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a> returns <b>SPI_FLASH_DONE</b>.</p>
<p>Like SPIFLashDualRead(), this uses the 0x3b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02065">2065</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00059">CMD_DREAD</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="hw__ssi_8h_source.html#l00200">SSI_ICR_DMARXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00148">SSI_IM_RTIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00147">SSI_IM_RXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00091">tSPIFlashState::ui32RxChannel</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Save the parameters of this read operation to the state structure.</span>
    <span class="comment">//</span>
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> = ui32Base;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> = <a class="code" href="group__spi__flash__api.html#gac7464fa85e0f285f4f293e4a5109b88a">CMD_DREAD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> = ui32Addr;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> = pui8Data;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = bUseDMA;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a> = ui32TxChannel &amp; 0x1f;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a> = ui32RxChannel &amp; 0x1f;

    <span class="comment">//</span>
    <span class="comment">// Enable the SSI transmit and receive interrupts.  This will start the</span>
    <span class="comment">// transfer.  If uDMA is being used, the uDMA-related interrupts will be</span>
    <span class="comment">// enabled at the appropriate time by the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a> | <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a> | <a class="code" href="hw__ssi_8h.html#a991109b454b7f2a294ce9dd2b523f378">SSI_IM_RXIM</a> | <a class="code" href="hw__ssi_8h.html#afd3ac990370ed4a0100b719fc1c7da7f">SSI_IM_RTIM</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga550aa252bfb93bfe45061f4aa73683b9"></a><!-- doxytag: member="spi_flash.c::SPIFlashFastRead" ref="ga550aa252bfb93bfe45061f4aa73683b9" args="(uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga550aa252bfb93bfe45061f4aa73683b9">SPIFlashFastRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using the fast read command.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with the fast read command, using PIO mode. The fast read command allows the SPI flash to be read at a higher SPI clock rate because of the addition of a dummy cycle during the command setup. This function will not return until the read has completed. This uses the 0x0b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01681">1681</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00057">CMD_FREAD</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the fast read command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga95f7567ee4d9880eb6bcdacc88e0bdf9">CMD_FREAD</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the first byte to read.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, ui32Addr &amp; 0xff);

    <span class="comment">//</span>
    <span class="comment">// Send a dummy byte.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into read/write mode.  In this mode, dummy writes are</span>
    <span class="comment">// required in order to make the transfer occur; the SPI flash will ignore</span>
    <span class="comment">// the data.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// See if there is a single byte to be read.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Count == 1)
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a single dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a dummy write to prime the loop.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Loop while there is more than one byte left to be read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">while</span>(--ui32Count != 1)
        {
            <span class="comment">//</span>
            <span class="comment">// Perform a dummy write to keep the transmit FIFO from going</span>
            <span class="comment">// empty.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

            <span class="comment">//</span>
            <span class="comment">// Read the next data byte from the receive FIFO and place it into</span>
            <span class="comment">// the data buffer.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
            *pui8Data++ = ui32Addr &amp; 0xff;
        }

        <span class="comment">//</span>
        <span class="comment">// Perform the final dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Read the next data byte from the receive FIFO and place it into the</span>
        <span class="comment">// data buffer.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
        *pui8Data++ = ui32Addr &amp; 0xff;
    }

    <span class="comment">//</span>
    <span class="comment">// Read the final data byte from the receive FIFO and place it into the</span>
    <span class="comment">// data buffer.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
    *pui8Data++ = ui32Addr &amp; 0xff;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaaf27b3eebe2782b3986e0a4603ce9c5b"></a><!-- doxytag: member="spi_flash.c::SPIFlashFastReadNonBlocking" ref="gaaf27b3eebe2782b3986e0a4603ce9c5b" args="(tSPIFlashState *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gaaf27b3eebe2782b3986e0a4603ce9c5b">SPIFlashFastReadNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TxChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32RxChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using the fast read command in the background.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash state structure. </td></tr>
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read. </td></tr>
    <tr><td class="paramname">bUseDMA</td><td>is <b>true</b> if uDMA should be used and <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">ui32TxChannel</td><td>is the uDMA channel to be used for writing to the SSI module. </td></tr>
    <tr><td class="paramname">ui32RxChannel</td><td>is the uDMA channel to be used for reading from the SSI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with the fast read command, using either interrupts or uDMA to transfer the data. The fast read command allows the SPI flash to be read at a higher SPI clock rate because of the addition of a dummy cycle during the command setup. This function will return immediately and read the data in the background. In order for this to complete successfully, several conditions must be satisfied:</p>
<ul>
<li>Prior to calling this function:<ul>
<li>The SSI module must be enabled in SysCtl.</li>
<li>The SSI pins must be configured for use by the SSI module.</li>
<li>The SSI module interrupt must be enabled in NVIC.</li>
<li>The uDMA module must be enabled in SysCtl and the control table set (if using uDMA).</li>
<li>The uDMA channels must be assigned to the SSI module.</li>
</ul>
</li>
</ul>
<ul>
<li>After calling this function:<ul>
<li>The interrupt handler for the SSI module must call <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a>, passing the same pState structure pointer that was supplied to this function.</li>
<li>No other SPI flash operation can be called until this operation has completed.</li>
</ul>
</li>
</ul>
<p>Completion of the read operation is indicated when <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a> returns <b>SPI_FLASH_DONE</b>.</p>
<p>Like <a class="el" href="group__spi__flash__api.html#ga550aa252bfb93bfe45061f4aa73683b9">SPIFlashFastRead()</a>, this uses the 0x0b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01827">1827</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00057">CMD_FREAD</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="hw__ssi_8h_source.html#l00200">SSI_ICR_DMARXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00148">SSI_IM_RTIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00147">SSI_IM_RXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00091">tSPIFlashState::ui32RxChannel</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Save the parameters of this read operation to the state structure.</span>
    <span class="comment">//</span>
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> = ui32Base;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> = <a class="code" href="group__spi__flash__api.html#ga95f7567ee4d9880eb6bcdacc88e0bdf9">CMD_FREAD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> = ui32Addr;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> = pui8Data;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = bUseDMA;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a> = ui32TxChannel &amp; 0x1f;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a> = ui32RxChannel &amp; 0x1f;

    <span class="comment">//</span>
    <span class="comment">// Enable the SSI transmit and receive interrupts.  This will start the</span>
    <span class="comment">// transfer.  If uDMA is being used, the uDMA-related interrupts will be</span>
    <span class="comment">// enabled at the appropriate time by the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a> | <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a> | <a class="code" href="hw__ssi_8h.html#a991109b454b7f2a294ce9dd2b523f378">SSI_IM_RXIM</a> | <a class="code" href="hw__ssi_8h.html#afd3ac990370ed4a0100b719fc1c7da7f">SSI_IM_RTIM</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga39a63f47dbd0d32d90990b2010684c13"></a><!-- doxytag: member="spi_flash.c::SPIFlashInit" ref="ga39a63f47dbd0d32d90990b2010684c13" args="(uint32_t ui32Base, uint32_t ui32Clock, uint32_t ui32BitRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga39a63f47dbd0d32d90990b2010684c13">SPIFlashInit</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32BitRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the SPI flash driver.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Clock</td><td>is the rate of the clock supplied to the SSI module. </td></tr>
    <tr><td class="paramname">ui32BitRate</td><td>is the SPI clock rate.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the SSI module for use by the SPI flash driver. The SSI module will be placed into the correct mode of operation to allow communication with the SPI flash. This function must be called prior to calling the remaining SPI flash driver APIs. It can be called at a later point to reconfigure the SSI module, such as to increase the SPI clock rate once it has been determined that it is safe to use a higher speed clock.</p>
<p>It is the responsibility of the caller to enable the SSI module and configure the pins that it will utilize.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01174">1174</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="rom__map_8h_source.html#l04398">MAP_SSIAdvFrameHoldEnable</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04272">MAP_SSIConfigSetExpClk</a>, <a class="el" href="rom__map_8h_source.html#l04279">MAP_SSIEnable</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, <a class="el" href="ssi_8h_source.html#l00073">SSI_FRF_MOTO_MODE_0</a>, and <a class="el" href="ssi_8h_source.html#l00080">SSI_MODE_MASTER</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Configure the SPI module.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8b3859fa774e2ad6f31aad1f8644c03d">MAP_SSIConfigSetExpClk</a>(ui32Base, ui32Clock, <a class="code" href="ssi_8h.html#a510fb7c5fbaa13005b174e144eb29260">SSI_FRF_MOTO_MODE_0</a>,
                           <a class="code" href="ssi_8h.html#a56dae2de51b66a6533a27e858bc76fe9">SSI_MODE_MASTER</a>, ui32BitRate, 8);

    <span class="comment">//</span>
    <span class="comment">// Enable the advanced mode of operation, defaulting to read/write mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Enable the frame hold feature.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a565341d92d0eaebda9f9d911602688ce">MAP_SSIAdvFrameHoldEnable</a>(ui32Base);

    <span class="comment">//</span>
    <span class="comment">// Enable the SPI module.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#ab92ada8d1854704fdf4c8b58ac687f2a">MAP_SSIEnable</a>(ui32Base);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0d56c3c7817caa138af5f48be143f0f5"></a><!-- doxytag: member="spi_flash.c::SPIFlashIntHandler" ref="ga0d56c3c7817caa138af5f48be143f0f5" args="(tSPIFlashState *pState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handles SSI module interrupts for the SPI flash driver.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash driver instance data.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles SSI module interrupts that are generated as a result of SPI flash driver operations. This must be called by the application in response to the SSI module interrupt when using the SPIFlashxxxNonBlocking APIs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <b>SPI_FLASH_IDLE</b> if there is no transfer in progress, <b>SPI_FLASH_WORKING</b> is the requested transfer is still in progress, or <b>SPI_FLASH_DONE</b> if the requested transfer has completed. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l00103">103</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00059">CMD_DREAD</a>, <a class="el" href="spi__flash_8c_source.html#l00052">CMD_PP</a>, <a class="el" href="spi__flash_8c_source.html#l00061">CMD_QREAD</a>, <a class="el" href="spi__flash_8c_source.html#l00053">CMD_READ</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="rom__map_8h_source.html#l04391">MAP_SSIAdvDataPutFrameEndNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04321">MAP_SSIDataPutNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04349">MAP_SSIDMADisable</a>, <a class="el" href="rom__map_8h_source.html#l04342">MAP_SSIDMAEnable</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="spi__flash_8h_source.html#l00109">SPI_FLASH_DONE</a>, <a class="el" href="spi__flash_8h_source.html#l00107">SPI_FLASH_IDLE</a>, <a class="el" href="spi__flash_8h_source.html#l00108">SPI_FLASH_WORKING</a>, <a class="el" href="ssi_8h_source.html#l00109">SSI_ADV_MODE_BI_READ</a>, <a class="el" href="ssi_8h_source.html#l00111">SSI_ADV_MODE_QUAD_READ</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>, <a class="el" href="ssi_8h_source.html#l00090">SSI_DMA_RX</a>, <a class="el" href="ssi_8h_source.html#l00089">SSI_DMA_TX</a>, <a class="el" href="hw__ssi_8h_source.html#l00200">SSI_ICR_DMARXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00145">SSI_IM_DMARXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00144">SSI_IM_DMATXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00182">SSI_MIS_DMARXMIS</a>, <a class="el" href="hw__ssi_8h_source.html#l00180">SSI_MIS_DMATXMIS</a>, <a class="el" href="hw__ssi_8h_source.html#l00050">SSI_O_DR</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="hw__ssi_8h_source.html#l00055">SSI_O_MIS</a>, <a class="el" href="spi__flash_8c_source.html#l00073">STATE_ADDR1</a>, <a class="el" href="spi__flash_8c_source.html#l00074">STATE_ADDR2</a>, <a class="el" href="spi__flash_8c_source.html#l00075">STATE_ADDR3</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8c_source.html#l00071">STATE_IDLE</a>, <a class="el" href="spi__flash_8c_source.html#l00078">STATE_READ_DATA</a>, <a class="el" href="spi__flash_8c_source.html#l00079">STATE_READ_DATA_DMA</a>, <a class="el" href="spi__flash_8c_source.html#l00080">STATE_READ_DATA_END</a>, <a class="el" href="spi__flash_8c_source.html#l00077">STATE_READ_DATA_SETUP</a>, <a class="el" href="spi__flash_8c_source.html#l00076">STATE_READ_DUMMY</a>, <a class="el" href="spi__flash_8c_source.html#l00082">STATE_WRITE_DATA</a>, <a class="el" href="spi__flash_8c_source.html#l00083">STATE_WRITE_DATA_DMA</a>, <a class="el" href="spi__flash_8c_source.html#l00084">STATE_WRITE_DATA_END</a>, <a class="el" href="spi__flash_8c_source.html#l00081">STATE_WRITE_DATA_SETUP</a>, <a class="el" href="hw__udma_8h_source.html#l00065">UDMA_ALTCLR</a>, <a class="el" href="udma_8h_source.html#l00238">UDMA_ARB_2</a>, <a class="el" href="udma_8h_source.html#l00239">UDMA_ARB_4</a>, <a class="el" href="udma_8h_source.html#l00224">UDMA_DST_INC_8</a>, <a class="el" href="udma_8h_source.html#l00227">UDMA_DST_INC_NONE</a>, <a class="el" href="hw__udma_8h_source.html#l00062">UDMA_ENACLR</a>, <a class="el" href="udma_8h_source.html#l00210">UDMA_MODE_BASIC</a>, <a class="el" href="hw__udma_8h_source.html#l00068">UDMA_PRIOCLR</a>, <a class="el" href="hw__udma_8h_source.html#l00067">UDMA_PRIOSET</a>, <a class="el" href="hw__udma_8h_source.html#l00060">UDMA_REQMASKCLR</a>, <a class="el" href="udma_8h_source.html#l00232">UDMA_SIZE_8</a>, <a class="el" href="udma_8h_source.html#l00228">UDMA_SRC_INC_8</a>, <a class="el" href="udma_8h_source.html#l00231">UDMA_SRC_INC_NONE</a>, <a class="el" href="hw__udma_8h_source.html#l00057">UDMA_USEBURSTSET</a>, <a class="el" href="udma_8c_source.html#l00603">uDMAChannelControlSet()</a>, <a class="el" href="udma_8c_source.html#l00152">uDMAChannelEnable()</a>, <a class="el" href="udma_8c_source.html#l00710">uDMAChannelTransferSet()</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00091">tSPIFlashState::ui32RxChannel</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Data, ui32Count;

    <span class="comment">//</span>
    <span class="comment">// Set the write count to four.  This is the maximum number of bytes that</span>
    <span class="comment">// will be written into the SSI transmit FIFO in the interrupt handler.</span>
    <span class="comment">// Writing more might be possible but makes the latency of handling future</span>
    <span class="comment">// SSI interrupt critical to preventing receive FIFO overruns.</span>
    <span class="comment">//</span>
    ui32Count = 4;

    <span class="comment">//</span>
    <span class="comment">// Get the set of asserted and unmasked SSI module interrupts.  Only some</span>
    <span class="comment">// of these are directly handled; the others are implicitly handled via the</span>
    <span class="comment">// operation of the state machine.</span>
    <span class="comment">//</span>
    ui32Data = <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#adb7055b4042d647c5810778257911c2f">SSI_O_MIS</a>);

    <span class="comment">//</span>
    <span class="comment">// See if the uDMA transmit complete interrupt has asserted.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Data &amp; <a class="code" href="hw__ssi_8h.html#aa2d7bfefb90fd58c349d8f52fe6e05f0">SSI_MIS_DMATXMIS</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// Determine the size of the uDMA transfer based on the number of bytes</span>
        <span class="comment">// left to write.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1024)
        {
            <span class="comment">//</span>
            <span class="comment">// There are more than 1024 bytes left to transfer, so the uDMA</span>
            <span class="comment">// transfer that just completed was for a full 1024 bytes.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> -= 1024;

            <span class="comment">//</span>
            <span class="comment">// If a page program is being performed, then the data buffer</span>
            <span class="comment">// pointer needs to be incremented as well.</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>)
            {
                <span class="comment">//</span>
                <span class="comment">// Increment the data buffer pointer.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> += 1024;

                <span class="comment">//</span>
                <span class="comment">// See if there is more than one byte left to transfer.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Configure the uDMA to transmit the next portion of the</span>
                    <span class="comment">// data buffer.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                           <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>,
                                           pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                           (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> +
                                                    <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                           (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1024) ?
                                           1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> - 1);

                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA transmit channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>);
                }
            }
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">//</span>
            <span class="comment">// There are 1024 or less bytes left to transfer, so the uDMA</span>
            <span class="comment">// transfer that just copmleted was for one less than the remaining</span>
            <span class="comment">// transfer count.  If a page program is being performed, then the</span>
            <span class="comment">// data buffer pointer needs to be incremented.</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>)
            {
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> += (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> - 1);
            }

            <span class="comment">//</span>
            <span class="comment">// Set the remaining transfer count to 1.  The final byte will be</span>
            <span class="comment">// transferred with PIO since the end of frame flag needs to be set</span>
            <span class="comment">// first.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = 1;
        }

        <span class="comment">//</span>
        <span class="comment">// Clear the uDMA transmit complete interrupt.</span>
        <span class="comment">//</span>
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a>;
    }

    <span class="comment">//</span>
    <span class="comment">// See if the uDMA receive complete interrupt has asserted.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Data &amp; <a class="code" href="hw__ssi_8h.html#a9e26a9350a70e9cd92f99d5a83f6670a">SSI_MIS_DMARXMIS</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// Determine the size of the uDMA transfer based on the number of bytes</span>
        <span class="comment">// left to read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &gt;= 1024)
        {
            <span class="comment">//</span>
            <span class="comment">// There are 1024 or more bytes left to transfer, so the uDMA</span>
            <span class="comment">// transfer that just completed was for a full 1024 bytes.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> -= 1024;
            <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> != 0)
            {
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> -= 1024;
            }

            <span class="comment">//</span>
            <span class="comment">// The data buffer pointer needs to be incremented as well.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> += 1024;

            <span class="comment">//</span>
            <span class="comment">// See if there is additional data to transfer.</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> != 0)
            {
                <span class="comment">//</span>
                <span class="comment">// Configure the transmit uDMA if there is more than one byte</span>
                <span class="comment">// left to write.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Configure the uDMA to transmit the next portion of the</span>
                    <span class="comment">// data buffer.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                           <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>, pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                           (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> +
                                                    <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                           (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1024) ?
                                           1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> - 1);

                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA transmit channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// Configure the uDMA to receive the next portion of the data</span>
                <span class="comment">// buffer.</span>
                <span class="comment">//</span>
                <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>, <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>,
                                       (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                       pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                       (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &gt;= 1024) ?
                                       1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a>);

                <span class="comment">//</span>
                <span class="comment">// Enable the uDMA receive channel.</span>
                <span class="comment">//</span>
                <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>);

                <span class="comment">//</span>
                <span class="comment">// If this is the final receive uDMA buffer and there is a</span>
                <span class="comment">// transmit uDMA buffer associated, enable the DMA transmit</span>
                <span class="comment">// interrupt.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>((pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &lt;= 1024) &amp;&amp;
                   (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1))
                {
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a061b9446afd7711c00e17fb127490c41">SSI_IM_DMATXIM</a>;
                }
            }
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">//</span>
            <span class="comment">// There are less than 1024 bytes left to transfer, so the uDMA</span>
            <span class="comment">// transfer that copmleted was for the remaining transfer count.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = 0;
        }

        <span class="comment">//</span>
        <span class="comment">// Clear the uDMA receive complete interrupt.</span>
        <span class="comment">//</span>
        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;
    }

    <span class="comment">//</span>
    <span class="comment">// Drain the receive FIFO is not using uDMA.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(!pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a>)
    {
        <span class="comment">//</span>
        <span class="comment">// Loop while there is more data in the receive FIFO and more data to</span>
        <span class="comment">// be read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">while</span>((pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> != 0) &amp;&amp;
              (<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, &amp;ui32Data) != 0))
        {
            <span class="comment">//</span>
            <span class="comment">// Save this byte into the data buffer.</span>
            <span class="comment">//</span>
            *(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>)++ = ui32Data &amp; 0xff;

            <span class="comment">//</span>
            <span class="comment">// Decrement the read count.</span>
            <span class="comment">//</span>
            pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a>--;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// The SPI flash state machine.  Loop forever; the state machine will</span>
    <span class="comment">// explicitly return to the caller when there is no further work that can</span>
    <span class="comment">// be done without stalling.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(1)
    {
        <span class="comment">//</span>
        <span class="comment">// Determine the current state.</span>
        <span class="comment">//</span>
        <span class="keywordflow">switch</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a>)
        {
            <span class="comment">//</span>
            <span class="comment">// The state machine is idle.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#gaafff27c7165f059a969fe60fee51f683">STATE_IDLE</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Return indicating that the state machine is idle.  This</span>
                <span class="comment">// should never happen since no further interrupts should occur</span>
                <span class="comment">// once the transfer has completed and the state machine goes</span>
                <span class="comment">// into the idle state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ac6eafdef3c4e5d673a746ea45dcafb33">SPI_FLASH_IDLE</a>);
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the command state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Set the SSI module into write-only mode.</span>
                <span class="comment">//</span>
                <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

                <span class="comment">//</span>
                <span class="comment">// Attempt to write the command byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(ui32Count == 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                             pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a>) == 0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// The command byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// The command byte has been written, so move to the first</span>
                    <span class="comment">// address byte state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga24066dd67ecabc27f87c908010002988">STATE_ADDR1</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the first address byte state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga24066dd67ecabc27f87c908010002988">STATE_ADDR1</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Attempt to write the first address byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(ui32Count == 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                             (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> &gt;&gt; 16) &amp;
                                             0xff) == 0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// The first address byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// The first address byte has been written, so move to the</span>
                    <span class="comment">// second address byte state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga37df3bc5709b8a9c3658aa65175e04d8">STATE_ADDR2</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the second address byte state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga37df3bc5709b8a9c3658aa65175e04d8">STATE_ADDR2</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Attempt to write the second address byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(ui32Count == 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                             (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> &gt;&gt; 8) &amp; 0xff) ==
                   0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// The second address byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// The second address byte has been written, so move to the</span>
                    <span class="comment">// third address byte state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga3b7208a6ce8258ad8bf6160d2ea35b2f">STATE_ADDR3</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the third address byte state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga3b7208a6ce8258ad8bf6160d2ea35b2f">STATE_ADDR3</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Attempt to write the third address byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(ui32Count == 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                             pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> &amp; 0xff) == 0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// The third address byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// The third address byte has been written, so determine</span>
                    <span class="comment">// the next state based on the command byte.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// A page program is being performed, so move to the</span>
                        <span class="comment">// write data setup state.</span>
                        <span class="comment">//</span>
                        pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga75f5fdfe876583fac9954464e1bdacae">STATE_WRITE_DATA_SETUP</a>;
                    }
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#ga9c953a6c538020e644127ee080608021">CMD_READ</a>)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// A read is being performed, so move to the read data</span>
                        <span class="comment">// setup state.</span>
                        <span class="comment">//</span>
                        pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga8a38e584b3df3a826f3e3604b59f1341">STATE_READ_DATA_SETUP</a>;
                    }
                    <span class="keywordflow">else</span>
                    {
                        <span class="comment">//</span>
                        <span class="comment">// The other forms of read (fast read, dual read, and</span>
                        <span class="comment">// quad read) all require a dummy byte.  Move to the</span>
                        <span class="comment">// dummy byte state.</span>
                        <span class="comment">//</span>
                        pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#gaa2044cfac78a38212abe959061b73b93">STATE_READ_DUMMY</a>;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the dummy byte state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#gaa2044cfac78a38212abe959061b73b93">STATE_READ_DUMMY</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Attempt to write the dummy byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(ui32Count == 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, 0) == 0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// THe dummy byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// The dummy byte has been written, so move to the read</span>
                    <span class="comment">// data setup state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga8a38e584b3df3a826f3e3604b59f1341">STATE_READ_DATA_SETUP</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the read data setup state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga8a38e584b3df3a826f3e3604b59f1341">STATE_READ_DATA_SETUP</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Set the SSI module into the appropriate mode based on the</span>
                <span class="comment">// command byte.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#gac7464fa85e0f285f4f293e4a5109b88a">CMD_DREAD</a>)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Bi-SPI read mode is used for the dual read command.</span>
                    <span class="comment">//</span>
                    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#a0d3b574fbf3d0b60970d6f3357ac13bd">SSI_ADV_MODE_BI_READ</a>);
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> == <a class="code" href="group__spi__flash__api.html#gaccf40d95b8aa697f4023b4ff334b61fa">CMD_QREAD</a>)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Quad-SPI read mode is used for the quad read command.</span>
                    <span class="comment">//</span>
                    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                      <a class="code" href="ssi_8h.html#a4dd541d5976ffab841e75cbaa5515a48">SSI_ADV_MODE_QUAD_READ</a>);
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// Advanced read/write mode is used for the read and fast</span>
                    <span class="comment">// read commands.</span>
                    <span class="comment">//</span>
                    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                      <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// See if a single byte is being transferred.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> == 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Disable the use of uDMA.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = <span class="keyword">false</span>;

                    <span class="comment">//</span>
                    <span class="comment">// Move to the read data end state to transfer the single</span>
                    <span class="comment">// byte.  This uses PIO even if uDMA has been requested.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// See if uDMA has been requested for this transfer.</span>
                <span class="comment">//</span>
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> || (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &lt; 4))
                {
                    <span class="comment">//</span>
                    <span class="comment">// Disable the use of uDMA.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = <span class="keyword">false</span>;

                    <span class="comment">//</span>
                    <span class="comment">// Move to the read data state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#gaad5e20feb263b09e1be1f48394fdb50a">STATE_READ_DATA</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// This transfer should use uDMA.</span>
                <span class="comment">//</span>
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// If the transfer is larger than 1024 bytes, enable the</span>
                    <span class="comment">// uDMA receive complete interrupt which will be used to</span>
                    <span class="comment">// move to the next block of the transfer.  Otherwise,</span>
                    <span class="comment">// enable the uDMA transmit complete interrupt which will</span>
                    <span class="comment">// be used to complete the transaction.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &gt; 1024)
                    {
                        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#ab5b00bc0dac2957c1e749feda9745280">SSI_IM_DMARXIM</a>;
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a061b9446afd7711c00e17fb127490c41">SSI_IM_DMATXIM</a>;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Disable the uDMA channels.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#ad6083ee9273019db8454bc298c3673e0">UDMA_ENACLR</a>) = ((1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>) |
                                          (1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>));

                    <span class="comment">//</span>
                    <span class="comment">// Configure the attributes for the transmit uDMA channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a93b7ff36ae2aa59087166fc2445a5f86">UDMA_USEBURSTSET</a>) = ((1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>) |
                                               (1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>));
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a297a23ad50e4111b1fbd0690c4c4a1c2">UDMA_ALTCLR</a>) = ((1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>) |
                                          (1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>));
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a4551274bc3f8c607d10e7407030a043d">UDMA_PRIOCLR</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a616a171071e25adf3b2ffb37b3c4e31b">UDMA_PRIOSET</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a9bf39ed430bce60aff19ce8115120751">UDMA_REQMASKCLR</a>) = ((1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>) |
                                              (1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>));

                    <span class="comment">//</span>
                    <span class="comment">// Configure the control parameters of the uDMA channels.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                          <a class="code" href="udma_8h.html#ace9a62c226f2e73cc1a7c56d80efa361">UDMA_SRC_INC_NONE</a> |
                                          <a class="code" href="udma_8h.html#aff850520540f2dd5ef6c016ac9bc85f8">UDMA_DST_INC_NONE</a> |
                                          <a class="code" href="udma_8h.html#acfd5e57fa4a0c7e33d76c9f0f663c70e">UDMA_SIZE_8</a> | <a class="code" href="udma_8h.html#a06a426feec6bae050e1ceec32feb6524">UDMA_ARB_2</a>);
                    <a class="code" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>,
                                          <a class="code" href="udma_8h.html#ace9a62c226f2e73cc1a7c56d80efa361">UDMA_SRC_INC_NONE</a> |
                                          <a class="code" href="udma_8h.html#a8df004d5dabcc2302bc3170f228d6a8e">UDMA_DST_INC_8</a> |
                                          <a class="code" href="udma_8h.html#acfd5e57fa4a0c7e33d76c9f0f663c70e">UDMA_SIZE_8</a> | <a class="code" href="udma_8h.html#a54624c18043cb15f52b95faad3251f6d">UDMA_ARB_4</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Configure the uDMA receive channel to transfer the first</span>
                    <span class="comment">// portion of the data buffer.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>,
                                           <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>,
                                           (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> +
                                                    <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                           pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                           (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> &gt;= 1024) ?
                                           1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA receive channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Configure the uDMA channel to transfer the dummy bytes</span>
                    <span class="comment">// for the first portion of the data buffer.  The last</span>
                    <span class="comment">// dummy byte will not be included since it must be treated</span>
                    <span class="comment">// special.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                           <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>,
                                           pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                           (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> +
                                                    <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                           (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1024) ?
                                           1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> - 1);

                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA transmit channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Clear any previously pending uDMA completion interrupt.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Enable uDMA transmit and receive in the SSI module.</span>
                    <span class="comment">//</span>
                    <a class="code" href="rom__map_8h.html#a2afd24398ee80ff8864f68c470c0e9b5">MAP_SSIDMAEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                     <a class="code" href="ssi_8h.html#a90f31eb354206da6173911200ba7d2cb">SSI_DMA_TX</a> | <a class="code" href="ssi_8h.html#acad5d21da630367195b15fe80be03a64">SSI_DMA_RX</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Move to the uDMA data read state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga91b29ddde291ec8eb0a75b7d1aa119f9">STATE_READ_DATA_DMA</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the read data state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#gaad5e20feb263b09e1be1f48394fdb50a">STATE_READ_DATA</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Loop while there is more than one byte left to write.</span>
                <span class="comment">//</span>
                <span class="keywordflow">while</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> != 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Dummy bytes are written into the FIFO in order to</span>
                    <span class="comment">// trigger the read operation.  Attempt to write another</span>
                    <span class="comment">// dummy byte into the FIFO.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ui32Count == 0)
                    {
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }
                    <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, 0) == 0)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// The dummy byte could not be written, so return</span>
                        <span class="comment">// indicating that the transfer is still in progress.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of dummy bytes to write.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a>--;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Move to the read data end state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>;

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the uDMA read data state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga91b29ddde291ec8eb0a75b7d1aa119f9">STATE_READ_DATA_DMA</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// See if the write count is greater than one.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Return indicating that the transfer is still in</span>
                    <span class="comment">// progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// Disable uDMA transmit in the SSI module.</span>
                <span class="comment">//</span>
                <a class="code" href="rom__map_8h.html#a07161e7fa7b8499571fcc680d3bbd527">MAP_SSIDMADisable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#a90f31eb354206da6173911200ba7d2cb">SSI_DMA_TX</a>);

                <span class="comment">//</span>
                <span class="comment">// Enable the uDMA receive done and FIFO transmit interrupt.</span>
                <span class="comment">//</span>
                <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) =
                    <a class="code" href="hw__ssi_8h.html#ab5b00bc0dac2957c1e749feda9745280">SSI_IM_DMARXIM</a> | <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a>;

                <span class="comment">//</span>
                <span class="comment">// Move to the read data end state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>;

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the data read end state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga0a0a8dfd33eacde71dfa36beccd55673">STATE_READ_DATA_END</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// See if the final dummy byte still needs to be written.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> != 0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Attempt to write the final dummy byte into the FIFO and</span>
                    <span class="comment">// mark it as the end of the frame.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ui32Count == 0)
                    {
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }
                    <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#aed0a08c7007456819f7e6ddc22ddeaba">MAP_SSIAdvDataPutFrameEndNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                                            0) == 0)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// The dummy byte could not be written, so return</span>
                        <span class="comment">// indicating that the transfer is still in progress.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }

                    <span class="comment">//</span>
                    <span class="comment">// The write portion of the transfer has completed.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = 0;

                    <span class="comment">//</span>
                    <span class="comment">// Disable the transmit interrupt now that the write</span>
                    <span class="comment">// write portion of the transfer has completed.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) &amp;= ~(<a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// Return indicating that the transfer is still in progress if</span>
                <span class="comment">// there are still data bytes to be read.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> != 0)
                {
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// Disable uDMA receive in the SSI module.</span>
                <span class="comment">//</span>
                <a class="code" href="rom__map_8h.html#a07161e7fa7b8499571fcc680d3bbd527">MAP_SSIDMADisable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#acad5d21da630367195b15fe80be03a64">SSI_DMA_RX</a>);

                <span class="comment">//</span>
                <span class="comment">// The transfer is complete, so disable all interrupts.</span>
                <span class="comment">//</span>
                <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = 0;

                <span class="comment">//</span>
                <span class="comment">// Move to the idle state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#gaafff27c7165f059a969fe60fee51f683">STATE_IDLE</a>;

                <span class="comment">//</span>
                <span class="comment">// Return indicating that the transfer has completed.</span>
                <span class="comment">//</span>
                <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#aca3e474ded3319802c56c082e198903c">SPI_FLASH_DONE</a>);
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the write data setup state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga75f5fdfe876583fac9954464e1bdacae">STATE_WRITE_DATA_SETUP</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// See if a single data byte is being transferred.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> == 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Disable the use of uDMA.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = <span class="keyword">false</span>;

                    <span class="comment">//</span>
                    <span class="comment">// Move to the write data end state to transfer the single</span>
                    <span class="comment">// byte.  This uses PIO even if uDMA has been requested.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// See if uDMA has been requested for this transfer.</span>
                <span class="comment">//</span>
                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> || (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &lt; 4))
                {
                    <span class="comment">//</span>
                    <span class="comment">// Disable the use of uDMA.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = <span class="keyword">false</span>;

                    <span class="comment">//</span>
                    <span class="comment">// uDMA is not being used, so move to the write data state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga76d26adac52cf8bd900415b001591008">STATE_WRITE_DATA</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// This transfer should use uDMA.</span>
                <span class="comment">//</span>
                <span class="keywordflow">else</span>
                {
                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA transmit complete interrupt.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a061b9446afd7711c00e17fb127490c41">SSI_IM_DMATXIM</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Disable the transmit uDMA channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#ad6083ee9273019db8454bc298c3673e0">UDMA_ENACLR</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Configure the attributes for the transmit uDMA channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a93b7ff36ae2aa59087166fc2445a5f86">UDMA_USEBURSTSET</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a297a23ad50e4111b1fbd0690c4c4a1c2">UDMA_ALTCLR</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a4551274bc3f8c607d10e7407030a043d">UDMA_PRIOCLR</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(<a class="code" href="hw__udma_8h.html#a9bf39ed430bce60aff19ce8115120751">UDMA_REQMASKCLR</a>) = 1 &lt;&lt; pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Configure the control parameters of the uDMA channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f">uDMAChannelControlSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                          <a class="code" href="udma_8h.html#a3a2ecfdeedc93963d2c5b6dcf3598d80">UDMA_SRC_INC_8</a> |
                                          <a class="code" href="udma_8h.html#aff850520540f2dd5ef6c016ac9bc85f8">UDMA_DST_INC_NONE</a> |
                                          <a class="code" href="udma_8h.html#acfd5e57fa4a0c7e33d76c9f0f663c70e">UDMA_SIZE_8</a> | <a class="code" href="udma_8h.html#a54624c18043cb15f52b95faad3251f6d">UDMA_ARB_4</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Configure the uDMA channel to transfer the next portion</span>
                    <span class="comment">// of the data buffer.  The last byte in the buffer will</span>
                    <span class="comment">// not be included since it must be treated special.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3">uDMAChannelTransferSet</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>,
                                           <a class="code" href="udma_8h.html#a0d0916171d90267e53ad4c455f81ab85">UDMA_MODE_BASIC</a>,
                                           pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>,
                                           (<span class="keywordtype">void</span> *)(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> +
                                                    <a class="code" href="hw__ssi_8h.html#aeee45da597a7055c2b8468367cd8e920">SSI_O_DR</a>),
                                           (pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1024) ?
                                           1024 : pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> - 1);

                    <span class="comment">//</span>
                    <span class="comment">// Enable the uDMA transmit channel.</span>
                    <span class="comment">//</span>
                    <a class="code" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06">uDMAChannelEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a>);
                    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a>;

                    <span class="comment">//</span>
                    <span class="comment">// Enable uDMA in the SSI module.</span>
                    <span class="comment">//</span>
                    <a class="code" href="rom__map_8h.html#a2afd24398ee80ff8864f68c470c0e9b5">MAP_SSIDMAEnable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#a90f31eb354206da6173911200ba7d2cb">SSI_DMA_TX</a>);

                    <span class="comment">//</span>
                    <span class="comment">// Move to the uDMA data write state.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga2a54f197080ab88952cb98579bf86d9e">STATE_WRITE_DATA_DMA</a>;
                }

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the write data state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga76d26adac52cf8bd900415b001591008">STATE_WRITE_DATA</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Loop while there is more than one byte left to write.</span>
                <span class="comment">//</span>
                <span class="keywordflow">while</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> != 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Attempt to write the next data byte into the FIFO.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ui32Count == 0)
                    {
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }
                    <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#a8c46066183d1c49c10582b59490607a7">MAP_SSIDataPutNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                                 *(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>)) == 0)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// The next data byte could not be written, so return</span>
                        <span class="comment">// indicating that the transfer is still in progress.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Increment the buffer pointer and decrement the byte</span>
                    <span class="comment">// count.</span>
                    <span class="comment">//</span>
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>++;
                    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a>--;

                    <span class="comment">//</span>
                    <span class="comment">// Decrement the count of bytes that have been written.</span>
                    <span class="comment">//</span>
                    ui32Count--;
                }

                <span class="comment">//</span>
                <span class="comment">// Move to the write data end state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>;

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the uDMA write data state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga2a54f197080ab88952cb98579bf86d9e">STATE_WRITE_DATA_DMA</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// See if the write count is greater than one.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> &gt; 1)
                {
                    <span class="comment">//</span>
                    <span class="comment">// Return indicating that the transfer is still in</span>
                    <span class="comment">// progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// Disable uDMA in the SSI module.</span>
                <span class="comment">//</span>
                <a class="code" href="rom__map_8h.html#a07161e7fa7b8499571fcc680d3bbd527">MAP_SSIDMADisable</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>, <a class="code" href="ssi_8h.html#a90f31eb354206da6173911200ba7d2cb">SSI_DMA_TX</a>);

                <span class="comment">//</span>
                <span class="comment">// Disable the uDMA transmit complete interrupt and enable the</span>
                <span class="comment">// FIFO interrupt.</span>
                <span class="comment">//</span>
                <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a>;

                <span class="comment">//</span>
                <span class="comment">// Move to the write data end state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>;

                <span class="comment">//</span>
                <span class="comment">// Done with this state.</span>
                <span class="comment">//</span>
                <span class="keywordflow">break</span>;
            }

            <span class="comment">//</span>
            <span class="comment">// The state machine is in the write data end state.</span>
            <span class="comment">//</span>
            <span class="keywordflow">case</span> <a class="code" href="group__spi__flash__api.html#ga6b1d1c61ab08460db62fe8441f7882ee">STATE_WRITE_DATA_END</a>:
            {
                <span class="comment">//</span>
                <span class="comment">// Attempt to write the final data byte into the FIFO.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span>(<a class="code" href="rom__map_8h.html#aed0a08c7007456819f7e6ddc22ddeaba">MAP_SSIAdvDataPutFrameEndNonBlocking</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a>,
                                                      *(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a>)) ==
                   0)
                {
                    <span class="comment">//</span>
                    <span class="comment">// The final data byte could not be written, so return</span>
                    <span class="comment">// indicating that the transfer is still in progress.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#ae368a0a3d565b6e96aeb09c7ee4db481">SPI_FLASH_WORKING</a>);
                }

                <span class="comment">//</span>
                <span class="comment">// The transfer is complete, so disable all interrupts.</span>
                <span class="comment">//</span>
                <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = 0;

                <span class="comment">//</span>
                <span class="comment">// Move to the idle state.</span>
                <span class="comment">//</span>
                pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#gaafff27c7165f059a969fe60fee51f683">STATE_IDLE</a>;

                <span class="comment">//</span>
                <span class="comment">// Return indicating that the transfer has completed.</span>
                <span class="comment">//</span>
                <span class="keywordflow">return</span>(<a class="code" href="spi__flash_8h.html#aca3e474ded3319802c56c082e198903c">SPI_FLASH_DONE</a>);
            }
        }
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__spi__flash__api_ga0d56c3c7817caa138af5f48be143f0f5_cgraph.png" border="0" usemap="#group__spi__flash__api_ga0d56c3c7817caa138af5f48be143f0f5_cgraph" alt=""/></div>
<map name="group__spi__flash__api_ga0d56c3c7817caa138af5f48be143f0f5_cgraph" id="group__spi__flash__api_ga0d56c3c7817caa138af5f48be143f0f5_cgraph">
<area shape="rect" id="node3" href="group__udma__api.html#ga6f73ab006ff6a593eeeb947130bbdf6f" title="uDMAChannelControlSet" alt="" coords="193,5,361,35"/><area shape="rect" id="node5" href="group__udma__api.html#ga41e21189773539bbc5f302863cd5bf06" title="uDMAChannelEnable" alt="" coords="204,59,351,88"/><area shape="rect" id="node7" href="group__udma__api.html#ga938c21dc70cb6e11e6eb826de0fa21c3" title="uDMAChannelTransferSet" alt="" coords="191,112,364,141"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1bd70e866ded923d10aee1a43bc2b349"></a><!-- doxytag: member="spi_flash.c::SPIFlashPageProgram" ref="ga1bd70e866ded923d10aee1a43bc2b349" args="(uint32_t ui32Base, uint32_t ui32Addr, const uint8_t *pui8Data, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga1bd70e866ded923d10aee1a43bc2b349">SPIFlashPageProgram</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Programs the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to be programmed. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data to be programmed. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to be programmed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function programs data into the SPI flash, using PIO mode. This function will not return until the entire program command has been written into the SSI transmit FIFO. This uses the 0x02 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01248">1248</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00052">CMD_PP</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the page program command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the first byte to program.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, ui32Addr &amp; 0xff);

    <span class="comment">//</span>
    <span class="comment">// Loop while there is more than one data byte left to be sent.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(ui32Count-- != 1)
    {
        <span class="comment">//</span>
        <span class="comment">// Send the next data byte.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, *pui8Data++);
    }

    <span class="comment">//</span>
    <span class="comment">// Send the last data byte, marking it as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, *pui8Data);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gab47e95a2c22ec3d0eafe80e8fad1e84f"></a><!-- doxytag: member="spi_flash.c::SPIFlashPageProgramNonBlocking" ref="gab47e95a2c22ec3d0eafe80e8fad1e84f" args="(tSPIFlashState *pState, uint32_t ui32Base, uint32_t ui32Addr, const uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gab47e95a2c22ec3d0eafe80e8fad1e84f">SPIFlashPageProgramNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TxChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Programs the SPI flash in the background.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash state structure. </td></tr>
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to be programmed. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data to be programmed. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to be programmed. </td></tr>
    <tr><td class="paramname">bUseDMA</td><td>is <b>true</b> if uDMA should be used and <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">ui32TxChannel</td><td>is the uDMA channel to be used for writing to the SSI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function programs data into the SPI flash, using either interrupts or uDMA to transfer the data. This function will return immediately and send the data in the background. In order for this to complete successfully, several conditions must be satisfied:</p>
<ul>
<li>Prior to calling this function:<ul>
<li>The SSI module must be enabled in SysCtl.</li>
<li>The SSI pins must be configured for use by the SSI module.</li>
<li>The SSI module interrupt must be enabled in NVIC.</li>
<li>The uDMA module must be enabled in SysCtl and the control table set (if using uDMA).</li>
<li>The uDMA channels must be assigned to the SSI module.</li>
</ul>
</li>
</ul>
<ul>
<li>After calling this function:<ul>
<li>The interrupt handler for the SSI module must call <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a>, passing the same pState structure pointer that was supplied to this function.</li>
<li>No other SPI flash operation can be called until this operation has completed.</li>
</ul>
</li>
</ul>
<p>Completion of the programming operation is indicated when <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a> returns <b>SPI_FLASH_DONE</b>.</p>
<p>Like <a class="el" href="group__spi__flash__api.html#ga1bd70e866ded923d10aee1a43bc2b349">SPIFlashPageProgram()</a>, this uses the 0x02 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01327">1327</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00052">CMD_PP</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Save the parameters of this program operation to the state structure.</span>
    <span class="comment">//</span>
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> = ui32Base;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> = <a class="code" href="group__spi__flash__api.html#ga2543fca56aeb170a41cc9f4d9b24c4cf">CMD_PP</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> = ui32Addr;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> = (uint8_t *)pui8Data;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = 0;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = bUseDMA;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a> = ui32TxChannel &amp; 0x1f;

    <span class="comment">//</span>
    <span class="comment">// Enable the SSI transmit interrupt.  This will start the transfer.  If</span>
    <span class="comment">// uDMA is being used, the uDMA-related interrupt will be enabled at the</span>
    <span class="comment">// appropriate time by the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a>;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae88d59957feec85adc1801777157b578"></a><!-- doxytag: member="spi_flash.c::SPIFlashQuadRead" ref="gae88d59957feec85adc1801777157b578" args="(uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gae88d59957feec85adc1801777157b578">SPIFlashQuadRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using Quad-SPI.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with Quad-SPI, using PIO mode. This function will not return until the read has completed. This uses the 0x6b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02159">2159</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00061">CMD_QREAD</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00111">SSI_ADV_MODE_QUAD_READ</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the quad read command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gaccf40d95b8aa697f4023b4ff334b61fa">CMD_QREAD</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the first byte to read.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, ui32Addr &amp; 0xff);

    <span class="comment">//</span>
    <span class="comment">// Send a dummy byte.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into Quad-SPI read mode.  In this mode, dummy writes</span>
    <span class="comment">// are required in order to make the transfer occur; the SSI module will</span>
    <span class="comment">// ignore the data (the SPI flash will never see the dummy data since</span>
    <span class="comment">// Quad-SPI read mode is a uni-directional input mode).</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a4dd541d5976ffab841e75cbaa5515a48">SSI_ADV_MODE_QUAD_READ</a>);

    <span class="comment">//</span>
    <span class="comment">// See if there is a single byte to be read.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Count == 1)
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a single dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a dummy write to prime the loop.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Loop while there is more than one byte left to be read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">while</span>(--ui32Count != 1)
        {
            <span class="comment">//</span>
            <span class="comment">// Perform a dummy write to keep the transmit FIFO from going</span>
            <span class="comment">// empty.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

            <span class="comment">//</span>
            <span class="comment">// Read the next data byte from the receive FIFO and place it into</span>
            <span class="comment">// the data buffer.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
            *pui8Data++ = ui32Addr &amp; 0xff;
        }

        <span class="comment">//</span>
        <span class="comment">// Perform the final dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Read the next data byte from the receive FIFO and place it into the</span>
        <span class="comment">// data buffer.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
        *pui8Data++ = ui32Addr &amp; 0xff;
    }

    <span class="comment">//</span>
    <span class="comment">// Read the final data byte from the receive FIFO and place it into the</span>
    <span class="comment">// data buffer.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
    *pui8Data++ = ui32Addr &amp; 0xff;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa4ef70354c42d9ed4a78583e46c16ccd"></a><!-- doxytag: member="spi_flash.c::SPIFlashQuadReadNonBlocking" ref="gaa4ef70354c42d9ed4a78583e46c16ccd" args="(tSPIFlashState *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gaa4ef70354c42d9ed4a78583e46c16ccd">SPIFlashQuadReadNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TxChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32RxChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash using Quad-SPI in the background.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash state structure. </td></tr>
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read. </td></tr>
    <tr><td class="paramname">bUseDMA</td><td>is <b>true</b> if uDMA should be used and <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">ui32TxChannel</td><td>is the uDMA channel to be used for writing to the SSI module. </td></tr>
    <tr><td class="paramname">ui32RxChannel</td><td>is the uDMA channel to be used for reading from the SSI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash with Quad-SPI, using either interrupts or uDMA to transfer the data. This function will return immediately and read the data in the background. In order for this to complete successfully, several conditions must be satisfied:</p>
<ul>
<li>Prior to calling this function:<ul>
<li>The SSI module must be enabled in SysCtl.</li>
<li>The SSI pins must be configured for use by the SSI module.</li>
<li>The SSI module interrupt must be enabled in NVIC.</li>
<li>The uDMA module must be enabled in SysCtl and the control table set (if using uDMA).</li>
<li>The uDMA channels must be assigned to the SSI module.</li>
</ul>
</li>
</ul>
<ul>
<li>After calling this function:<ul>
<li>The interrupt handler for the SSI module must call <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a>, passing the same pState structure pointer that was supplied to this function.</li>
<li>No other SPI flash operation can be called until this operation has completed.</li>
</ul>
</li>
</ul>
<p>Completion of the read operation is indicated when <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a> returns <b>SPI_FLASH_DONE</b>.</p>
<p>Like <a class="el" href="group__spi__flash__api.html#gae88d59957feec85adc1801777157b578">SPIFlashQuadRead()</a>, this uses the 0x6b SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02303">2303</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00061">CMD_QREAD</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="hw__ssi_8h_source.html#l00200">SSI_ICR_DMARXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00148">SSI_IM_RTIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00147">SSI_IM_RXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00091">tSPIFlashState::ui32RxChannel</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Save the parameters of this read operation to the state structure.</span>
    <span class="comment">//</span>
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> = ui32Base;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> = <a class="code" href="group__spi__flash__api.html#gaccf40d95b8aa697f4023b4ff334b61fa">CMD_QREAD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> = ui32Addr;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> = pui8Data;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = bUseDMA;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a> = ui32TxChannel &amp; 0x1f;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a> = ui32RxChannel &amp; 0x1f;

    <span class="comment">//</span>
    <span class="comment">// Enable the SSI transmit and receive interrupts.  This will start the</span>
    <span class="comment">// transfer.  If uDMA is being used, the uDMA-related interrupts will be</span>
    <span class="comment">// enabled at the appropriate time by the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a> | <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a> | <a class="code" href="hw__ssi_8h.html#a991109b454b7f2a294ce9dd2b523f378">SSI_IM_RXIM</a> | <a class="code" href="hw__ssi_8h.html#afd3ac990370ed4a0100b719fc1c7da7f">SSI_IM_RTIM</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gad3dbb731a043f828f04867ff9146b07a"></a><!-- doxytag: member="spi_flash.c::SPIFlashRead" ref="gad3dbb731a043f828f04867ff9146b07a" args="(uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gad3dbb731a043f828f04867ff9146b07a">SPIFlashRead</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash, using PIO mode. This function will not return until the read has completed. This uses the 0x03 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01372">1372</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00053">CMD_READ</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the read command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga9c953a6c538020e644127ee080608021">CMD_READ</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the first byte to read.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, ui32Addr &amp; 0xff);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into read/write mode.  In this mode, dummy writes are</span>
    <span class="comment">// required in order to make the transfer occur; the SPI flash will ignore</span>
    <span class="comment">// the data.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// See if there is a single byte to be read.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(ui32Count == 1)
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a single dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// Perform a dummy write to prime the loop.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Loop while there is more than one byte left to be read.</span>
        <span class="comment">//</span>
        <span class="keywordflow">while</span>(--ui32Count != 1)
        {
            <span class="comment">//</span>
            <span class="comment">// Perform a dummy write to keep the transmit FIFO from going</span>
            <span class="comment">// empty.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);

            <span class="comment">//</span>
            <span class="comment">// Read the next data byte from the receive FIFO and place it into</span>
            <span class="comment">// the data buffer.</span>
            <span class="comment">//</span>
            <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
            *pui8Data++ = ui32Addr &amp; 0xff;
        }

        <span class="comment">//</span>
        <span class="comment">// Perform the final dummy write, marking it as the end of the frame.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

        <span class="comment">//</span>
        <span class="comment">// Read the next data byte from the receive FIFO and place it into the</span>
        <span class="comment">// data buffer.</span>
        <span class="comment">//</span>
        <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
        *pui8Data++ = ui32Addr &amp; 0xff;
    }

    <span class="comment">//</span>
    <span class="comment">// Read the final data byte from the receive FIFO and place it into the</span>
    <span class="comment">// data buffer.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Addr);
    *pui8Data++ = ui32Addr &amp; 0xff;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga8d594d8bdd9e5f553ed8f626a118ed7c"></a><!-- doxytag: member="spi_flash.c::SPIFlashReadID" ref="ga8d594d8bdd9e5f553ed8f626a118ed7c" args="(uint32_t ui32Base, uint8_t *pui8ManufacturerID, uint16_t *pui16DeviceID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga8d594d8bdd9e5f553ed8f626a118ed7c">SPIFlashReadID</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8ManufacturerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pui16DeviceID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the manufacturer and device IDs from the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">pui8ManufacturerID</td><td>is a pointer to the location into which to store the manufacturer ID. </td></tr>
    <tr><td class="paramname">pui16DeviceID</td><td>is a pointer to the location into which to store the device ID.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the manufacturer and device IDs from the SPI flash. These values can be used to identify the SPI flash that is attached, as well as determining if a SPI flash is attached (if the <b>SSIRx</b> pin is pulled up or down, either using the pad's weak pull up/down or using an external resistor, which will cause the returned IDs to be either all zeros or all ones if the SPI flash is not attached). This uses the 0x9f SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l02362">2362</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00062">CMD_RDID</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Data1, ui32Data2;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Data1) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the read ID command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga7dcce537746ff1c0c717f6ac1f4af57b">CMD_RDID</a>);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into read/write mode.  In this mode, dummy writes are</span>
    <span class="comment">// required in order to make the transfer occur; the SPI flash will ignore</span>
    <span class="comment">// the data.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send three dummy bytes, marking the last as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, 0);
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

    <span class="comment">//</span>
    <span class="comment">// Read the first returned data byte, which contains the manufacturer ID.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Data1);
    *pui8ManufacturerID = ui32Data1 &amp; 0xff;

    <span class="comment">//</span>
    <span class="comment">// Read the remaining two data bytes, which contain the device ID.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Data1);
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Data2);
    *pui16DeviceID = ((ui32Data1 &amp; 0xff) &lt;&lt; 8) | (ui32Data2 &amp; 0xff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf8c7a404794d8d63406154471c73540f"></a><!-- doxytag: member="spi_flash.c::SPIFlashReadNonBlocking" ref="gaf8c7a404794d8d63406154471c73540f" args="(tSPIFlashState *pState, uint32_t ui32Base, uint32_t ui32Addr, uint8_t *pui8Data, uint32_t ui32Count, bool bUseDMA, uint32_t ui32TxChannel, uint32_t ui32RxChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gaf8c7a404794d8d63406154471c73540f">SPIFlashReadNonBlocking</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_s_p_i_flash_state.html">tSPIFlashState</a> *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32TxChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32RxChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads data from the SPI flash in the background.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pState</td><td>is a pointer to the SPI flash state structure. </td></tr>
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to read. </td></tr>
    <tr><td class="paramname">pui8Data</td><td>is a pointer to the data buffer to into which to read the data. </td></tr>
    <tr><td class="paramname">ui32Count</td><td>is the number of bytes to read. </td></tr>
    <tr><td class="paramname">bUseDMA</td><td>is <b>true</b> if uDMA should be used and <b>false</b> otherwise. </td></tr>
    <tr><td class="paramname">ui32TxChannel</td><td>is the uDMA channel to be used for writing to the SSI module. </td></tr>
    <tr><td class="paramname">ui32RxChannel</td><td>is the uDMA channel to be used for reading from the SSI module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads data from the SPI flash, using either interrupts or uDMA to transfer the data. This function will return immediately and read the data in the background. In order for this to complete successfully, several conditions must be satisfied:</p>
<ul>
<li>Prior to calling this function:<ul>
<li>The SSI module must be enabled in SysCtl.</li>
<li>The SSI pins must be configured for use by the SSI module.</li>
<li>The SSI module interrupt must be enabled in NVIC.</li>
<li>The uDMA module must be enabled in SysCtl and the control table set (if using uDMA).</li>
<li>The uDMA channels must be assigned to the SSI module.</li>
</ul>
</li>
</ul>
<ul>
<li>After calling this function:<ul>
<li>The interrupt handler for the SSI module must call <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a>, passing the same pState structure pointer that was supplied to this function.</li>
<li>No other SPI flash operation can be called until this operation has completed.</li>
</ul>
</li>
</ul>
<p>Completion of the read operation is indicated when <a class="el" href="group__spi__flash__api.html#ga0d56c3c7817caa138af5f48be143f0f5">SPIFlashIntHandler()</a> returns <b>SPI_FLASH_DONE</b>.</p>
<p>Like <a class="el" href="group__spi__flash__api.html#gad3dbb731a043f828f04867ff9146b07a">SPIFlashRead()</a>, this uses the 0x03 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01510">1510</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8h_source.html#l00080">tSPIFlashState::bUseDMA</a>, <a class="el" href="spi__flash_8c_source.html#l00053">CMD_READ</a>, <a class="el" href="hw__types_8h_source.html#l00048">HWREG</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="spi__flash_8h_source.html#l00065">tSPIFlashState::pui8Buffer</a>, <a class="el" href="hw__ssi_8h_source.html#l00200">SSI_ICR_DMARXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00199">SSI_ICR_DMATXIC</a>, <a class="el" href="hw__ssi_8h_source.html#l00148">SSI_IM_RTIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00147">SSI_IM_RXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00146">SSI_IM_TXIM</a>, <a class="el" href="hw__ssi_8h_source.html#l00056">SSI_O_ICR</a>, <a class="el" href="hw__ssi_8h_source.html#l00053">SSI_O_IM</a>, <a class="el" href="spi__flash_8c_source.html#l00072">STATE_CMD</a>, <a class="el" href="spi__flash_8h_source.html#l00050">tSPIFlashState::ui16Cmd</a>, <a class="el" href="spi__flash_8h_source.html#l00055">tSPIFlashState::ui16State</a>, <a class="el" href="spi__flash_8h_source.html#l00060">tSPIFlashState::ui32Addr</a>, <a class="el" href="spi__flash_8h_source.html#l00045">tSPIFlashState::ui32Base</a>, <a class="el" href="spi__flash_8h_source.html#l00070">tSPIFlashState::ui32ReadCount</a>, <a class="el" href="spi__flash_8h_source.html#l00091">tSPIFlashState::ui32RxChannel</a>, <a class="el" href="spi__flash_8h_source.html#l00086">tSPIFlashState::ui32TxChannel</a>, and <a class="el" href="spi__flash_8h_source.html#l00075">tSPIFlashState::ui32WriteCount</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Trash;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Trash) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Save the parameters of this read operation to the state structure.</span>
    <span class="comment">//</span>
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#afa5492f2bf96fc487cb9c6e89ee75dbf" title="The base address of the SSI module that is being used.">ui32Base</a> = ui32Base;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a074f5ab3f6e39f06334bf7ce875c8027" title="The command that is being send to the SPI flash.">ui16Cmd</a> = <a class="code" href="group__spi__flash__api.html#ga9c953a6c538020e644127ee080608021">CMD_READ</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a13617645ea59a89666b09faca56d5e83" title="The current state of the SPI flash state machine.">ui16State</a> = <a class="code" href="group__spi__flash__api.html#ga88c4e00f812e9b6becece01b8f60d678">STATE_CMD</a>;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a14849eb4c3631e87c93d6bc2ed7c5a9d" title="The SPI flash address associated with the command.">ui32Addr</a> = ui32Addr;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a2bc8ac2fab0bc4c2a47f207c976ba875" title="A pointer to the data buffer that is being read or written.">pui8Buffer</a> = pui8Data;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ade82e929a6d52eb542fe1d34ee210764" title="The count of bytes left to be read.">ui32ReadCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a31ff9833643e984d1fd9e48d7a851a6b" title="The count of bytes left to be written.">ui32WriteCount</a> = ui32Count;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#ab33983a1783bc5f7593f60ebf8975645" title="A flag that is true if uDMA used be used for the transfer.">bUseDMA</a> = bUseDMA;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#a3bb98b66624f93e28338d954d3fd9032">ui32TxChannel</a> = ui32TxChannel &amp; 0x1f;
    pState-&gt;<a class="code" href="structt_s_p_i_flash_state.html#aa47658e72d6edfdebf29fd87a368c23e" title="The uDMA channel to use for receiving when using uDMA for the transfer.">ui32RxChannel</a> = ui32RxChannel &amp; 0x1f;

    <span class="comment">//</span>
    <span class="comment">// Enable the SSI transmit and receive interrupts.  This will start the</span>
    <span class="comment">// transfer.  If uDMA is being used, the uDMA-related interrupts will be</span>
    <span class="comment">// enabled at the appropriate time by the interrupt handler.</span>
    <span class="comment">//</span>
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#aaf63879f2c29b6fd6d9903153dd4271a">SSI_O_ICR</a>) = <a class="code" href="hw__ssi_8h.html#a873e573501798cee815d0e810979e579">SSI_ICR_DMATXIC</a> | <a class="code" href="hw__ssi_8h.html#a954860482fa17ad95cd0d4cb44fda84b">SSI_ICR_DMARXIC</a>;
    <a class="code" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>(ui32Base + <a class="code" href="hw__ssi_8h.html#a0c839fa56316268d9d3c1a6338d5b9a8">SSI_O_IM</a>) = <a class="code" href="hw__ssi_8h.html#a22cc1ee908ec15a4ae5cec1f77195b53">SSI_IM_TXIM</a> | <a class="code" href="hw__ssi_8h.html#a991109b454b7f2a294ce9dd2b523f378">SSI_IM_RXIM</a> | <a class="code" href="hw__ssi_8h.html#afd3ac990370ed4a0100b719fc1c7da7f">SSI_IM_RTIM</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabb1bf43047839456adfc4c6e484585a6"></a><!-- doxytag: member="spi_flash.c::SPIFlashReadStatus" ref="gabb1bf43047839456adfc4c6e484585a6" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the SPI flash status register.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the SPI flash status register. This uses the 0x05 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the value of the SPI flash status register. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01587">1587</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00055">CMD_RDSR</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04328">MAP_SSIDataGet</a>, <a class="el" href="rom__map_8h_source.html#l04335">MAP_SSIDataGetNonBlocking</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, <a class="el" href="ssi_8h_source.html#l00107">SSI_ADV_MODE_READ_WRITE</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    uint32_t ui32Data;

    <span class="comment">//</span>
    <span class="comment">// Drain any residual data from the receive FIFO.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(<a class="code" href="rom__map_8h.html#a2985d0cd62b5efa437dd6c4053a66e4f">MAP_SSIDataGetNonBlocking</a>(ui32Base, &amp;ui32Data) != 0)
    {
    }

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the write status register command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gaf36d3b85d64c03760c6b76e916b443c1">CMD_RDSR</a>);

    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into read/write mode.  In this mode, dummy writes are</span>
    <span class="comment">// required in order to make the transfer occur; the SPI flash will ignore</span>
    <span class="comment">// the data.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#a3b381e1d2c940e29363b2e12591f9a0b">SSI_ADV_MODE_READ_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Perform a single dummy write, marking it as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, 0);

    <span class="comment">//</span>
    <span class="comment">// Read the value of the status register.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a8f9f9fa6cc04e29027eaa0531d308ff1">MAP_SSIDataGet</a>(ui32Base, &amp;ui32Data);

    <span class="comment">//</span>
    <span class="comment">// Return the status register value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ui32Data &amp; 0xff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga058368211f1723e85295eb32b637360e"></a><!-- doxytag: member="spi_flash.c::SPIFlashSectorErase" ref="ga058368211f1723e85295eb32b637360e" args="(uint32_t ui32Base, uint32_t ui32Addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga058368211f1723e85295eb32b637360e">SPIFlashSectorErase</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases a 4 KB sector of the SPI flash.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui32Addr</td><td>is the SPI flash address to erase.</td></tr>
  </table>
  </dd>
</dl>
<p>This function erases a sector of the SPI flash. Each sector is 4 KB with a 4 KB alignment; the SPI flash will ignore the lower ten bits of the address provided. The sector erase command is issued by this function; <a class="el" href="group__spi__flash__api.html#gabb1bf43047839456adfc4c6e484585a6">SPIFlashReadStatus()</a> must be used to query the SPI flash to determine when the sector erase operation has completed. This uses the 0x20 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01882">1882</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00058">CMD_SE</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the sector erase command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gab108a0bca1eff44cfc82862a6931b04f">CMD_SE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the address of the sector to be erased, marking the last byte of</span>
    <span class="comment">// the address as the end of the frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 16) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, (ui32Addr &gt;&gt; 8) &amp; 0xff);
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, ui32Addr &amp; 0xff);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga86346f2b25c46fb16acdb7a0315f68c9"></a><!-- doxytag: member="spi_flash.c::SPIFlashWriteDisable" ref="ga86346f2b25c46fb16acdb7a0315f68c9" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga86346f2b25c46fb16acdb7a0315f68c9">SPIFlashWriteDisable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables SPI flash write operations.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the SPI flash to disallow program and erase operations. This uses the 0x04 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01560">1560</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00054">CMD_WRDI</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the write disable command, marking this byte as the end of the</span>
    <span class="comment">// frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gaa98eb90657f02a0b7a4634174081799e">CMD_WRDI</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gadd97a4e0bcaa224283744a64c10a701c"></a><!-- doxytag: member="spi_flash.c::SPIFlashWriteEnable" ref="gadd97a4e0bcaa224283744a64c10a701c" args="(uint32_t ui32Base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#gadd97a4e0bcaa224283744a64c10a701c">SPIFlashWriteEnable</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables SPI flash write operations.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the SPI flash to allow program and erase operations. This must be done prior to each SPI flash program or erase operation; the SPI flash will automatically disable program and erase operations once a program or erase operation has completed. This uses the 0x06 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01647">1647</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00056">CMD_WREN</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the write enable command, marking this byte as the end of the</span>
    <span class="comment">// frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#ga233ab2b77759d1d35814743f08c96347">CMD_WREN</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga901b800fe1f8a373dcc1e269f4f40e04"></a><!-- doxytag: member="spi_flash.c::SPIFlashWriteStatus" ref="ga901b800fe1f8a373dcc1e269f4f40e04" args="(uint32_t ui32Base, uint8_t ui8Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__spi__flash__api.html#ga901b800fe1f8a373dcc1e269f4f40e04">SPIFlashWriteStatus</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ui8Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the SPI flash status register.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Base</td><td>is the SSI module base address. </td></tr>
    <tr><td class="paramname">ui8Status</td><td>is the value to write to the status register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the SPI flash status register. This uses the 0x01 SPI flash command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="spi__flash_8c_source.html#l01212">1212</a> of file <a class="el" href="spi__flash_8c_source.html">spi_flash.c</a>.</p>

<p>References <a class="el" href="spi__flash_8c_source.html#l00051">CMD_WRSR</a>, <a class="el" href="rom__map_8h_source.html#l04384">MAP_SSIAdvDataPutFrameEnd</a>, <a class="el" href="rom__map_8h_source.html#l04377">MAP_SSIAdvModeSet</a>, <a class="el" href="rom__map_8h_source.html#l04265">MAP_SSIDataPut</a>, and <a class="el" href="ssi_8h_source.html#l00108">SSI_ADV_MODE_WRITE</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Set the SSI module into write-only mode.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#af2a8506d9ba0b87db9ebb07871785993">MAP_SSIAdvModeSet</a>(ui32Base, <a class="code" href="ssi_8h.html#ac06e63f4a08c332b7dbd3b1cb0c6154c">SSI_ADV_MODE_WRITE</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the write status register command.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#aed26e3b46561e08948d24d8f583a7c43">MAP_SSIDataPut</a>(ui32Base, <a class="code" href="group__spi__flash__api.html#gacf9ec38b37caa1223e957bba6058f626">CMD_WRSR</a>);

    <span class="comment">//</span>
    <span class="comment">// Send the new status register value, marking this byte as the end of the</span>
    <span class="comment">// frame.</span>
    <span class="comment">//</span>
    <a class="code" href="rom__map_8h.html#a96329eb749a2f91f9676bbfacbe0bb7d">MAP_SSIAdvDataPutFrameEnd</a>(ui32Base, ui8Status);
}
</pre></div>
</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jan 27 2015 22:34:58 for EE445M Real Time Operating Systems by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
