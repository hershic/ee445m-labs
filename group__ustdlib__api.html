<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>EE445M Real Time Operating Systems: Ustdlib_api</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">EE445M Real Time Operating Systems
   
   </div>
   <div id="projectbrief">Taken at the University of Texas Spring 2015</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__ustdlib__api.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Ustdlib_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a> (char *s1, const char *s2, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70">uvsnprintf</a> (char *s, size_t n, const char *format, va_list arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga43a285f04c8bcd68ddb8a16ca4f4a43c">usprintf</a> (char *s, const char *format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gabba09d3e2aec8902cd6c72c79d364dac">usnprintf</a> (char *s, size_t n, const char *format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a> (time_t timer, struct tm *tm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga06ccdf7b6e513ef783d4ac92dee507c6">ucmptime</a> (struct tm *t1, struct tm *t2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaaf70d2ea7909ed1600710c2113c84907">umktime</a> (struct tm *timeptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga643aaaee2316d5f31b9b4f62d169571a">ustrtoul</a> (const char *nptr, const char **endptr, int base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga7c1f1d61220c492f777a3f25fd34df3a">ustrtof</a> (const char *nptr, const char **endptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga277a9ccba3eabd09f2214dd508ddae9e">ustrlen</a> (const char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gacc7c68bbbc467d9e1a855552ed586a54">ustrstr</a> (const char *s1, const char *s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga0085d1d81c8d1570a12a02d3b6ffface">ustrncasecmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gacb9ef59ae11aae4f0169fb3dab34d2d6">ustrcasecmp</a> (const char *s1, const char *s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaee3790eee84161a4ea17657fe464e8ab">ustrcmp</a> (const char *s1, const char *s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaaecc415a64e9bc2cce10f03eb7a6b753">usrand</a> (unsigned int seed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gae2ac426587be82ba1a5b5eed7067fd0c">g_pcHex</a> = &quot;0123456789abcdef&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga7317c745b34e7997a57fc64a28fc74a8">g_psDaysToMonth</a> [12]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga472f478db7f9e5884272a134b0211c3f">g_pfExponents</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a> = 1</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga06ccdf7b6e513ef783d4ac92dee507c6"></a><!-- doxytag: member="ustdlib.c::ucmptime" ref="ga06ccdf7b6e513ef783d4ac92dee507c6" args="(struct tm *t1, struct tm *t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="group__ustdlib__api.html#ga06ccdf7b6e513ef783d4ac92dee507c6">ucmptime</a> </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two time structures and determines if one is greater than, less than, or equal to the other.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>is the first time structure to compare. </td></tr>
    <tr><td class="paramname">t2</td><td>is the second time structure to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function compares two time structures and returns a signed number to indicate the result of the comparison. If the time represented by <em>t1</em> is greater than the time represented by <em>t2</em> then a positive number is returned. Likewise if <em>t1</em> is less than <em>t2</em> then a negative number is returned. If the two times are equal then the function returns 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two times are equal, +1 if <em>t1</em> is greater than <em>t2</em>, and -1 if <em>t1</em> is less than <em>t2</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00954">954</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01034">umktime()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Compare each field in descending signficance to determine if</span>
    <span class="comment">// greater than, less than, or equal.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(t1-&gt;tm_year &gt; t2-&gt;tm_year)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_year &lt; t2-&gt;tm_year)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_mon &gt; t2-&gt;tm_mon)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_mon &lt; t2-&gt;tm_mon)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_mday &gt; t2-&gt;tm_mday)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_mday &lt; t2-&gt;tm_mday)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_hour &gt; t2-&gt;tm_hour)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_hour &lt; t2-&gt;tm_hour)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_min &gt; t2-&gt;tm_min)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_min &lt; t2-&gt;tm_min)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_sec &gt; t2-&gt;tm_sec)
    {
        <span class="keywordflow">return</span>(1);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(t1-&gt;tm_sec &lt; t2-&gt;tm_sec)
    {
        <span class="keywordflow">return</span>(-1);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">//</span>
        <span class="comment">// Reaching this branch of the conditional means that all of the</span>
        <span class="comment">// fields are equal, and thus the two times are equal.</span>
        <span class="comment">//</span>
        <span class="keywordflow">return</span>(0);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga06ccdf7b6e513ef783d4ac92dee507c6_icgraph.png" border="0" usemap="#group__ustdlib__api_ga06ccdf7b6e513ef783d4ac92dee507c6_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga06ccdf7b6e513ef783d4ac92dee507c6_icgraph" id="group__ustdlib__api_ga06ccdf7b6e513ef783d4ac92dee507c6_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gaaf70d2ea7909ed1600710c2113c84907" title="umktime" alt="" coords="133,5,205,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga3a5728f0b62a5c92bc34f0a41c33278c"></a><!-- doxytag: member="ustdlib.c::ulocaltime" ref="ga3a5728f0b62a5c92bc34f0a41c33278c" args="(time_t timer, struct tm *tm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a> </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts from seconds to calendar date and time.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the number of seconds. </td></tr>
    <tr><td class="paramname">tm</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch) into the equivalent month, day, year, hours, minutes, and seconds representation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00862">862</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l00841">g_psDaysToMonth</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01034">umktime()</a>.</p>
<div class="fragment"><pre class="fragment">{
    time_t temp, months;

    <span class="comment">//</span>
    <span class="comment">// Extract the number of seconds, converting time to the number of minutes.</span>
    <span class="comment">//</span>
    temp = timer / 60;
    tm-&gt;tm_sec = timer - (temp * 60);
    timer = temp;

    <span class="comment">//</span>
    <span class="comment">// Extract the number of minutes, converting time to the number of hours.</span>
    <span class="comment">//</span>
    temp = timer / 60;
    tm-&gt;tm_min = timer - (temp * 60);
    timer = temp;

    <span class="comment">//</span>
    <span class="comment">// Extract the number of hours, converting time to the number of days.</span>
    <span class="comment">//</span>
    temp = timer / 24;
    tm-&gt;tm_hour = timer - (temp * 24);
    timer = temp;

    <span class="comment">//</span>
    <span class="comment">// Compute the day of the week.</span>
    <span class="comment">//</span>
    tm-&gt;tm_wday = (timer + 4) % 7;

    <span class="comment">//</span>
    <span class="comment">// Compute the number of leap years that have occurred since 1968, the</span>
    <span class="comment">// first leap year before 1970.  For the beginning of a leap year, cut the</span>
    <span class="comment">// month loop below at March so that the leap day is classified as February</span>
    <span class="comment">// 29 followed by March 1, instead of March 1 followed by another March 1.</span>
    <span class="comment">//</span>
    timer += 366 + 365;
    temp = timer / ((4 * 365) + 1);
    <span class="keywordflow">if</span>((timer - (temp * ((4 * 365) + 1))) &gt; (31 + 28))
    {
        temp++;
        months = 12;
    }
    <span class="keywordflow">else</span>
    {
        months = 2;
    }

    <span class="comment">//</span>
    <span class="comment">// Extract the year.</span>
    <span class="comment">//</span>
    tm-&gt;tm_year = ((timer - temp) / 365) + 68;
    timer -= ((tm-&gt;tm_year - 68) * 365) + temp;

    <span class="comment">//</span>
    <span class="comment">// Extract the month.</span>
    <span class="comment">//</span>
    <span class="keywordflow">for</span>(temp = 0; temp &lt; months; temp++)
    {
        <span class="keywordflow">if</span>(<a class="code" href="group__ustdlib__api.html#ga7317c745b34e7997a57fc64a28fc74a8">g_psDaysToMonth</a>[temp] &gt; timer)
        {
            <span class="keywordflow">break</span>;
        }
    }
    tm-&gt;tm_mon = temp - 1;

    <span class="comment">//</span>
    <span class="comment">// Extract the day of the month.</span>
    <span class="comment">//</span>
    tm-&gt;tm_mday = timer - <a class="code" href="group__ustdlib__api.html#ga7317c745b34e7997a57fc64a28fc74a8">g_psDaysToMonth</a>[temp - 1] + 1;
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph.png" border="0" usemap="#group__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph" id="group__ustdlib__api_ga3a5728f0b62a5c92bc34f0a41c33278c_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gaaf70d2ea7909ed1600710c2113c84907" title="umktime" alt="" coords="136,5,208,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaaf70d2ea7909ed1600710c2113c84907"></a><!-- doxytag: member="ustdlib.c::umktime" ref="gaaf70d2ea7909ed1600710c2113c84907" args="(struct tm *timeptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="group__ustdlib__api.html#gaaf70d2ea7909ed1600710c2113c84907">umktime</a> </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts calendar date and time to seconds.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts the date and time represented by the <em>timeptr</em> structure pointer to the number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the calendar time and date as seconds. If the conversion was not possible then the function returns (uint32_t)(-1). </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01034">1034</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l00954">ucmptime()</a>, and <a class="el" href="ustdlib_8c_source.html#l00862">ulocaltime()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span>tm sTimeGuess;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulTimeGuess = 0x80000000;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulAdjust = 0x40000000;
    <span class="keywordtype">int</span> iSign;

    <span class="comment">//</span>
    <span class="comment">// Seed the binary search with the first guess.</span>
    <span class="comment">//</span>
    <a class="code" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a>(ulTimeGuess, &amp;sTimeGuess);
    iSign = <a class="code" href="group__ustdlib__api.html#ga06ccdf7b6e513ef783d4ac92dee507c6">ucmptime</a>(timeptr, &amp;sTimeGuess);

    <span class="comment">//</span>
    <span class="comment">// While the time is not yet found, execute a binary search.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(iSign &amp;&amp; ulAdjust)
    {
        <span class="comment">//</span>
        <span class="comment">// Adjust the time guess up or down depending on the result of the</span>
        <span class="comment">// last compare.</span>
        <span class="comment">//</span>
        ulTimeGuess = ((iSign &gt; 0) ? (ulTimeGuess + ulAdjust) :
                       (ulTimeGuess - ulAdjust));
        ulAdjust /= 2;

        <span class="comment">//</span>
        <span class="comment">// Compare the new time guess against the time pointed at by the</span>
        <span class="comment">// function parameters.</span>
        <span class="comment">//</span>
        <a class="code" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a>(ulTimeGuess, &amp;sTimeGuess);
        iSign = <a class="code" href="group__ustdlib__api.html#ga06ccdf7b6e513ef783d4ac92dee507c6">ucmptime</a>(timeptr, &amp;sTimeGuess);
    }

    <span class="comment">//</span>
    <span class="comment">// If the above loop was exited with iSign == 0, that means that the</span>
    <span class="comment">// time in seconds was found, so return that value to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(iSign == 0)
    {
        <span class="keywordflow">return</span>(ulTimeGuess);
    }

    <span class="comment">//</span>
    <span class="comment">// Otherwise the time could not be converted so return an error.</span>
    <span class="comment">//</span>
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">return</span>((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)-1);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph.png" border="0" usemap="#group__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph" alt=""/></div>
<map name="group__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph" id="group__ustdlib__api_gaaf70d2ea7909ed1600710c2113c84907_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga06ccdf7b6e513ef783d4ac92dee507c6" title="ucmptime" alt="" coords="128,5,205,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c" title="ulocaltime" alt="" coords="127,59,207,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga04408b1c80a2190c4aad7b783b5af8d8"></a><!-- doxytag: member="ustdlib.c::urand" ref="ga04408b1c80a2190c4aad7b783b5af8d8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a new (pseudo) random number</p>
<p>This function is very similar to the C library <code>rand()</code> function. It will generate a pseudo-random number sequence based on the seed value.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pseudo-random number will be returned. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01806">1806</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l01774">g_iRandomSeed</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Generate a new pseudo-random number with a linear congruence random</span>
    <span class="comment">// number generator.  This new random number becomes the seed for the next</span>
    <span class="comment">// random number.</span>
    <span class="comment">//</span>
    <a class="code" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a> = (<a class="code" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a> * 1664525) + 1013904223;

    <span class="comment">//</span>
    <span class="comment">// Return the new random number.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)<a class="code" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gabba09d3e2aec8902cd6c72c79d364dac"></a><!-- doxytag: member="ustdlib.c::usnprintf" ref="gabba09d3e2aec8902cd6c72c79d364dac" args="(char *s, size_t n, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#gabba09d3e2aec8902cd6c72c79d364dac">usnprintf</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple snprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The function will copy at most <em>n</em> - 1 characters into the buffer <em>s</em>. One space is reserved in the buffer for the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00809">809</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l00158">uvsnprintf()</a>.</p>
<div class="fragment"><pre class="fragment">{
    va_list arg;
    <span class="keywordtype">int</span> ret;

    <span class="comment">//</span>
    <span class="comment">// Start the varargs processing.</span>
    <span class="comment">//</span>
    va_start(arg, format);

    <span class="comment">//</span>
    <span class="comment">// Call vsnprintf to perform the conversion.</span>
    <span class="comment">//</span>
    ret = <a class="code" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70">uvsnprintf</a>(s, n, format, arg);

    <span class="comment">//</span>
    <span class="comment">// End the varargs processing.</span>
    <span class="comment">//</span>
    va_end(arg);

    <span class="comment">//</span>
    <span class="comment">// Return the conversion count.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ret);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gabba09d3e2aec8902cd6c72c79d364dac_cgraph.png" border="0" usemap="#group__ustdlib__api_gabba09d3e2aec8902cd6c72c79d364dac_cgraph" alt=""/></div>
<map name="group__ustdlib__api_gabba09d3e2aec8902cd6c72c79d364dac_cgraph" id="group__ustdlib__api_gabba09d3e2aec8902cd6c72c79d364dac_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70" title="uvsnprintf" alt="" coords="127,5,204,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc" title="ustrncpy" alt="" coords="253,5,325,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga43a285f04c8bcd68ddb8a16ca4f4a43c"></a><!-- doxytag: member="ustdlib.c::usprintf" ref="ga43a285f04c8bcd68ddb8a16ca4f4a43c" args="(char *s, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#ga43a285f04c8bcd68ddb8a16ca4f4a43c">usprintf</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple sprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The caller must ensure that the buffer <em>s</em> is large enough to hold the entire converted string, including the null termination character.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the count of characters that were written to the output buffer, not including the NULL termination character. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00731">731</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l00158">uvsnprintf()</a>.</p>
<div class="fragment"><pre class="fragment">{
    va_list arg;
    <span class="keywordtype">int</span> ret;

    <span class="comment">//</span>
    <span class="comment">// Start the varargs processing.</span>
    <span class="comment">//</span>
    va_start(arg, format);

    <span class="comment">//</span>
    <span class="comment">// Call vsnprintf to perform the conversion.  Use a large number for the</span>
    <span class="comment">// buffer size.</span>
    <span class="comment">//</span>
    ret = <a class="code" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70">uvsnprintf</a>(s, 0xffff, format, arg);

    <span class="comment">//</span>
    <span class="comment">// End the varargs processing.</span>
    <span class="comment">//</span>
    va_end(arg);

    <span class="comment">//</span>
    <span class="comment">// Return the conversion count.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ret);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga43a285f04c8bcd68ddb8a16ca4f4a43c_cgraph.png" border="0" usemap="#group__ustdlib__api_ga43a285f04c8bcd68ddb8a16ca4f4a43c_cgraph" alt=""/></div>
<map name="group__ustdlib__api_ga43a285f04c8bcd68ddb8a16ca4f4a43c_cgraph" id="group__ustdlib__api_ga43a285f04c8bcd68ddb8a16ca4f4a43c_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70" title="uvsnprintf" alt="" coords="121,5,199,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc" title="ustrncpy" alt="" coords="248,5,320,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaaecc415a64e9bc2cce10f03eb7a6b753"></a><!-- doxytag: member="ustdlib.c::usrand" ref="gaaecc415a64e9bc2cce10f03eb7a6b753" args="(unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__ustdlib__api.html#gaaecc415a64e9bc2cce10f03eb7a6b753">usrand</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the random number generator seed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>is the new seed value to use for the random number generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>srand()</code> function. It will set the seed value used in the <code><a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand()</a></code> function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01790">1790</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l01774">g_iRandomSeed</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a> = seed;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gacb9ef59ae11aae4f0169fb3dab34d2d6"></a><!-- doxytag: member="ustdlib.c::ustrcasecmp" ref="gacb9ef59ae11aae4f0169fb3dab34d2d6" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#gacb9ef59ae11aae4f0169fb3dab34d2d6">ustrcasecmp</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcasecmp()</code> function. It compares two strings without regard to case. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01673">1673</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l01604">ustrncasecmp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Just let ustrncasecmp() handle this.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="group__ustdlib__api.html#ga0085d1d81c8d1570a12a02d3b6ffface">ustrncasecmp</a>(s1, s2, (<span class="keywordtype">size_t</span>)-1));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph.png" border="0" usemap="#group__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph" alt=""/></div>
<map name="group__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph" id="group__ustdlib__api_gacb9ef59ae11aae4f0169fb3dab34d2d6_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga0085d1d81c8d1570a12a02d3b6ffface" title="ustrncasecmp" alt="" coords="152,5,256,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gaee3790eee84161a4ea17657fe464e8ab"></a><!-- doxytag: member="ustdlib.c::ustrcmp" ref="gaee3790eee84161a4ea17657fe464e8ab" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#gaee3790eee84161a4ea17657fe464e8ab">ustrcmp</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcmp()</code> function. It compares two strings, taking case into account. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01761">1761</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l01700">ustrncmp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Pass this on to ustrncmp.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(<a class="code" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a>(s1, s2, (<span class="keywordtype">size_t</span>)-1));
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph.png" border="0" usemap="#group__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph" alt=""/></div>
<map name="group__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph" id="group__ustdlib__api_gaee3790eee84161a4ea17657fe464e8ab_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077" title="ustrncmp" alt="" coords="124,5,199,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga277a9ccba3eabd09f2214dd508ddae9e"></a><!-- doxytag: member="ustdlib.c::ustrlen" ref="ga277a9ccba3eabd09f2214dd508ddae9e" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="group__ustdlib__api.html#ga277a9ccba3eabd09f2214dd508ddae9e">ustrlen</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the length of a null-terminated string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is a pointer to the string whose length is to be found.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strlen()</code> function. It determines the length of the null-terminated string passed and returns this to the caller.</p>
<p>This implementation assumes that single byte character strings are passed and will return incorrect values if passed some UTF-8 strings.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the length of the string pointed to by <em>s</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01501">1501</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>.</p>

<p>Referenced by <a class="el" href="lib_2libuart_2uart_8c_source.html#l00075">uart_send_string_()</a>, and <a class="el" href="ustdlib_8c_source.html#l01547">ustrstr()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> len;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(s);

    <span class="comment">//</span>
    <span class="comment">// Initialize the length.</span>
    <span class="comment">//</span>
    len = 0;

    <span class="comment">//</span>
    <span class="comment">// Step throug the string looking for a zero character (marking its end).</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(s[len])
    {
        <span class="comment">//</span>
        <span class="comment">// Zero not found so move on to the next character.</span>
        <span class="comment">//</span>
        len++;
    }

    <span class="keywordflow">return</span>(len);
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph.png" border="0" usemap="#group__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph" id="group__ustdlib__api_ga277a9ccba3eabd09f2214dd508ddae9e_icgraph">
<area shape="rect" id="node3" href="lib_2libuart_2uart_8h.html#a511e841b613337d3f818786891074f07" title="uart_send_string_" alt="" coords="115,5,240,35"/><area shape="rect" id="node7" href="group__ustdlib__api.html#gacc7c68bbbc467d9e1a855552ed586a54" title="ustrstr" alt="" coords="148,59,207,88"/><area shape="rect" id="node5" href="lib_2libuart_2uart_8h.html#a6663854cc5f46b64a624589faacd8979" title="uart_send_string" alt="" coords="289,5,407,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga0085d1d81c8d1570a12a02d3b6ffface"></a><!-- doxytag: member="ustdlib.c::ustrncasecmp" ref="ga0085d1d81c8d1570a12a02d3b6ffface" args="(const char *s1, const char *s2, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#ga0085d1d81c8d1570a12a02d3b6ffface">ustrncasecmp</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncasecmp()</code> function. It compares at most <em>n</em> characters of two strings without regard to case. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01604">1604</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01673">ustrcasecmp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">char</span> c1, c2;

    <span class="comment">//</span>
    <span class="comment">// Loop while there are more characters to compare.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(n)
    {
        <span class="comment">//</span>
        <span class="comment">// If we reached a NULL in both strings, they must be equal so</span>
        <span class="comment">// we end the comparison and return 0</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(!*s1 &amp;&amp; !*s2)
        {
            <span class="keywordflow">return</span>(0);
        }

        <span class="comment">//</span>
        <span class="comment">// Lower case the characters at the current position before we compare.</span>
        <span class="comment">//</span>
        c1 = (((*s1 &gt;= <span class="charliteral">&#39;A&#39;</span>) &amp;&amp; (*s1 &lt;= <span class="charliteral">&#39;Z&#39;</span>)) ? (*s1 + (<span class="charliteral">&#39;a&#39;</span> - <span class="charliteral">&#39;A&#39;</span>)) : *s1);
        c2 = (((*s2 &gt;= <span class="charliteral">&#39;A&#39;</span>) &amp;&amp; (*s2 &lt;= <span class="charliteral">&#39;Z&#39;</span>)) ? (*s2 + (<span class="charliteral">&#39;a&#39;</span> - <span class="charliteral">&#39;A&#39;</span>)) : *s2);

        <span class="comment">//</span>
        <span class="comment">// Compare the two characters and, if different, return the relevant</span>
        <span class="comment">// return code.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(c2 &lt; c1)
        {
            <span class="keywordflow">return</span>(1);
        }
        <span class="keywordflow">if</span>(c1 &lt; c2)
        {
            <span class="keywordflow">return</span>(-1);
        }

        <span class="comment">//</span>
        <span class="comment">// Move on to the next character.</span>
        <span class="comment">//</span>
        s1++;
        s2++;
        n--;
    }

    <span class="comment">//</span>
    <span class="comment">// If we fall out, the strings must be equal for at least the first n</span>
    <span class="comment">// characters so return 0 to indicate this.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(0);
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph.png" border="0" usemap="#group__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph" id="group__ustdlib__api_ga0085d1d81c8d1570a12a02d3b6ffface_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gacb9ef59ae11aae4f0169fb3dab34d2d6" title="ustrcasecmp" alt="" coords="159,5,255,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gad21ed7429e68621153a72a7230a6a077"></a><!-- doxytag: member="ustdlib.c::ustrncmp" ref="gad21ed7429e68621153a72a7230a6a077" args="(const char *s1, const char *s2, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncmp()</code> function. It compares at most <em>n</em> characters of two strings taking case into account. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01700">1700</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01761">ustrcmp()</a>, and <a class="el" href="ustdlib_8c_source.html#l01547">ustrstr()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//</span>
    <span class="comment">// Loop while there are more characters.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(n)
    {
        <span class="comment">//</span>
        <span class="comment">// If we reached a NULL in both strings, they must be equal so we end</span>
        <span class="comment">// the comparison and return 0</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(!*s1 &amp;&amp; !*s2)
        {
            <span class="keywordflow">return</span>(0);
        }

        <span class="comment">//</span>
        <span class="comment">// Compare the two characters and, if different, return the relevant</span>
        <span class="comment">// return code.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(*s2 &lt; *s1)
        {
            <span class="keywordflow">return</span>(1);
        }
        <span class="keywordflow">if</span>(*s1 &lt; *s2)
        {
            <span class="keywordflow">return</span>(-1);
        }

        <span class="comment">//</span>
        <span class="comment">// Move on to the next character.</span>
        <span class="comment">//</span>
        s1++;
        s2++;
        n--;
    }

    <span class="comment">//</span>
    <span class="comment">// If we fall out, the strings must be equal for at least the first n</span>
    <span class="comment">// characters so return 0 to indicate this.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(0);
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph.png" border="0" usemap="#group__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph" alt=""/></div>
<map name="group__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph" id="group__ustdlib__api_gad21ed7429e68621153a72a7230a6a077_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gaee3790eee84161a4ea17657fe464e8ab" title="ustrcmp" alt="" coords="131,5,200,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#gacc7c68bbbc467d9e1a855552ed586a54" title="ustrstr" alt="" coords="136,59,195,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9c6b6efcdd76a057125b6e580d0b47fc"></a><!-- doxytag: member="ustdlib.c::ustrncpy" ref="ga9c6b6efcdd76a057125b6e580d0b47fc" args="(char *s1, const char *s2, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies a certain number of characters from one string to another.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the destination buffer into which characters are to be copied. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the string from which characters are to be copied. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of characters to copy to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies at most <em>n</em> characters from the string pointed to by <em>s2</em> into the buffer pointed to by <em>s1</em>. If the end of <em>s2</em> is found before <em>n</em> characters have been copied, remaining characters in <em>s1</em> will be padded with zeroes until <em>n</em> characters have been written. Note that the destination string will only be NULL terminated if the number of characters to be copied is greater than the length of <em>s2</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <em>s1</em>. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00065">65</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l00158">uvsnprintf()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> count;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(s1);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(s2);

    <span class="comment">//</span>
    <span class="comment">// Start at the beginning of the source string.</span>
    <span class="comment">//</span>
    count = 0;

    <span class="comment">//</span>
    <span class="comment">// Copy the source string until we run out of source characters or</span>
    <span class="comment">// destination space.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(n &amp;&amp; s2[count])
    {
        s1[count] = s2[count];
        count++;
        n--;
    }

    <span class="comment">//</span>
    <span class="comment">// Pad the destination if we are not yet done.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(n)
    {
        s1[count++] = (char)0;
        n--;
    }

    <span class="comment">//</span>
    <span class="comment">// Pass the destination pointer back to the caller.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(s1);
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga9c6b6efcdd76a057125b6e580d0b47fc_icgraph.png" border="0" usemap="#group__ustdlib__api_ga9c6b6efcdd76a057125b6e580d0b47fc_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga9c6b6efcdd76a057125b6e580d0b47fc_icgraph" id="group__ustdlib__api_ga9c6b6efcdd76a057125b6e580d0b47fc_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70" title="uvsnprintf" alt="" coords="127,32,204,61"/><area shape="rect" id="node5" href="group__ustdlib__api.html#ga43a285f04c8bcd68ddb8a16ca4f4a43c" title="usprintf" alt="" coords="257,5,321,35"/><area shape="rect" id="node7" href="group__ustdlib__api.html#gabba09d3e2aec8902cd6c72c79d364dac" title="usnprintf" alt="" coords="253,59,325,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacc7c68bbbc467d9e1a855552ed586a54"></a><!-- doxytag: member="ustdlib.c::ustrstr" ref="gacc7c68bbbc467d9e1a855552ed586a54" args="(const char *s1, const char *s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="group__ustdlib__api.html#gacc7c68bbbc467d9e1a855552ed586a54">ustrstr</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds a substring within a string.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the string that will be searched. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the substring that is to be found within <em>s1</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strstr()</code> function. It scans a string for the first instance of a given substring and returns a pointer to that substring. If the substring cannot be found, a NULL pointer is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the first occurrence of <em>s2</em> within <em>s1</em> or NULL if no match is found. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01547">1547</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="ustdlib_8c_source.html#l01501">ustrlen()</a>, and <a class="el" href="ustdlib_8c_source.html#l01700">ustrncmp()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> n;

    <span class="comment">//</span>
    <span class="comment">// Get the length of the string to be found.</span>
    <span class="comment">//</span>
    n = <a class="code" href="group__ustdlib__api.html#ga277a9ccba3eabd09f2214dd508ddae9e">ustrlen</a>(s2);

    <span class="comment">//</span>
    <span class="comment">// Loop while we have not reached the end of the string.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(*s1)
    {
        <span class="comment">//</span>
        <span class="comment">// Check to see if the substring appears at this position.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a>(s2, s1, n) == 0)
        {
            <span class="comment">//</span>
            <span class="comment">// It does so return the pointer.</span>
            <span class="comment">//</span>
            <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)s1);
        }

        <span class="comment">//</span>
        <span class="comment">// Move to the next position in the string being searched.</span>
        <span class="comment">//</span>
        s1++;
    }

    <span class="comment">//</span>
    <span class="comment">// We reached the end of the string without finding the substring so</span>
    <span class="comment">// return NULL.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)0);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_gacc7c68bbbc467d9e1a855552ed586a54_cgraph.png" border="0" usemap="#group__ustdlib__api_gacc7c68bbbc467d9e1a855552ed586a54_cgraph" alt=""/></div>
<map name="group__ustdlib__api_gacc7c68bbbc467d9e1a855552ed586a54_cgraph" id="group__ustdlib__api_gacc7c68bbbc467d9e1a855552ed586a54_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga277a9ccba3eabd09f2214dd508ddae9e" title="ustrlen" alt="" coords="120,5,181,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077" title="ustrncmp" alt="" coords="113,59,188,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7c1f1d61220c492f777a3f25fd34df3a"></a><!-- doxytag: member="ustdlib.c::ustrtof" ref="ga7c1f1d61220c492f777a3f25fd34df3a" args="(const char *nptr, const char **endptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="group__ustdlib__api.html#ga7c1f1d61220c492f777a3f25fd34df3a">ustrtof</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a string into its floating-point equivalent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the floating-point value. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the floating-point value in the string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtof()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into a floating-point value.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the result of the conversion. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01313">1313</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, and <a class="el" href="ustdlib_8c_source.html#l01285">g_pfExponents</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulNeg, ulExp, ulExpNeg, ulValid, ulIdx;
    <span class="keywordtype">float</span> fRet, fDigit, fExp;
    <span class="keyword">const</span> <span class="keywordtype">char</span> *pcPtr;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(nptr);

    <span class="comment">//</span>
    <span class="comment">// Initially, the result is zero.</span>
    <span class="comment">//</span>
    fRet = 0;
    ulNeg = 0;
    ulValid = 0;

    <span class="comment">//</span>
    <span class="comment">// Skip past any leading white space.</span>
    <span class="comment">//</span>
    pcPtr = nptr;
    <span class="keywordflow">while</span>((*pcPtr == <span class="charliteral">&#39; &#39;</span>) || (*pcPtr == <span class="charliteral">&#39;\t&#39;</span>))
    {
        pcPtr++;
    }

    <span class="comment">//</span>
    <span class="comment">// Take a leading + or - from the value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;-&#39;</span>)
    {
        ulNeg = 1;
        pcPtr++;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;+&#39;</span>)
    {
        pcPtr++;
    }

    <span class="comment">//</span>
    <span class="comment">// Loop while there are valid digits to consume.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>((*pcPtr &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;9&#39;</span>))
    {
        <span class="comment">//</span>
        <span class="comment">// Add this digit to the converted value.</span>
        <span class="comment">//</span>
        fRet *= 10;
        fRet += *pcPtr++ - <span class="charliteral">&#39;0&#39;</span>;

        <span class="comment">//</span>
        <span class="comment">// Since a digit has been added, this is now a valid result.</span>
        <span class="comment">//</span>
        ulValid = 1;
    }

    <span class="comment">//</span>
    <span class="comment">// See if the next character is a period and the character after that is a</span>
    <span class="comment">// digit, indicating the start of the fractional portion of the value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>((*pcPtr == <span class="charliteral">&#39;.&#39;</span>) &amp;&amp; (pcPtr[1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (pcPtr[1] &lt;= <span class="charliteral">&#39;9&#39;</span>))
    {
        <span class="comment">//</span>
        <span class="comment">// Skip the period.</span>
        <span class="comment">//</span>
        pcPtr++;

        <span class="comment">//</span>
        <span class="comment">// Loop while there are valid fractional digits to consume.</span>
        <span class="comment">//</span>
        fDigit = 0.1;
        <span class="keywordflow">while</span>((*pcPtr &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;9&#39;</span>))
        {
            <span class="comment">//</span>
            <span class="comment">// Add this digit to the converted value.</span>
            <span class="comment">//</span>
            fRet += (*pcPtr++ - <span class="charliteral">&#39;0&#39;</span>) * fDigit;
            fDigit /= (float)10.0;

            <span class="comment">//</span>
            <span class="comment">// Since a digit has been added, this is now a valid result.</span>
            <span class="comment">//</span>
            ulValid = 1;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// See if the next character is an &quot;e&quot; and a valid number has been</span>
    <span class="comment">// converted, indicating the start of the exponent.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(((pcPtr[0] == <span class="charliteral">&#39;e&#39;</span>) || (pcPtr[0] == <span class="charliteral">&#39;E&#39;</span>)) &amp;&amp; (ulValid == 1) &amp;&amp;
       (((pcPtr[1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (pcPtr[1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
        (((pcPtr[1] == <span class="charliteral">&#39;+&#39;</span>) || (pcPtr[1] == <span class="charliteral">&#39;-&#39;</span>)) &amp;&amp;
         (pcPtr[2] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (pcPtr[2] &lt;= <span class="charliteral">&#39;9&#39;</span>))))
    {
        <span class="comment">//</span>
        <span class="comment">// Skip the &quot;e&quot;.</span>
        <span class="comment">//</span>
        pcPtr++;

        <span class="comment">//</span>
        <span class="comment">// Take a leading + or - from the exponenet.</span>
        <span class="comment">//</span>
        ulExpNeg = 0;
        <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;-&#39;</span>)
        {
            ulExpNeg = 1;
            pcPtr++;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;+&#39;</span>)
        {
            pcPtr++;
        }

        <span class="comment">//</span>
        <span class="comment">// Loop while there are valid digits in the exponent.</span>
        <span class="comment">//</span>
        ulExp = 0;
        <span class="keywordflow">while</span>((*pcPtr &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;9&#39;</span>))
        {
            <span class="comment">//</span>
            <span class="comment">// Add this digit to the converted value.</span>
            <span class="comment">//</span>
            ulExp *= 10;
            ulExp += *pcPtr++ - <span class="charliteral">&#39;0&#39;</span>;
        }

        <span class="comment">//</span>
        <span class="comment">// Raise ten to the power of the exponent.  Do this via binary</span>
        <span class="comment">// decomposition; for each binary bit set in the exponent, multiply the</span>
        <span class="comment">// floating-point representation by ten raised to that binary value</span>
        <span class="comment">// (extracted from the table above).</span>
        <span class="comment">//</span>
        fExp = 1;
        <span class="keywordflow">for</span>(ulIdx = 0; ulIdx &lt; 7; ulIdx++)
        {
            <span class="keywordflow">if</span>(ulExp &amp; (1 &lt;&lt; ulIdx))
            {
                fExp *= <a class="code" href="group__ustdlib__api.html#ga472f478db7f9e5884272a134b0211c3f">g_pfExponents</a>[ulIdx];
            }
        }

        <span class="comment">//</span>
        <span class="comment">// If the exponent is negative, then the exponent needs to be inverted.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(ulExpNeg == 1)
        {
            fExp = 1 / fExp;
        }

        <span class="comment">//</span>
        <span class="comment">// Multiply the result by the computed exponent value.</span>
        <span class="comment">//</span>
        fRet *= fExp;
    }

    <span class="comment">//</span>
    <span class="comment">// Set the return string pointer to the first character not consumed.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(endptr)
    {
        *endptr = ulValid ? pcPtr : nptr;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the converted value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ulNeg ? (0 - fRet) : fRet);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga643aaaee2316d5f31b9b4f62d169571a"></a><!-- doxytag: member="ustdlib.c::ustrtoul" ref="ga643aaaee2316d5f31b9b4f62d169571a" args="(const char *nptr, const char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="group__ustdlib__api.html#ga643aaaee2316d5f31b9b4f62d169571a">ustrtoul</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a string into its numeric equivalent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the integer. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the integer in the string. </td></tr>
    <tr><td class="paramname">base</td><td>is the radix to use for the conversion; can be zero to auto-select the radix or between 2 and 16 to explicitly specify the radix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtoul()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into an integer value.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the result of the conversion. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01104">1104</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulRet, ulDigit, ulNeg, ulValid;
    <span class="keyword">const</span> <span class="keywordtype">char</span> *pcPtr;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(nptr);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>((base == 0) || ((base &gt; 1) &amp;&amp; (base &lt;= 16)));

    <span class="comment">//</span>
    <span class="comment">// Initially, the result is zero.</span>
    <span class="comment">//</span>
    ulRet = 0;
    ulNeg = 0;
    ulValid = 0;

    <span class="comment">//</span>
    <span class="comment">// Skip past any leading white space.</span>
    <span class="comment">//</span>
    pcPtr = nptr;
    <span class="keywordflow">while</span>((*pcPtr == <span class="charliteral">&#39; &#39;</span>) || (*pcPtr == <span class="charliteral">&#39;\t&#39;</span>))
    {
        pcPtr++;
    }

    <span class="comment">//</span>
    <span class="comment">// Take a leading + or - from the value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;-&#39;</span>)
    {
        ulNeg = 1;
        pcPtr++;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;+&#39;</span>)
    {
        pcPtr++;
    }

    <span class="comment">//</span>
    <span class="comment">// See if the radix was not specified, or is 16, and the value starts with</span>
    <span class="comment">// &quot;0x&quot; or &quot;0X&quot; (to indicate a hex value).</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(((base == 0) || (base == 16)) &amp;&amp; (*pcPtr == <span class="charliteral">&#39;0&#39;</span>) &amp;&amp;
       ((pcPtr[1] == <span class="charliteral">&#39;x&#39;</span>) || (pcPtr[1] == <span class="charliteral">&#39;X&#39;</span>)))
    {
        <span class="comment">//</span>
        <span class="comment">// Skip the leading &quot;0x&quot;.</span>
        <span class="comment">//</span>
        pcPtr += 2;

        <span class="comment">//</span>
        <span class="comment">// Set the radix to 16.</span>
        <span class="comment">//</span>
        base = 16;
    }

    <span class="comment">//</span>
    <span class="comment">// See if the radix was not specified.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(base == 0)
    {
        <span class="comment">//</span>
        <span class="comment">// See if the value starts with &quot;0&quot;.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(*pcPtr == <span class="charliteral">&#39;0&#39;</span>)
        {
            <span class="comment">//</span>
            <span class="comment">// Values that start with &quot;0&quot; are assumed to be radix 8.</span>
            <span class="comment">//</span>
            base = 8;
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">//</span>
            <span class="comment">// Otherwise, the values are assumed to be radix 10.</span>
            <span class="comment">//</span>
            base = 10;
        }
    }

    <span class="comment">//</span>
    <span class="comment">// Loop while there are more valid digits to consume.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(1)
    {
        <span class="comment">//</span>
        <span class="comment">// See if this character is a number.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>((*pcPtr &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;9&#39;</span>))
        {
            <span class="comment">//</span>
            <span class="comment">// Convert the character to its integer equivalent.</span>
            <span class="comment">//</span>
            ulDigit = *pcPtr++ - <span class="charliteral">&#39;0&#39;</span>;
        }

        <span class="comment">//</span>
        <span class="comment">// Otherwise, see if this character is an upper case letter.</span>
        <span class="comment">//</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>((*pcPtr &gt;= <span class="charliteral">&#39;A&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;Z&#39;</span>))
        {
            <span class="comment">//</span>
            <span class="comment">// Convert the character to its integer equivalent.</span>
            <span class="comment">//</span>
            ulDigit = *pcPtr++ - <span class="charliteral">&#39;A&#39;</span> + 10;
        }

        <span class="comment">//</span>
        <span class="comment">// Otherwise, see if this character is a lower case letter.</span>
        <span class="comment">//</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>((*pcPtr &gt;= <span class="charliteral">&#39;a&#39;</span>) &amp;&amp; (*pcPtr &lt;= <span class="charliteral">&#39;z&#39;</span>))
        {
            <span class="comment">//</span>
            <span class="comment">// Convert the character to its integer equivalent.</span>
            <span class="comment">//</span>
            ulDigit = *pcPtr++ - <span class="charliteral">&#39;a&#39;</span> + 10;
        }

        <span class="comment">//</span>
        <span class="comment">// Otherwise, this is not a valid character.</span>
        <span class="comment">//</span>
        <span class="keywordflow">else</span>
        {
            <span class="comment">//</span>
            <span class="comment">// Stop converting this value.</span>
            <span class="comment">//</span>
            <span class="keywordflow">break</span>;
        }

        <span class="comment">//</span>
        <span class="comment">// See if this digit is valid for the chosen radix.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(ulDigit &gt;= base)
        {
            <span class="comment">//</span>
            <span class="comment">// Since this was not a valid digit, move the pointer back to the</span>
            <span class="comment">// character that therefore should not have been consumed.</span>
            <span class="comment">//</span>
            pcPtr--;

            <span class="comment">//</span>
            <span class="comment">// Stop converting this value.</span>
            <span class="comment">//</span>
            <span class="keywordflow">break</span>;
        }

        <span class="comment">//</span>
        <span class="comment">// Add this digit to the converted value.</span>
        <span class="comment">//</span>
        ulRet *= base;
        ulRet += ulDigit;

        <span class="comment">//</span>
        <span class="comment">// Since a digit has been added, this is now a valid result.</span>
        <span class="comment">//</span>
        ulValid = 1;
    }

    <span class="comment">//</span>
    <span class="comment">// Set the return string pointer to the first character not consumed.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(endptr)
    {
        *endptr = ulValid ? pcPtr : nptr;
    }

    <span class="comment">//</span>
    <span class="comment">// Return the converted value.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(ulNeg ? (0 - ulRet) : ulRet);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga4d2016620f37444cd039675cf8b25d70"></a><!-- doxytag: member="ustdlib.c::uvsnprintf" ref="ga4d2016620f37444cd039675cf8b25d70" args="(char *s, size_t n, const char *format, va_list arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__ustdlib__api.html#ga4d2016620f37444cd039675cf8b25d70">uvsnprintf</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple vsnprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">arg</td><td>is the list of optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vsnprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeroes instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The <em>n</em> parameter limits the number of characters that will be stored in the buffer pointed to by <em>s</em> to prevent the possibility of a buffer overflow. The buffer size should be large enough to hold the expected converted output string, including the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00158">158</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>References <a class="el" href="debug_8h_source.html#l00067">ASSERT</a>, <a class="el" href="ustdlib_8c_source.html#l00042">g_pcHex</a>, and <a class="el" href="ustdlib_8c_source.html#l00065">ustrncpy()</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l00809">usnprintf()</a>, and <a class="el" href="ustdlib_8c_source.html#l00731">usprintf()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ulIdx, ulValue, ulCount, ulBase, ulNeg;
    <span class="keywordtype">char</span> *pcStr, cFill;
    <span class="keywordtype">int</span> iConvertCount = 0;

    <span class="comment">//</span>
    <span class="comment">// Check the arguments.</span>
    <span class="comment">//</span>
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(s);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(n);
    <a class="code" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>(format);

    <span class="comment">//</span>
    <span class="comment">// Adjust buffer size limit to allow one space for null termination.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span>(n)
    {
        n--;
    }

    <span class="comment">//</span>
    <span class="comment">// Initialize the count of characters converted.</span>
    <span class="comment">//</span>
    iConvertCount = 0;

    <span class="comment">//</span>
    <span class="comment">// Loop while there are more characters in the format string.</span>
    <span class="comment">//</span>
    <span class="keywordflow">while</span>(*format)
    {
        <span class="comment">//</span>
        <span class="comment">// Find the first non-% character, or the end of the string.</span>
        <span class="comment">//</span>
        <span class="keywordflow">for</span>(ulIdx = 0; (format[ulIdx] != <span class="charliteral">&#39;%&#39;</span>) &amp;&amp; (format[ulIdx] != <span class="charliteral">&#39;\0&#39;</span>);
            ulIdx++)
        {
        }

        <span class="comment">//</span>
        <span class="comment">// Write this portion of the string to the output buffer.  If there are</span>
        <span class="comment">// more characters to write than there is space in the buffer, then</span>
        <span class="comment">// only write as much as will fit in the buffer.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(ulIdx &gt; n)
        {
            <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, format, n);
            s += n;
            n = 0;
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, format, ulIdx);
            s += ulIdx;
            n -= ulIdx;
        }

        <span class="comment">//</span>
        <span class="comment">// Update the conversion count.  This will be the number of characters</span>
        <span class="comment">// that should have been written, even if there was not room in the</span>
        <span class="comment">// buffer.</span>
        <span class="comment">//</span>
        iConvertCount += ulIdx;

        <span class="comment">//</span>
        <span class="comment">// Skip the portion of the format string that was written.</span>
        <span class="comment">//</span>
        format += ulIdx;

        <span class="comment">//</span>
        <span class="comment">// See if the next character is a %.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span>(*format == <span class="charliteral">&#39;%&#39;</span>)
        {
            <span class="comment">//</span>
            <span class="comment">// Skip the %.</span>
            <span class="comment">//</span>
            format++;

            <span class="comment">//</span>
            <span class="comment">// Set the digit count to zero, and the fill character to space</span>
            <span class="comment">// (that is, to the defaults).</span>
            <span class="comment">//</span>
            ulCount = 0;
            cFill = <span class="charliteral">&#39; &#39;</span>;

            <span class="comment">//</span>
            <span class="comment">// It may be necessary to get back here to process more characters.</span>
            <span class="comment">// Goto&#39;s aren&#39;t pretty, but effective.  I feel extremely dirty for</span>
            <span class="comment">// using not one but two of the beasts.</span>
            <span class="comment">//</span>
again:

            <span class="comment">//</span>
            <span class="comment">// Determine how to handle the next character.</span>
            <span class="comment">//</span>
            <span class="keywordflow">switch</span>(*format++)
            {
                <span class="comment">//</span>
                <span class="comment">// Handle the digit characters.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;2&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;3&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;4&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;5&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;6&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;7&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;8&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;9&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// If this is a zero, and it is the first digit, then the</span>
                    <span class="comment">// fill character is a zero instead of a space.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>((format[-1] == <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (ulCount == 0))
                    {
                        cFill = <span class="charliteral">&#39;0&#39;</span>;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the digit count.</span>
                    <span class="comment">//</span>
                    ulCount *= 10;
                    ulCount += format[-1] - <span class="charliteral">&#39;0&#39;</span>;

                    <span class="comment">//</span>
                    <span class="comment">// Get the next character.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">goto</span> again;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %c command.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Get the value from the varargs.</span>
                    <span class="comment">//</span>
                    ulValue = va_arg(arg, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);

                    <span class="comment">//</span>
                    <span class="comment">// Copy the character to the output buffer, if there is</span>
                    <span class="comment">// room.  Update the buffer size remaining.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(n != 0)
                    {
                        *s++ = (char)ulValue;
                        n--;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the conversion count.</span>
                    <span class="comment">//</span>
                    iConvertCount++;

                    <span class="comment">//</span>
                    <span class="comment">// This command has been handled.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">break</span>;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %d and %i commands.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;d&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;i&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Get the value from the varargs.</span>
                    <span class="comment">//</span>
                    ulValue = va_arg(arg, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);

                    <span class="comment">//</span>
                    <span class="comment">// If the value is negative, make it positive and indicate</span>
                    <span class="comment">// that a minus sign is needed.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>((<span class="keywordtype">long</span>)ulValue &lt; 0)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Make the value positive.</span>
                        <span class="comment">//</span>
                        ulValue = -(long)ulValue;

                        <span class="comment">//</span>
                        <span class="comment">// Indicate that the value is negative.</span>
                        <span class="comment">//</span>
                        ulNeg = 1;
                    }
                    <span class="keywordflow">else</span>
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Indicate that the value is positive so that a</span>
                        <span class="comment">// negative sign isn&#39;t inserted.</span>
                        <span class="comment">//</span>
                        ulNeg = 0;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Set the base to 10.</span>
                    <span class="comment">//</span>
                    ulBase = 10;

                    <span class="comment">//</span>
                    <span class="comment">// Convert the value to ASCII.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">goto</span> convert;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %s command.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Get the string pointer from the varargs.</span>
                    <span class="comment">//</span>
                    pcStr = va_arg(arg, <span class="keywordtype">char</span> *);

                    <span class="comment">//</span>
                    <span class="comment">// Determine the length of the string.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">for</span>(ulIdx = 0; pcStr[ulIdx] != <span class="charliteral">&#39;\0&#39;</span>; ulIdx++)
                    {
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the convert count to include any padding that</span>
                    <span class="comment">// should be necessary (regardless of whether we have space</span>
                    <span class="comment">// to write it or not).</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ulCount &gt; ulIdx)
                    {
                        iConvertCount += (ulCount - ulIdx);
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Copy the string to the output buffer.  Only copy as much</span>
                    <span class="comment">// as will fit in the buffer.  Update the output buffer</span>
                    <span class="comment">// pointer and the space remaining.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ulIdx &gt; n)
                    {
                        <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, pcStr, n);
                        s += n;
                        n = 0;
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, pcStr, ulIdx);
                        s += ulIdx;
                        n -= ulIdx;

                        <span class="comment">//</span>
                        <span class="comment">// Write any required padding spaces assuming there is</span>
                        <span class="comment">// still space in the buffer.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">if</span>(ulCount &gt; ulIdx)
                        {
                            ulCount -= ulIdx;
                            <span class="keywordflow">if</span>(ulCount &gt; n)
                            {
                                ulCount = n;
                            }
                            n = -ulCount;

                            <span class="keywordflow">while</span>(ulCount--)
                            {
                                *s++ = <span class="charliteral">&#39; &#39;</span>;
                            }
                        }
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the conversion count.  This will be the number of</span>
                    <span class="comment">// characters that should have been written, even if there</span>
                    <span class="comment">// was not room in the buffer.</span>
                    <span class="comment">//</span>
                    iConvertCount += ulIdx;

                    <span class="comment">//</span>
                    <span class="comment">// This command has been handled.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">break</span>;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %u command.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;u&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Get the value from the varargs.</span>
                    <span class="comment">//</span>
                    ulValue = va_arg(arg, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);

                    <span class="comment">//</span>
                    <span class="comment">// Set the base to 10.</span>
                    <span class="comment">//</span>
                    ulBase = 10;

                    <span class="comment">//</span>
                    <span class="comment">// Indicate that the value is positive so that a minus sign</span>
                    <span class="comment">// isn&#39;t inserted.</span>
                    <span class="comment">//</span>
                    ulNeg = 0;

                    <span class="comment">//</span>
                    <span class="comment">// Convert the value to ASCII.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">goto</span> convert;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %x and %X commands.  Note that they are treated</span>
                <span class="comment">// identically; that is, %X will use lower case letters for a-f</span>
                <span class="comment">// instead of the upper case letters is should use.  We also</span>
                <span class="comment">// alias %p to %x.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;x&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;X&#39;</span>:
                <span class="keywordflow">case</span> <span class="charliteral">&#39;p&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Get the value from the varargs.</span>
                    <span class="comment">//</span>
                    ulValue = va_arg(arg, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);

                    <span class="comment">//</span>
                    <span class="comment">// Set the base to 16.</span>
                    <span class="comment">//</span>
                    ulBase = 16;

                    <span class="comment">//</span>
                    <span class="comment">// Indicate that the value is positive so that a minus sign</span>
                    <span class="comment">// isn&#39;t inserted.</span>
                    <span class="comment">//</span>
                    ulNeg = 0;

                    <span class="comment">//</span>
                    <span class="comment">// Determine the number of digits in the string version of</span>
                    <span class="comment">// the value.</span>
                    <span class="comment">//</span>
convert:
                    <span class="keywordflow">for</span>(ulIdx = 1;
                        (((ulIdx * ulBase) &lt;= ulValue) &amp;&amp;
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
                        ulIdx *= ulBase, ulCount--)
                    {
                    }

                    <span class="comment">//</span>
                    <span class="comment">// If the value is negative, reduce the count of padding</span>
                    <span class="comment">// characters needed.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ulNeg)
                    {
                        ulCount--;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// If the value is negative and the value is padded with</span>
                    <span class="comment">// zeros, then place the minus sign before the padding.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ulNeg &amp;&amp; (n != 0) &amp;&amp; (cFill == <span class="charliteral">&#39;0&#39;</span>))
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Place the minus sign in the output buffer.</span>
                        <span class="comment">//</span>
                        *s++ = <span class="charliteral">&#39;-&#39;</span>;
                        n--;

                        <span class="comment">//</span>
                        <span class="comment">// Update the conversion count.</span>
                        <span class="comment">//</span>
                        iConvertCount++;

                        <span class="comment">//</span>
                        <span class="comment">// The minus sign has been placed, so turn off the</span>
                        <span class="comment">// negative flag.</span>
                        <span class="comment">//</span>
                        ulNeg = 0;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// See if there are more characters in the specified field</span>
                    <span class="comment">// width than there are in the conversion of this value.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>((ulCount &gt; 1) &amp;&amp; (ulCount &lt; 65536))
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Loop through the required padding characters.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">for</span>(ulCount--; ulCount; ulCount--)
                        {
                            <span class="comment">//</span>
                            <span class="comment">// Copy the character to the output buffer if there</span>
                            <span class="comment">// is room.</span>
                            <span class="comment">//</span>
                            <span class="keywordflow">if</span>(n != 0)
                            {
                                *s++ = cFill;
                                n--;
                            }

                            <span class="comment">//</span>
                            <span class="comment">// Update the conversion count.</span>
                            <span class="comment">//</span>
                            iConvertCount++;
                        }
                    }

                    <span class="comment">//</span>
                    <span class="comment">// If the value is negative, then place the minus sign</span>
                    <span class="comment">// before the number.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(ulNeg &amp;&amp; (n != 0))
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Place the minus sign in the output buffer.</span>
                        <span class="comment">//</span>
                        *s++ = <span class="charliteral">&#39;-&#39;</span>;
                        n--;

                        <span class="comment">//</span>
                        <span class="comment">// Update the conversion count.</span>
                        <span class="comment">//</span>
                        iConvertCount++;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Convert the value into a string.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">for</span>(; ulIdx; ulIdx /= ulBase)
                    {
                        <span class="comment">//</span>
                        <span class="comment">// Copy the character to the output buffer if there is</span>
                        <span class="comment">// room.</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">if</span>(n != 0)
                        {
                            *s++ = <a class="code" href="group__ustdlib__api.html#gae2ac426587be82ba1a5b5eed7067fd0c">g_pcHex</a>[(ulValue / ulIdx) % ulBase];
                            n--;
                        }

                        <span class="comment">//</span>
                        <span class="comment">// Update the conversion count.</span>
                        <span class="comment">//</span>
                        iConvertCount++;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// This command has been handled.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">break</span>;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle the %% command.</span>
                <span class="comment">//</span>
                <span class="keywordflow">case</span> <span class="charliteral">&#39;%&#39;</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Simply write a single %.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(n != 0)
                    {
                        *s++ = format[-1];
                        n--;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the conversion count.</span>
                    <span class="comment">//</span>
                    iConvertCount++;

                    <span class="comment">//</span>
                    <span class="comment">// This command has been handled.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">break</span>;
                }

                <span class="comment">//</span>
                <span class="comment">// Handle all other commands.</span>
                <span class="comment">//</span>
                <span class="keywordflow">default</span>:
                {
                    <span class="comment">//</span>
                    <span class="comment">// Indicate an error.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">if</span>(n &gt;= 5)
                    {
                        <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, <span class="stringliteral">&quot;ERROR&quot;</span>, 5);
                        s += 5;
                        n -= 5;
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc">ustrncpy</a>(s, <span class="stringliteral">&quot;ERROR&quot;</span>, n);
                        s += n;
                        n = 0;
                    }

                    <span class="comment">//</span>
                    <span class="comment">// Update the conversion count.</span>
                    <span class="comment">//</span>
                    iConvertCount += 5;

                    <span class="comment">//</span>
                    <span class="comment">// This command has been handled.</span>
                    <span class="comment">//</span>
                    <span class="keywordflow">break</span>;
                }
            }
        }
    }

    <span class="comment">//</span>
    <span class="comment">// Null terminate the string in the buffer.</span>
    <span class="comment">//</span>
    *s = 0;

    <span class="comment">//</span>
    <span class="comment">// Return the number of characters in the full converted string.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span>(iConvertCount);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_cgraph.png" border="0" usemap="#group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_cgraph" alt=""/></div>
<map name="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_cgraph" id="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_cgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#ga9c6b6efcdd76a057125b6e580d0b47fc" title="ustrncpy" alt="" coords="133,5,205,35"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_icgraph.png" border="0" usemap="#group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_icgraph" alt=""/></div>
<map name="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_icgraph" id="group__ustdlib__api_ga4d2016620f37444cd039675cf8b25d70_icgraph">
<area shape="rect" id="node3" href="group__ustdlib__api.html#gabba09d3e2aec8902cd6c72c79d364dac" title="usnprintf" alt="" coords="133,5,205,35"/><area shape="rect" id="node5" href="group__ustdlib__api.html#ga43a285f04c8bcd68ddb8a16ca4f4a43c" title="usprintf" alt="" coords="137,59,201,88"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gaa1c0e31c29613a8c1efeec6604eace42"></a><!-- doxytag: member="ustdlib.c::g_iRandomSeed" ref="gaa1c0e31c29613a8c1efeec6604eace42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="group__ustdlib__api.html#gaa1c0e31c29613a8c1efeec6604eace42">g_iRandomSeed</a> = 1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01774">1774</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01806">urand()</a>, and <a class="el" href="ustdlib_8c_source.html#l01790">usrand()</a>.</p>

</div>
</div>
<a class="anchor" id="gae2ac426587be82ba1a5b5eed7067fd0c"></a><!-- doxytag: member="ustdlib.c::g_pcHex" ref="gae2ac426587be82ba1a5b5eed7067fd0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const <a class="el" href="group__ustdlib__api.html#gae2ac426587be82ba1a5b5eed7067fd0c">g_pcHex</a> = &quot;0123456789abcdef&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00042">42</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l00158">uvsnprintf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga472f478db7f9e5884272a134b0211c3f"></a><!-- doxytag: member="ustdlib.c::g_pfExponents" ref="ga472f478db7f9e5884272a134b0211c3f" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float <a class="el" href="group__ustdlib__api.html#ga472f478db7f9e5884272a134b0211c3f">g_pfExponents</a>[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
{
    1.0e+01,
    1.0e+02,
    1.0e+04,
    1.0e+08,
    1.0e+16,
    1.0e+32,
}
</pre></div>
<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l01285">1285</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l01313">ustrtof()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7317c745b34e7997a57fc64a28fc74a8"></a><!-- doxytag: member="ustdlib.c::g_psDaysToMonth" ref="ga7317c745b34e7997a57fc64a28fc74a8" args="[12]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const time_t <a class="el" href="group__ustdlib__api.html#ga7317c745b34e7997a57fc64a28fc74a8">g_psDaysToMonth</a>[12]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
{
    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
}
</pre></div>
<p>Definition at line <a class="el" href="ustdlib_8c_source.html#l00841">841</a> of file <a class="el" href="ustdlib_8c_source.html">ustdlib.c</a>.</p>

<p>Referenced by <a class="el" href="ustdlib_8c_source.html#l00862">ulocaltime()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jan 27 2015 22:02:21 for EE445M Real Time Operating Systems by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
