#+startup: sections
#+options: H:1 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:nil LaTeX:t
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) BLOCKED(r) | OPTIONAL(o) HIATUS(h) DONE(d) CANCELED(c)
#+author: Hershal Bhave
#+author: Eric Crosson
* [12/12] Lab 1
** [3/3] lcd driver
*** DONE contains logically separate displays
     use a horizontal split
*** DONE 4+ lines per display
*** DONE API to write to displays individually
** [3/3] adc driver
*** DONE samples from 100 - 10,000 Hz
*** DONE samples from ADC0 - ADC11
*** DONE have 1 to 1 abilities as this api
    #+BEGIN_SRC c
      unsigned short ADC_In(void);
      int ADC_Open(unsigned int channelNum);
      int ADC_Collect(unsigned int channelNum, unsigned int fs,
                      unsigned short buffer[], unsigned int numberOfSamples);
    #+END_SRC
** [5/5] interpreter
*** DONE uart port
*** DONE interrupts
*** OPTIONAL hardware fifo
*** DONE software fifo x2
*** DONE the below mojo
  Use the stdio library and remap the serial stream to the UART. See the
  =retarget.c= file in the =Keil\ARM\Boards\Keil\MCBSTM32\Blinky= project
  included in the Keil installation. In particular, you need to create a
  fputc function like this:
  #+BEGIN_SRC c
    int fputc(int ch, FILE *f){
      UART0_OutChar(ch);
      return (1);
    }
    int fgetc (FILE *f){
      return (UART0_InChar());
    }
    int ferror(FILE *f){
    /* Your implementation of ferror */
      return EOF;
    }
  #+END_SRC
** DONE Checkout
- demonstrate measuring of timer2 ISR overhead
- be prepared to field questions addressing interrupts/FIFOs
- demonstrate each interpreter command
- show screen displaying two stuffs
* [6/14] Lab 2
** [6/6] Part 1
Demonstrate each of the following
*** DONE Testmain1
- needs cooperative thread scheduler without interrupts

  Meaning: create method =OS_Suspend= that, when called, transfers
  control from the current thread to the next waiting thread.

  This will be the sole method of thread switching in this program.

  #+NAME: Testmain1
  #+CAPTION: Test system for cooperative thread switching
  #+BEGIN_SRC c :tangle no
    unsigned long Count1; // number of times thread1 loops
    unsigned long Count2; // number of times thread2 loops
    unsigned long Count3; // number of times thread3 loops
    void Thread1(void){
      Count1 = 0;
      for(;;){
        PE0 ^= 0x01;      // heartbeat
        Count1++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    void Thread2(void){
      Count2 = 0;
      for(;;){
        PE1 ^= 0x02;      // heartbeat
        Count2++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    void Thread3(void){
      Count3 = 0;
      for(;;){
        // PE2 ^= 0x04;      // heartbeat
        PE3 ^= 0x08;      // heartbeat
        Count3++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    int main(void){
      OS_Init();    // initialize, disable interrupts
      PortE_Init(); // profile user threads
      NumCreated = 0 ;
      NumCreated += OS_AddThread(&Thread1,128,1);
      NumCreated += OS_AddThread(&Thread2,128,2);
      NumCreated += OS_AddThread(&Thread3,128,3);
      // Count1 = Count2 = Count3 (or off by one) at all times
      OS_Launch(TIME_2MS); // doesn't return, interrupts enabled in here
      return 0;            // this never executes
    }
 #+END_SRC
*** DONE Testmain2
- preemptive thread scheduler with SysTick interrupts

  SysTick suspends the running thread and begins the next active
  thread in the list with a round robin fashion.

  #+NAME: Testmain2
  #+CAPTION: Test system for preemptive thread switching
  #+BEGIN_SRC c :tangle no
    void Thread1b(void){
      Count1 = 0;
      for(;;){
        PE0 ^= 0x01;    // heartbeat
        Count1++;
      }
    }
    void Thread2b(void){
      Count2 = 0;
      for(;;){
        PE1 ^= 0x02;    // heartbeat
        Count2++;
      }
    }
    void Thread3b(void){
      Count3 = 0;
      for(;;){
        PE2 ^= 0x04;    // heartbeat
        Count3++;
      }
    }
    int Testmain2(void){
      OS_Init();    // initialize, disable interrupts
      PortE_Init(); // profile user threads
      NumCreated = 0 ;
      NumCreated += OS_AddThread(&Thread1b,128,1);
      NumCreated += OS_AddThread(&Thread2b,128,2);
      NumCreated += OS_AddThread(&Thread3b,128,3);
      // Count1 = Count2 = Count3 on average
      // Notice: counts are larger than testmain1. Why is this?
      OS_Launch(TIME_2MS); // doesn't return, interrupts enabled in here
      return 0;            // this never executes
    }
  #+END_SRC
*** DONE Testmain7
I don't think a description of this main program was included in
the lab manual.

*** DONE OS_Launch
*** DONE Context switching
**** init
1. Give =PendSV= handler lowest priority
**** action
1. SysTick interrupt fires
   1. prepare for context switching
   2. pend the =PendSV= exception
      [[./img/pendsv_context_switch.png]]
2. Enter =PendSV=
   1. do context switch
      The exception sequence (that landed you in the =PendSV= handler)
      has saved R0-R3, R12, LR, PC, xPSR. Thus, =PendSV= is only
      responsible for storing R4-R11 to the process stack.
*** DONE Checkout
<2015-02-16 Mon 10:30>
** [0/7] Part 2
Your job is to design, implement and test operating system commands
that implement a multiple thread environment.

Note: The word task in this lab is not a formal term, rather a general
description of an overall function implemented with a combination of
hardware, background threads (ISR), and foreground threads (main
programs).
*** TODO test libsemaphore
- call =os_signal= from a periodic interrupt
- call =os_wait= in the main loop and watch the loop step after =os_signal=
*** [1/2] profiling compile-time flag
- [X] compiles minimally intrusive pin-toggling code to
identify when and what tcb is running
- [ ] measure PIDWork with and without the profiling code
*** [0/2] guarantee UART never loses data
- [ ] stress test :: Hammer it and increase the capacity until no chars
                 are dropped from libuart or libshell
- [ ] profile ::  Create a table like Table 2.1 in [[./Lab02.pdf]]
*** IN-PROGRESS make callback to task scheduler explicit
*** TODO Task 1 : Software triggered data acquisition and filtering
What's the AR? I have no idea.
**** notes
For the data acquisition system DAS, the software must start the
analog-to-digital converter (ADC) and read the result at precise time
intervals.

In Labs 2 and 3, f_s is 2 kHz.

I don't know what the fuck this page is asking me to do.
*** IN-PROGRESS Task 2 : Aperiodic task triggered by the select switch
A background thread =ButtonPush= should be run whenever the user touches
the select button. This task will create a foreground thread that:

1. outputs to the LCD,
2. sleeps for 50ms,
3. outputs again to the LCD, then
4. kills itself

Note: if the user pushes the button faster than once every two
seconds, multiple foreground threads will exist simultaneously.
*** IN-PROGRESS Task 3 : Hardware triggered data acquisition and FFT
This task will sample the ADC every 400 Hz (2.5 ms) via a
hardware-triggered timer.

1. start collecting data (takes 64 ms)
2. fft on the block, when done trigger interrupt
3. ADC ISR (=producer=) pushes with =OS_Fifo_Put= into global mem space
4. =Consumer= foreground thread calculates the FFT
   question: so the fft is calculated twice? once by us once by
   hardware?

*Note*: you *must* use 16-bit mode for timer-triggered adc sampling.
*** IN-PROGRESS Task 4 : CPU Bound task
- increment PIDWork (global var) continually
- reset it to 0 each time you are granted foreground
- try to maximize high water mark of PIDWork
*** IN-PROGRESS Task 5 : User interface with a command line interpreter
- use libshell developed in Lab 1
**** IN-PROGRESS answer esc's questions
[[../../lib/libshell/shell.c]]
All invocations to uart_send are through uart.h. Should this be to
libhw, who then queues it? Is this thread-save? is libuart?
- I guess so, uart sends chars with an interrupt, doesn't it? pendsv
  won't interrupt it IF WE SENT PENDSV CORRECTLY. The way we're
  heading, we'll need a TxFIFO won't we?
*** [0/4] Checkout
- [ ] Run the software system and explain the profiling data to the TA
- [ ] Discuss the sketches you created as part of prep & procedure
- [ ] Discuss the TCB before and after a thread switch
- [ ] Identify inefficiencies in your implementation
*** [3/3] Deliverables
- 20 points :: report
- 10 points :: software quality

- [X] objectives :: 1/2 page max
- [X] hardware design :: none
- [X] software design :: spinlock/round-robin switching source
- [6/6] measurement data :: graphs and tables of data
  - [X] plots of the logic analyzer
     see Figures 2.1, 2.2, 2.3, 2.4, and 2.8
  - [X] measurement of the thread-switch time
  - [X] plot of the logic analyzer running spinlock/round-robin
  - [X] the four sketches with measured data collected during testing
     from first preparation parts 3 and 5
  - [X] a table each showing performance measurements versus sizes of
     OS_Fifo and timeslices
     like Table 2.1
  - [X] table showing performance measurements with/without debugging instruments
- [7/7] analysis and discussion :: 2 page maximum
  - [X] Why did the time jitter in my solution jump from 4 to 6 Î¼s when
     interpreter I/O occurred?
  - [X] Justify why Task 3 has no time jitter on its ADC sampling.
  - [X] There are four (or more) interrupts in this system DAS, ADC,
     Select, and SysTick (thread switch).
     Justify your choice of hardware priorities in the NVIC?
  - [X] Explain what happens if your stack size is too small.
     How could you detect stack overflow? How could you prevent stack overflow from crashing the OS?
  - [X] Both Consumer and Display have an OS_Kill() at the end. Do these
     OS_Kills always execute, sometime execute, or never execute?
     Explain.
  - [X] The interaction between the producer and consumer is
     deterministic. What does deterministic mean?
    - Assume for this question that if the OS_Fifo has 5 elements data
    is lost, but if it has 6 elements no data is lost.
    - What does this tell you about the timing of the consumer plus display?
  - [X] Without going back and actually measuring it, do you think the
     Consumer ever waits when it calls OS_MailBox_Send?
     Explain.
* [3/10] Lab 3
** [1/5] Preparation
*** TODO Add a priority field to =OS_AddPeriodicThread=
**** Valvano
Consider at least two ways to implement the second periodic background
thread. A priority parameter in the OS_AddPeriodicThread function
allows the user to specify the relative priority of the four
background threads.  This priority does not affect the fact that all
background threads (two periodic, two aperiodic) will preempt any
foreground thread. In this lab, OS_AddPeriodicThread will be called 0,
1, or 2 times. Think about how would your implementation be different
if there were 10 background threads? Write C code to implement this
new expanded periodic thread feature.
**** Decrypted
We already have a way to start periodic threads, this just means we
need to rebuild libhw as a threading daemon.
*** DONE Add libjitter
**** DONE Add profiling functionality to os
PendSV needs to record the SysTick before and after thread switch to
determine the amount of thread-time jitter. Maybe have each thread
record these jitter values? Not sure how to library-ize this...
**** Valvano
Add features to the OS to measure and record time jitters for the two
periodic threads. Record two maximum jitters and two histograms of
jitter values. In particular, move the jitter measurements from Lab2
into the OS, and make two copies of it. Feel free to change any of the
user code in Lab2.c so they are compatible with your RTOS.
**** Decrypted
Add libjitter, which just keeps a running average and/or buffer of
pidwork values. Research SV (System Service Call).
*** BLOCKED [3/4] Aperiodic background thread triggered on button press
**** TODO Create priority threads
**** DONE Create single-shot threads
**** DONE Button Detection
**** DONE Button Debouncing
**** Valvano
Write C code to implement the second aperiodic background thread,
triggered by a falling edge on PF0. In hardware this is implemented
with the SW2 button. On the robot, you could add a bumper switch and
use this feature to detect collisions. Your OS should allow the user
to activate and arm this feature by passing a user function to
execute, and using the external event mechanism to trigger the
background task. You should also provide an OS function to disarm this
feature. The priority parameters for OS_AddPeriodicThread
OS_AddSW1Task and OS_AddSW2Task allow the user to specify the relative
priority of the four background threads.
**** Decrypted
Basically, get libhw working and make libbutton generalized to work on
any gpio (it's almost there).
*** TODO Implement a counting semaphore
**** Valvano
Consider at least two ways to implement blocking semaphores. In this
class, we have 1 to 10 foreground threads.  How would your
implementation be different if there were 100 foreground threads?
Write C code to implement the blocking semaphores. Take one of the
test programs from Lab2.c and modify it to test the blocking
semaphores. In particular, there should be multiple threads signaling
the same semaphore, and multiple threads waiting on that same
semaphore. You should signal both in the background and in the
foreground, but you can only wait in the foreground. Use counters to
make verify the total number of times signal is called matches the
total number of times wait allows a thread to pass. The key is to run
the system in an exhaustive manner increasing the likelihood of
finding bugs. For example, if there is a 1 in 10 4 chance of Condition
A occurring (e.g., PC is executing at a particular spot) and a 1 in 10
4 chance of Condition B occurring, there will be a 1 in 10 8 chance of
Conditions A and B occurring at the same time. You also have to be
careful not to introduce critical sections in the test program itself.
Edit Lab2.c so it is compatible with your RTOS. Modify the numbers in
Signal2() so that the period of this thread is variable.
**** Decrypted
Make a counting semaphore.
*** TODO Consider how to implement a priority scheduler
**** Valvano
Consider at least two ways to implement the priority scheduler. Again,
think about how would your implementation be different if there were
100 foreground threads? Write C code to implement the priority
scheduler.
**** Decrypted
Think about how to implement a priority scheduler. Then implement it.
** Lab Session Notes
- adc sampling at 2 khz
  follow the figure 2.4
- another thread for the serial
- a thread to update the lcd with adc data
- jitter: defined as time past 2khz goal

- task: display threadcount to lcd, watch it increase with button-created threads
- fft to smash the cpu and increase jitter
- task 4/5: from starter code. also to smash cpu for jitter
* [0/1] Lab 4
** TODO [0/4] preparation
*** TODO analog interface design/low-pass filter                  :hershal:
- use either excel or filterpro (probably filterpro will be easier,
  windows-only), to design an analog low-pass filter
  - 1kHz analog filter specs:
    - 2x TI TLC2272ACP :: rail-to-fail dual op-amp
    - 2x 10 nF Capacitor
    - 12.4 kOhm Resistor
    - 16.8 kOhm Resistor
    - 12 nF Capacitor
    - 4.220 kOhm Resistor
    - 7.870 kOhm Resistor
    - 68 nF Capacitor
*** TODO real time data acquisition                               :hershal:
- use the adc to sample data from the ir sensor
**** TODO add interpreter commands:                                 :eric:
  - enable/disable sampling
  - enable/disable filtering
  - print out the raw/filtered adc data
*** TODO design a FIR filter
- design a digial FIR filter to condition the signal
*** TODO plot the data on the lcd                                    :eric:
- plot either:
  - voltage vs. time
  - voltage vs. frequency
- plots modes switchable by interpreter commands
