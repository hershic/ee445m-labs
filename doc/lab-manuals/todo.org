#+startup: sections
#+options: H:1 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:nil LaTeX:t
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) CANCELED(c)
#+author: Hershal Bhave
#+author: Eric Crosson
* [12/12] Lab 1
** [3/3] lcd driver
*** DONE contains logically separate displays
     use a horizontal split
*** DONE 4+ lines per display
*** DONE API to write to displays individually
** [3/3] adc driver
*** DONE samples from 100 - 10,000 Hz
*** DONE samples from ADC0 - ADC11
*** DONE have 1 to 1 abilities as this api
    #+BEGIN_SRC c
      unsigned short ADC_In(void);
      int ADC_Open(unsigned int channelNum);
      int ADC_Collect(unsigned int channelNum, unsigned int fs,
                      unsigned short buffer[], unsigned int numberOfSamples);
    #+END_SRC
** [5/5] interpreter
*** DONE uart port
*** DONE interrupts
*** OPTIONAL hardware fifo
*** DONE software fifo x2
*** DONE the below mojo
  Use the stdio library and remap the serial stream to the UART. See the
  =retarget.c= file in the =Keil\ARM\Boards\Keil\MCBSTM32\Blinky= project
  included in the Keil installation. In particular, you need to create a
  fputc function like this:
  #+BEGIN_SRC c
    int fputc(int ch, FILE *f){
      UART0_OutChar(ch);
      return (1);
    }
    int fgetc (FILE *f){
      return (UART0_InChar());
    }
    int ferror(FILE *f){
    /* Your implementation of ferror */
      return EOF;
    }
  #+END_SRC
** DONE Checkout
- demonstrate measuring of timer2 ISR overhead
- be prepared to field questions addressing interrupts/FIFOs
- demonstrate each interpreter command
- show screen displaying two stuffs
* [6/14] Lab 2
** [6/6] Part 1
Demonstrate each of the following
*** DONE Testmain1
- needs cooperative thread scheduler without interrupts

  Meaning: create method =OS_Suspend= that, when called, transfers
  control from the current thread to the next waiting thread.

  This will be the sole method of thread switching in this program.

  #+NAME: Testmain1
  #+CAPTION: Test system for cooperative thread switching
  #+BEGIN_SRC c :tangle no
    unsigned long Count1; // number of times thread1 loops
    unsigned long Count2; // number of times thread2 loops
    unsigned long Count3; // number of times thread3 loops
    void Thread1(void){
      Count1 = 0;
      for(;;){
        PE0 ^= 0x01;      // heartbeat
        Count1++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    void Thread2(void){
      Count2 = 0;
      for(;;){
        PE1 ^= 0x02;      // heartbeat
        Count2++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    void Thread3(void){
      Count3 = 0;
      for(;;){
        // PE2 ^= 0x04;      // heartbeat
        PE3 ^= 0x08;      // heartbeat
        Count3++;
        OS_Suspend();     // cooperative multitasking
      }
    }
    int main(void){
      OS_Init();    // initialize, disable interrupts
      PortE_Init(); // profile user threads
      NumCreated = 0 ;
      NumCreated += OS_AddThread(&Thread1,128,1);
      NumCreated += OS_AddThread(&Thread2,128,2);
      NumCreated += OS_AddThread(&Thread3,128,3);
      // Count1 = Count2 = Count3 (or off by one) at all times
      OS_Launch(TIME_2MS); // doesn't return, interrupts enabled in here
      return 0;            // this never executes
    }
 #+END_SRC
*** DONE Testmain2
- preemptive thread scheduler with SysTick interrupts

  SysTick suspends the running thread and begins the next active
  thread in the list with a round robin fashion.

  #+NAME: Testmain2
  #+CAPTION: Test system for preemptive thread switching
  #+BEGIN_SRC c :tangle no
    void Thread1b(void){
      Count1 = 0;
      for(;;){
        PE0 ^= 0x01;    // heartbeat
        Count1++;
      }
    }
    void Thread2b(void){
      Count2 = 0;
      for(;;){
        PE1 ^= 0x02;    // heartbeat
        Count2++;
      }
    }
    void Thread3b(void){
      Count3 = 0;
      for(;;){
        PE2 ^= 0x04;    // heartbeat
        Count3++;
      }
    }
    int Testmain2(void){
      OS_Init();    // initialize, disable interrupts
      PortE_Init(); // profile user threads
      NumCreated = 0 ;
      NumCreated += OS_AddThread(&Thread1b,128,1);
      NumCreated += OS_AddThread(&Thread2b,128,2);
      NumCreated += OS_AddThread(&Thread3b,128,3);
      // Count1 = Count2 = Count3 on average
      // Notice: counts are larger than testmain1. Why is this?
      OS_Launch(TIME_2MS); // doesn't return, interrupts enabled in here
      return 0;            // this never executes
    }
  #+END_SRC
*** DONE Testmain7
I don't think a description of this main program was included in
the lab manual.

*** DONE OS_Launch
*** DONE Context switching
**** init
1. Give =PendSV= handler lowest priority
**** action
1. SysTick interrupt fires
   1. prepare for context switching
   2. pend the =PendSV= exception
      [[./img/pendsv_context_switch.png]]
2. Enter =PendSV=
   1. do context switch
      The exception sequence (that landed you in the =PendSV= handler)
      has saved R0-R3, R12, LR, PC, xPSR. Thus, =PendSV= is only
      responsible for storing R4-R11 to the process stack.
*** DONE Checkout
<2015-02-16 Mon 10:30>
** [0/8] Part 2
Your job is to design, implement and test operating system commands
that implement a multiple thread environment.

Note: The word task in this lab is not a formal term, rather a general
description of an overall function implemented with a combination of
hardware, background threads (ISR), and foreground threads (main
programs).
*** TODO test libsemaphore
- call =os_signal= from a periodic interrupt
- call =os_wait= in the main loop and watch the loop step after =os_signal=
*** [1/2] profiling compile-time flag
- [X] compiles minimally intrusive pin-toggling code to
identify when and what tcb is running
- [ ] measure PIDWork with and without the profiling code
*** [0/2] guarantee UART never loses data
- [ ] stress test :: Hammer it and increase the capacity until no chars
                 are dropped from libuart or libshell
- [ ] profile ::  Create a table like Table 2.1 in [[./Lab02.pdf]]
*** IN-PROGRESS make callback to task scheduler explicit
*** TODO Task 1 : Software triggered data acquisition and filtering
What's the AR? I have no idea.
**** notes
For the data acquisition system DAS, the software must start the
analog-to-digital converter (ADC) and read the result at precise time
intervals.

In Labs 2 and 3, f_s is 2 kHz.

I don't know what the fuck this page is asking me to do.
*** TODO Task 2 : Aperiodic task triggered by the select switch
A background thread =ButtonPush= should be run whenever the user touches
the select button. This task will create a foreground thread that:

1. outputs to the LCD,
2. sleeps for 50ms,
3. outputs again to the LCD, then
4. kills itself

Note: if the user pushes the button faster than once every two
seconds, multiple foreground threads will exist simultaneously.
*** TODO Task 3 : Hardware triggered data acquisition and FFT
This task will sample the ADC every 400 Hz (2.5 ms) via a
hardware-triggered timer.

1. start collecting data (takes 64 ms)
2. fft on the block, when done trigger interrupt
3. ADC ISR (=producer=) pushes with =OS_Fifo_Put= into global mem space
4. =Consumer= foreground thread calculates the FFT
   question: so the fft is calculated twice? once by us once by
   hardware?

*Note*: you *must* use 16-bit mode for timer-triggered adc sampling.
*** IN-PROGRESS Task 4 : CPU Bound task
#+BEGIN_SRC c
  /* NOTE: this is a rough draft, never compiled, never spell checked */
  uint32_t PID_RECORD = 0;
  uint32_t PID_WORK = 0;

  void pid_slave_thread(void) {

    ++PID_WORK;
  }

  void pid_record_arbiter(void) {

    if(PID_RECORD < PID_WORK) {
      PID_RECORD = PID_WORK;
    }
    /* Sorry Sisyphus */
    PID_WORK = 0;

    /* os_surrender_context(); */
  }

  void main(void) {

    os_threading_init();
    os_add_thread()
    postpone_death();
  }
#+END_SRC
- increment PIDWork (global var) continually
- reset it to 0 each time you are granted foreground
- try to maximize high water mark of PIDWork
*** TODO Task 5 : User interface with a command line interpreter
- use libshell developed in Lab 1
**** IN-PROGRESS answer esc's questions
[[../../lib/libshell/shell.c]]
All invocations to uart_send are through uart.h. Should this be to
libhw, who then queues it? Is this thread-save? is libuart?
- I guess so, uart sends chars with an interrupt, doesn't it? pendsv
  won't interrupt it IF WE SENT PENDSV CORRECTLY. The way we're
  heading, we'll need a TxFIFO won't we?
*** [0/4] Checkout
- [ ] Run the software system and explain the profiling data to the TA
- [ ] Discuss the sketches you created as part of prep & procedure
- [ ] Discuss the TCB before and after a thread switch
- [ ] Identify inefficiencies in your implementation
*** [0/16] Deliverables
- 20 points :: report
- 10 points :: software quality

- [ ] objectives :: 1/2 page max
- [ ] hardware design :: none
- [ ] software design :: spinlock/round-robin switching source
- [0/6] measurement data :: graphs and tables of data
   - [ ] plots of the logic analyzer
      see Figures 2.1, 2.2, 2.3, 2.4, and 2.8
   - [ ] measurement of the thread-switch time
   - [ ] plot of the logic analyzer running spinlock/round-robin
   - [ ] the four sketches with measured data collected during testing
      from first preparation parts 3 and 5
   - [ ] a table each showing performance measurements versus sizes of
      OS_Fifo and timeslices
      like Table 2.1
   - [ ] table showing performance measurements with/without debugging instruments
- [0/7] analysis and discussion :: 2 page maximum
   - [ ] Why did the time jitter in my solution jump from 4 to 6 Î¼s when
      interpreter I/O occurred?
   - [ ] Justify why Task 3 has no time jitter on its ADC sampling.
   - [ ] There are four (or more) interrupts in this system DAS, ADC,
      Select, and SysTick (thread switch).
      Justify your choice of hardware priorities in the NVIC?
   - [ ] Explain what happens if your stack size is too small.
      How could you detect stack overflow? How could you prevent stack overflow from crashing the OS?
   - [ ] Both Consumer and Display have an OS_Kill() at the end. Do these
      OS_Kills always execute, sometime execute, or never execute?
      Explain.
   - [ ] The interaction between the producer and consumer is
      deterministic. What does deterministic mean?
      - Assume for this question that if the OS_Fifo has 5 elements data
      is lost, but if it has 6 elements no data is lost.
      - What does this tell you about the timing of the consumer plus display?
   - [ ] Without going back and actually measuring it, do you think the
      Consumer ever waits when it calls OS_MailBox_Send?
      Explain.
