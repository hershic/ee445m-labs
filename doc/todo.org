#+startup: all
#+todo: TODO(t) VERIFY(v) IN-PROGRESS(p) DOCUMENT(m) PRINT(r) | OPTIONAL(o) HIATUS(h) DONE(d) CANCELED(c)
* [2/2] Global
** OPTIONAL Code review
[[http://www.vogella.com/tutorials/Gerrit/article.html][Gerrit code review - Tutorial]]
** OPTIONAL Continuous Integration
* [1/15] lib
"In a real time system there is no point in finishing your task before
the deadline." -- Gerstlauer
** [0/1] SysTick
*** TODO Initialization macro
convert this code into a single call that is readable, i.e. you can
immediately tell to what frequency/period the SysTick will interrupt.
#+BEGIN_SRC c :tangle no
  SysTickPeriodSet(SysCtlClockGet() / 10);
  SysTickEnable();
  SysTickIntEnable();
#+END_SRC
** [0/5] OS
*** TODO Thread addition macro
Create a macro to map over supplied threads and do this sort of
initialization. The only next step is os_launch, which should still be
called separately (comment created <2015-02-17 Tue>).
#+BEGIN_SRC c :tangle no
  IntMasterDisable();
  os_threading_init();
  os_add_thread(Thread1);
  os_add_thread(Thread2);
  os_add_thread(Thread3);
#+END_SRC
*** TODO Convert to libut/utlist
*** TODO fn to get tcb from thread's starting point
#+BEGIN_SRC c :tangle no
  void idle();
  os_add_thread(idle);
  os_get_tcb(idle); // returns the tcb containing idle
#+END_SRC
*** TODO define os_surrender_execution
*** TODO Create semaphore.dox
*** [0/2] define schedulers
See Rate Monotonic Scheduling for inspiration
- [ ] round-robin
- [ ] at least one other
** [0/1] Nexus
*** TODO interruptless-blocks
a lisp/ruby-style object to accept a block and ensure no interrupts
fire while it is executing (makes it atomic, wraps with Critical
sections, something of the sort)
** [0/1] Jitter
*** TODO create library
** [0/5] Debugging and total authoritarianism enforcement
*** TODO Check on changed immutables?
*** TODO create automated testing framework
urged by lecture <2015-02-17 Tue>
- place a magic packet in memory at the end of your stack, check for
  changed contents
*** TODO create stack watcher
die on attempted overflow
*** TODO reposition the memory
don't shoot yourself in the foot with a lodaed stac
(insert picture here)
*** TODO path expressions
urged by lecture <2015-02-17 Tue>
[[http://en.wikipedia.org/wiki/Eiffel_(programming_language)][Eiffel (programming language)]]
[[./img/path_expressions_lec04.png]]
- specify and enforce correct calling order
- represented as a graph
  choose one of the following representations based on sparseness of
  the data structures:
  - adjacency list
  - adjacency matrix
** [0/1] Doxygen
*** TODO add everythig to a group! it's all we have sans c++ inheritance.
** [1/1] framebuffer
*** OPTIONAL create flag to enable per-pixel-manipulation
compile time flag?
* [7/13] bin
** [4/6] dev environment
*** DONE openocd
*** [0/1] setenv
**** TODO Clean exit when invoked twice
currently prints help and exits (seemingly ambiguously)

*** [2/3] emacs
**** DONE eldoc for our functions
#+BEGIN_SRC emacs-lisp :tangle no
  (load "c-eldoc")
  (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+END_SRC
**** DONE disaster for arm
**** TODO Doxymacs
[[http://doxymacs.sourceforge.net/]]
**** [0/1] gdb helper
- [ ] flash and reload
*** DONE cmd to open screen on the M4
** [3/7] Doxygen
*** TODO special words
like immutable
define in doxygen and also highlight in emacs
make a mode for our dev environment - source disaster-arm, assign
keybinding, c-eldoc, and turn on pseudo-reserved word highlighting
*** DONE publish Doxygen on an external website
      http://hershic.github.io/ee445m-labs/
*** DONE link all doxygen projects together to show on one page
*** DONE link github to the online documentation
*** IN-PROGRESS script to update all doxygen files at once
- I have a hankering to refactor all Doxyfiles into a specific dir
- bash doxygenizing broke!
*** TODO Allow here docs in declare -r statements
I found a link with possibile insight. It's in one of my compter's
stack (bookmarks dir- chrome)
*** TODO make doxygen html output a consistent format
